<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-50">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tipster-AI Admin</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css" rel="stylesheet">
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="js/config.js?v=4.1.1"></script>
    <script src="js/utils.js?v=4.1.1"></script>
    <script src="js/database.js?v=4.1.1"></script>
    <script src="js/engine.js?v=4.1.1"></script>
    <script type="module" src="js/utils/evaluate.js?v=elite_1.0"></script>

    <link rel="stylesheet" href="css/admin.css?v=elite_2.7">
</head>

<body class="h-full text-gray-800">
    <!-- ADMIN LOGIN SCREEN -->
    <div id="admin-login-screen"
        class="fixed inset-0 bg-gradient-to-br from-blue-900 to-purple-900 flex items-center justify-center z-50">
        <div class="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md">
            <div class="text-center mb-6">
                <img src="logo.png" alt="Tipster-AI" class="h-16 w-16 mx-auto mb-4 rounded-xl">
                <h1 class="text-2xl font-bold text-gray-900">Admin Panel</h1>
                <p class="text-sm text-gray-600 mt-2">Accesso riservato</p>
            </div>

            <button id="google-signin-btn"
                class="w-full bg-white border-2 border-gray-300 text-gray-700 py-3 px-4 rounded-lg font-bold hover:bg-gray-50 transition flex items-center justify-center gap-3">
                <svg class="w-5 h-5" viewBox="0 0 24 24">
                    <path fill="#4285F4"
                        d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                    <path fill="#34A853"
                        d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                    <path fill="#FBBC05"
                        d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                    <path fill="#EA4335"
                        d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
                </svg>
                Accedi con Google
            </button>

            <div id="admin-login-error"
                class="hidden mt-4 p-3 bg-red-100 border border-red-300 rounded-lg text-red-700 text-sm">
            </div>
        </div>
    </div>

    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center max-w-md px-4">
            <div id="loading-spinner" class="text-white text-xl font-semibold animate-pulse mb-2">Inizializzazione...
            </div>
            <div id="auth-status"
                class="text-blue-200 text-sm font-mono bg-gray-800 p-2 rounded border border-gray-700">Attesa
                connessione...</div>
            <button id="retry-auth-btn"
                class="hidden mt-4 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Riprova</button>
        </div>
    </div>

    <div id="admin-content" class="min-h-full flex flex-col hidden">
        <!-- Header -->
        <header class="bg-white shadow-sm">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center py-4">
                    <div class="flex items-center">
                        <img src="logo.png" alt="Tipster-AI Logo" class="h-10 w-10 mr-3 rounded-lg">
                        <h1 class="text-xl font-bold text-gray-900">Tipster-AI Admin</h1>
                    </div>
                    <div class="flex items-center gap-4">
                        <div class="text-sm text-gray-600">
                            <i class="fa-solid fa-user-shield mr-1"></i>
                            <span id="admin-email-display"></span>
                        </div>
                        <button id="admin-logout-btn"
                            class="bg-red-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-700 transition text-sm">
                            <i class="fa-solid fa-sign-out-alt mr-1"></i>Esci
                        </button>
                    </div>
                </div>
                <div class="border-t border-gray-200 pt-4">
                    <nav class="flex flex-wrap gap-2">
                        <button data-page="page-dashboard"
                            class="nav-button bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold shadow-sm hover:bg-blue-700 transition-colors text-sm">
                            <i class="fa-solid fa-chart-bar mr-1"></i>Dashboard
                        </button>

                        <!-- NEW TABS -->
                        <button data-page="page-inserisci"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-file-import mr-1"></i>Inserisci Partite
                        </button>
                        <button data-page="page-pronostici"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-trophy mr-1"></i>Pronostici
                        </button>
                        <button data-page="page-trading-30"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-bolt-lightning mr-1 text-emerald-600"></i>Trading 3.0
                        </button>

                        <button data-page="page-gestione-db"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-database mr-1"></i>Gestione DB
                        </button>
                        <button data-page="page-ai-instructions"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-robot mr-1"></i>Istruzioni AI
                        </button>

                        <!-- OLD TABS (HIDDEN - for compatibility) -->
                        <button data-page="page-oggi" style="display:none"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-calendar-day mr-1"></i>Oggi
                        </button>
                        <button data-page="page-risultati" style="display:none"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-check-circle mr-1"></i>Risultati
                        </button>
                        <button data-page="page-ranking" style="display:none"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-trophy mr-1"></i>Ranking
                        </button>
                        <button data-page="page-storico" style="display:none"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-clock-rotate-left mr-1"></i>Storico
                        </button>
                    </nav>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main id="main-content" class="flex-grow">

            <!-- PAGINA DASHBOARD -->
            <div id="page-dashboard" class="page active max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Sticky Stats -->
                <div id="stats-container"
                    class="sticky top-0 z-10 bg-gray-50/80 backdrop-blur-sm py-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-8">
                </div>

                <!-- Filters -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-8">
                    <div class="flex flex-col md:flex-row gap-4 mb-4 items-center">
                        <div class="relative w-full md:w-64 hidden"> <!-- Search moved below -->
                            <input type="text" id="search-input-hidden" placeholder="Cerca lega o squadra..."
                                class="w-full pl-10 pr-4 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                            <i
                                class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        </div>
                        <div class="flex items-center gap-2 w-full md:w-auto">
                            <label class="text-sm font-medium text-gray-700">Periodo:</label>
                            <input type="date" id="filter-date-start" class="p-2 border rounded-lg">
                            <input type="date" id="filter-date-end" class="p-2 border rounded-lg">
                            <button id="show-no-result-btn"
                                class="bg-orange-500 text-white px-3 py-2 rounded-lg font-semibold text-sm hover:bg-orange-600 transition shadow-sm ml-2"
                                title="Mostra solo partite senza risultato">
                                <i class="fa-solid fa-filter mr-1"></i> Senza Risultato
                            </button>
                        </div>
                    </div>

                    <!-- STRATEGY BUILDER & CLIENT MANAGEMENT -->
                    <div class="bg-white p-6 rounded-xl shadow-md border border-gray-200 mb-8">
                        <div class="flex items-center gap-2 mb-4">
                            <i class="fa-solid fa-wand-magic-sparkles text-purple-600 text-xl"></i>
                            <h3 class="text-lg font-bold text-gray-800">Gestione Strategie & Filtri</h3>
                        </div>
                        <p class="text-sm text-gray-500 mb-6">Crea, testa e pubblica le strategie per il Client.</p>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            <!-- COL 1: EXPORT & LOCAL STRATEGIES -->
                            <div class="bg-blue-50 p-4 rounded-xl border border-blue-200">
                                <h4 class="font-bold text-gray-700 mb-3 flex items-center gap-2">
                                    <i class="fa-solid fa-flask text-purple-600"></i> Gestione Strategie (Locale)
                                    <span id="matches-count"
                                        class="ml-auto text-xs bg-blue-200 text-blue-800 py-1 px-2 rounded-full">Locale
                                        (0)</span>
                                </h4>
                                <div class="space-y-4">
                                    <div>
                                        <label class="block text-xs font-medium text-gray-500 mb-1">Strategie Salvate
                                            (Locale)</label>
                                        <div class="flex gap-2">
                                            <select id="saved-strategies-select"
                                                class="flex-grow p-2 border rounded text-sm bg-white">
                                                <option value="">Seleziona...</option>
                                            </select>
                                            <button id="load-filter-btn"
                                                class="bg-blue-600 text-white px-3 py-2 rounded hover:bg-blue-700"
                                                title="Carica Filtri">
                                                <i class="fa-solid fa-upload"></i>
                                            </button>
                                            <button id="delete-filter-btn"
                                                class="bg-red-500 text-white px-3 py-2 rounded hover:bg-red-600"
                                                title="Elimina">
                                                <i class="fa-solid fa-trash"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="text-xs text-gray-400 mt-2">
                                        <i class="fa-solid fa-info-circle mr-1"></i> Queste strategie sono visibili solo
                                        a te per testare i filtri.
                                    </div>
                                    <!-- Save Local Section -->
                                    <div class="mt-4 pt-3 border-t border-gray-200">
                                        <label class="block text-xs font-medium text-gray-500 mb-1">Salva Nuova
                                            Strategia Test</label>
                                        <div class="flex gap-2">
                                            <input type="text" id="local-strategy-name" placeholder="Nome strategia..."
                                                class="flex-grow p-2 border rounded text-sm">
                                            <button id="save-local-btn"
                                                class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 font-bold"
                                                title="Salva Localmente">
                                                <i class="fa-solid fa-floppy-disk mr-1"></i>Salva
                                            </button>
                                        </div>
                                    </div>
                                    <!-- Reset & Export moved here -->
                                    <div class="flex gap-2 mt-4">
                                        <button id="reset-filters-btn"
                                            class="bg-gray-500 text-white px-3 py-2 rounded text-sm hover:bg-gray-600 flex-1">
                                            <i class="fa-solid fa-arrows-rotate mr-1"></i>Reset
                                        </button>
                                        <button id="export-filtered-btn"
                                            class="bg-blue-600 text-white px-3 py-2 rounded text-sm hover:bg-blue-700 flex-1">
                                            <i class="fa-solid fa-file-csv mr-1"></i>Export CSV
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- COL 2: CLIENT MANAGEMENT -->
                            <div class="bg-yellow-50 p-4 rounded-xl border border-yellow-200">
                                <h4 class="font-bold text-gray-700 mb-3 flex items-center gap-2">
                                    <i class="fa-solid fa-users text-green-600"></i> Gestione Client (Pubblico)
                                </h4>
                                <div class="space-y-4">
                                    <!-- Select Client Filter -->
                                    <div>
                                        <label class="block text-xs font-medium text-gray-500 mb-1">Filtri Attivi su
                                            Client</label>
                                        <div class="flex gap-2">
                                            <select id="client-filters-select"
                                                class="flex-grow p-2 border rounded text-sm bg-white">
                                                <option value="">Caricamento...</option>
                                            </select>
                                            <button id="delete-client-filter-btn"
                                                class="bg-red-500 text-white px-3 py-2 rounded hover:bg-red-600"
                                                title="Elimina dal Client">
                                                <i class="fa-solid fa-trash"></i>
                                            </button>
                                        </div>

                                        <!-- Editable Name Field (appears when strategy selected) -->
                                        <div id="edit-strategy-name-container" class="hidden mt-3">
                                            <label class="block text-xs font-medium text-gray-700 mb-1">
                                                <i class="fa-solid fa-pen mr-1"></i>Nome Strategia
                                            </label>
                                            <div class="flex gap-2">
                                                <input type="text" id="edit-strategy-name"
                                                    placeholder="Nome strategia..."
                                                    class="flex-grow p-2 border-2 border-blue-300 rounded text-sm font-semibold focus:border-blue-500 focus:ring-2 focus:ring-blue-200">
                                                <button id="update-client-filter-btn"
                                                    class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 font-bold shadow-sm whitespace-nowrap">
                                                    <i class="fa-solid fa-save mr-1"></i>Aggiorna Strategia
                                                </button>
                                            </div>
                                            <div class="text-xs text-gray-500 mt-1">
                                                <i class="fa-solid fa-info-circle mr-1"></i>
                                                Puoi modificare il nome e i filtri, poi clicca "Aggiorna Strategia"
                                            </div>
                                        </div>
                                    </div>

                                    <hr class="border-yellow-200">

                                    <!-- Save New Strategy -->
                                    <div>
                                        <label class="block text-xs font-medium text-gray-500 mb-1">Pubblica Nuova
                                            Strategia</label>
                                        <div class="flex gap-2">
                                            <input type="text" id="new-strategy-name"
                                                placeholder="Nome (es. Over 2.5 Safe)..."
                                                class="flex-grow p-2 border rounded text-sm">
                                            <button id="save-filter-btn"
                                                class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 font-bold shadow-sm whitespace-nowrap">
                                                <i class="fa-solid fa-cloud-arrow-up mr-2"></i>Pubblica
                                            </button>
                                        </div>
                                        <div class="text-xs text-gray-500 mt-1">
                                            Salva i filtri attuali (sotto) come strategia pubblica.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <!-- LEFT COLUMN: Leagues -->
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <label class="block text-sm font-medium text-gray-700">Leghe</label>
                                <div>
                                    <button id="update-favorites-btn"
                                        class="text-xs text-green-600 hover:underline font-semibold mr-4">Aggiorna
                                        Preferiti</button>
                                    <button id="reset-leagues-btn"
                                        class="text-xs text-blue-600 hover:underline font-semibold">Azzera
                                        Leghe</button>
                                </div>
                            </div>
                            <div id="league-filters-grid" class="grid grid-cols-1 sm:grid-cols-2 gap-2"></div>
                        </div>

                        <!-- RIGHT COLUMN: Sliders & Tips -->
                        <div class="space-y-4">
                            <!-- Probabilit√† Slider + Inputs -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Probabilit√† (%)</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="prob-min-input" min="0" max="100" value="0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                    <div class="flex-1">
                                        <div id="probability-slider" class="mx-2"></div>
                                    </div>
                                    <input type="number" id="prob-max-input" min="0" max="100" value="100"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                </div>
                            </div>

                            <!-- Quota Slider + Inputs -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Quota</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="odds-min-input" min="1.0" max="10.0" step="0.01"
                                        value="1.0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                    <div class="flex-1">
                                        <div id="odds-slider" class="mx-2"></div>
                                    </div>
                                    <input type="number" id="odds-max-input" min="1.0" max="10.0" step="0.01"
                                        value="10.0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                </div>
                            </div>

                            <!-- Tips -->
                            <div class="pt-2">
                                <div class="flex justify-between items-center mb-1">
                                    <label class="block text-sm font-medium text-gray-700">Tips</label>
                                    <button id="reset-tips-btn"
                                        class="text-xs text-blue-600 hover:underline font-semibold">Azzera Tips</button>
                                </div>
                                <div id="tip-filters-container"
                                    class="w-full p-2 border rounded-lg bg-gray-50 flex flex-wrap gap-2"></div>
                            </div>

                            <!-- üî• Filtro Magia (AI / Non-AI) -->
                            <div class="pt-2">
                                <label class="block text-sm font-medium text-gray-700 mb-1">Origine Dati</label>
                                <select id="magia-filter" class="w-full p-2 border rounded-lg text-sm bg-white">
                                    <option value="all">Tutti (AI + Betmines + Consenso)</option>
                                    <option value="AI">Solo Magia AI</option>
                                    <option value="OK">Solo Consenso (entrambe fonti)</option>
                                    <option value="betmines">Solo Betmines</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Match List -->
                <div id="match-list-container" class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <!-- Search Bar Row -->
                    <div class="mb-4">
                        <div class="relative w-full">
                            <input type="text" id="search-input" placeholder="üîç Cerca lega, squadra o tip..."
                                class="w-full pl-10 pr-4 py-2 border-2 border-blue-100 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-blue-50/30">
                            <i
                                class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-blue-400"></i>
                        </div>
                    </div>

                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">Partite filtrate (<span id="filtered-count">0</span>)</h3>

                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-gray-700 whitespace-nowrap">Ordina per:</label>
                            <select id="dashboard-sort-select" class="p-2 border rounded-lg text-sm">
                                <option value="data-desc">üìÖ Data (recente)</option>
                                <option value="orario-asc">‚è∞ Orario (cronologico)</option>
                                <option value="lega">Lega</option>
                                <option value="quota">Quota</option>
                            </select>
                        </div>
                    </div>
                    <div class="max-h-[60vh] overflow-y-auto custom-scrollbar">
                        <table class="w-full text-sm text-left">
                            <thead class="bg-gray-100 text-xs uppercase sticky top-0">
                                <tr>
                                    <th class="p-3 font-semibold sortable-header" data-sort="data">Data <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="lega">Lega <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center">Magia</th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="partita">Partita <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="tip">Tip <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center">Ris.</th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="probabilita">
                                        Prob. <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="quota">
                                        Quota <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center" title="Over 0.5 HT - Info primo tempo">HT
                                    </th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="esito">
                                        Esito <i class="fa-solid fa-sort sort-icon"></i></th>
                                </tr>
                            </thead>
                            <tbody id="match-list-body" class="divide-y"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- PAGINA INSERISCI PARTITE (New Unified Interface) -->
            <div id="page-inserisci" class="page max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-8">

                <!-- Header -->
                <div class="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-6 rounded-2xl shadow-lg mb-8">
                    <h1 class="text-3xl font-bold flex items-center gap-3">
                        <i class="fa-solid fa-file-import"></i>
                        Inserisci Partite
                    </h1>
                    <p class="text-blue-100 mt-2">Carica tips e risultati per il giorno selezionato</p>
                </div>

                <!-- Quick Navigation -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <button onclick="document.querySelector('[data-page=page-oggi]').click()"
                        class="bg-blue-500 hover:bg-blue-600 text-white p-6 rounded-xl shadow-lg transition-all transform hover:scale-105">
                        <i class="fa-solid fa-calendar-plus text-4xl mb-3"></i>
                        <h3 class="text-xl font-bold mb-2">üì• Carica Tips</h3>
                        <p class="text-blue-100 text-sm">Carica pronostici per una data specifica</p>
                    </button>

                    <button onclick="document.querySelector('[data-page=page-risultati]').click()"
                        class="bg-green-500 hover:bg-green-600 text-white p-6 rounded-xl shadow-lg transition-all transform hover:scale-105">
                        <i class="fa-solid fa-check-circle text-4xl mb-3"></i>
                        <h3 class="text-xl font-bold mb-2">‚úÖ Aggiorna Risultati</h3>
                        <p class="text-green-100 text-sm">Inserisci risultati delle partite giocate</p>
                    </button>
                </div>

                <!-- Catalogo Leghe API -->
                <div id="catalog-section" class="bg-white p-4 rounded-xl shadow-md border border-gray-200 mb-4">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <i class="fa-solid fa-database text-purple-500 text-2xl"></i>
                            <div>
                                <h3 class="font-bold text-gray-800">üìö Catalogo Leghe API-Football</h3>
                                <p id="main-catalog-status" class="text-sm text-gray-500">Verifica stato...</p>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button id="main-download-catalog-btn"
                                class="bg-purple-600 text-white px-3 py-2 rounded-lg font-semibold hover:bg-purple-700 transition-colors text-sm">
                                üì• Scarica API
                            </button>
                            <button id="export-catalog-btn"
                                class="bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                                üíæ Esporta JSON
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Registry Leghe (Associazioni) -->
                <div id="registry-section" class="bg-white p-4 rounded-xl shadow-md border border-blue-200 mb-6">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <i class="fa-solid fa-link text-blue-500 text-2xl"></i>
                            <div>
                                <h3 class="font-bold text-gray-800">üîó Registry Leghe (Nostre Mappature)</h3>
                                <p id="registry-status" class="text-sm text-gray-500">Verifica stato...</p>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button id="associate-all-leagues-btn"
                                class="bg-blue-600 text-white px-3 py-2 rounded-lg font-semibold hover:bg-blue-700 transition-colors text-sm">
                                üîÑ Associa Tutte
                            </button>
                            <button id="import-registry-btn"
                                class="bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                                üì• Importa Registry
                            </button>
                            <input type="file" id="import-registry-input" class="hidden" accept=".json">
                            <button id="export-registry-btn"
                                class="bg-gray-200 text-gray-700 px-3 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                                üíæ Esporta Registry
                            </button>
                            <button id="clear-registry-btn"
                                class="bg-red-50 text-red-600 px-3 py-2 rounded-lg font-semibold border border-red-200 hover:bg-red-100 transition-colors text-sm">
                                üóëÔ∏è Svuota Registry
                            </button>
                            <button id="list-leagues-btn"
                                class="bg-amber-500 text-white px-3 py-2 rounded-lg font-semibold hover:bg-amber-600 transition-colors text-sm">
                                <i class="fa-solid fa-list-check mr-1"></i> Elenca Leghe
                            </button>
                            <div id="leagues-list-modal"
                                class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center p-4">
                                <div
                                    class="bg-white rounded-2xl shadow-2xl w-full max-w-5xl max-h-[90vh] flex flex-col">
                                    <div
                                        class="p-6 border-b flex justify-between items-center bg-amber-50 rounded-t-2xl">
                                        <h2 class="text-2xl font-bold text-amber-800 flex items-center gap-2">
                                            <i class="fa-solid fa-trophy"></i> Registry Intelligence
                                        </h2>
                                        <button id="close-leagues-list-btn"
                                            class="text-gray-500 hover:text-red-600 transition-colors">
                                            <i class="fa-solid fa-circle-xmark text-3xl"></i>
                                        </button>
                                    </div>
                                    <div class="p-6 overflow-y-auto custom-scrollbar flex-grow">
                                        <div class="mb-4 relative">
                                            <input type="text" id="league-list-search" placeholder="Cerca lega..."
                                                class="w-full p-3 pl-10 border-2 border-amber-100 rounded-xl focus:ring-2 focus:ring-amber-500 focus:border-amber-500">
                                            <i
                                                class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-amber-400"></i>
                                        </div>
                                        <table class="w-full text-sm text-left border-collapse">
                                            <thead
                                                class="bg-amber-100/50 sticky top-0 uppercase text-xs font-bold text-amber-900">
                                                <tr>
                                                    <th class="p-3 border-b border-amber-200">Nome Lega (Nostra)</th>
                                                    <th class="p-3 border-b border-amber-200">ID API</th>
                                                    <th class="p-3 border-b border-amber-200">Varianti (Alias)</th>
                                                    <th class="p-3 border-b border-amber-200 text-center">TRADING</th>
                                                    <th class="p-3 border-b border-amber-200">Trust Score</th>
                                                    <th class="p-3 border-b border-amber-200">Assetto</th>
                                                    <th class="p-3 border-b border-amber-200">Samples</th>
                                                    <th class="p-3 border-b border-amber-200">WR O1.5</th>
                                                    <th class="p-3 border-b border-amber-200"></th>
                                                </tr>
                                            </thead>
                                            <tbody id="leagues-list-body"
                                                class="divide-y divide-gray-100 text-gray-700">
                                                <!-- Content here -->
                                            </tbody>
                                        </table>
                                    </div>
                                    <div class="p-4 border-t bg-gray-50 text-right rounded-b-2xl">
                                        <span class="text-xs text-gray-500">Totale Leghe nel Registry: <span
                                                id="total-leagues-registry-count" class="font-bold">0</span></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Report Associazione -->
                    <div id="association-report" class="mt-4 hidden">
                        <div id="association-progress" class="mb-3 text-sm text-blue-600"></div>

                        <!-- Contatori -->
                        <div class="grid grid-cols-3 gap-3 mb-4">
                            <div class="bg-green-50 p-3 rounded-lg border border-green-200 text-center">
                                <div id="matched-count" class="text-2xl font-bold text-green-600">0</div>
                                <div class="text-xs text-green-700">‚úÖ Matchate</div>
                            </div>
                            <div class="bg-orange-50 p-3 rounded-lg border border-orange-200 text-center">
                                <div id="ambiguous-count" class="text-2xl font-bold text-orange-600">0</div>
                                <div class="text-xs text-orange-700">‚ö†Ô∏è Ambigue</div>
                            </div>
                            <div class="bg-red-50 p-3 rounded-lg border border-red-200 text-center">
                                <div id="notfound-count" class="text-2xl font-bold text-red-600">0</div>
                                <div class="text-xs text-red-700">‚ùå Non Trovate</div>
                            </div>
                        </div>

                        <!-- Lista Ambigue -->
                        <div id="ambiguous-section" class="hidden mb-4">
                            <h4 class="font-bold text-orange-700 mb-2">‚ö†Ô∏è Leghe Ambigue (scegli l'opzione corretta):
                            </h4>
                            <div id="ambiguous-list" class="space-y-2 max-h-48 overflow-y-auto"></div>
                        </div>

                        <!-- Lista Non Trovate -->
                        <div id="notfound-section" class="hidden mb-4">
                            <h4 class="font-bold text-red-700 mb-2">‚ùå Leghe Non Trovate:</h4>
                            <div id="notfound-list" class="space-y-2 max-h-48 overflow-y-auto text-sm"></div>
                        </div>

                        <!-- Bottone Salva -->
                        <button id="save-associations-btn"
                            class="hidden w-full bg-green-600 text-white font-semibold py-2 rounded-lg hover:bg-green-700">
                            ‚úÖ Salva Tutte le Associazioni
                        </button>
                    </div>
                </div>

                <!-- Info -->
                <div class="bg-white p-6 rounded-xl shadow-md border border-gray-200">
                    <div class="flex items-start gap-4">
                        <i class="fa-solid fa-circle-info text-blue-500 text-2xl mt-1"></i>
                        <div>
                            <h3 class="font-bold text-lg mb-2">Come funziona</h3>
                            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                                <li><strong>Carica Tips:</strong> Upload CSV con pronostici (prima dei match)</li>
                                <li><strong>Aggiungi HT (opzionale):</strong> Dati Over 0.5 HT per boost ranking</li>
                                <li><strong>Aggiorna Risultati:</strong> Dopo i match, upload CSV risultati</li>
                                <li><strong>Calcola esiti automatici:</strong> Il sistema determina Vinto/Perso</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>



            <!-- PAGINA OGGI (Old - Keep for compatibility) -->
            <div id="page-oggi" class="page max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4 border-b pb-2">üì• Carica Tips del Giorno</h2>

                    <!-- Info ordine caricamento -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 text-sm">
                        <i class="fa-solid fa-circle-info text-blue-500 mr-2"></i>
                        <strong>Ordine libero:</strong> Puoi caricare prima Tips e poi HT, o viceversa. Il sistema
                        far√†
                        il merge automaticamente.
                    </div>

                    <div class="space-y-6">
                        <div>
                            <label for="tips-date" class="block text-sm font-medium text-gray-700 mb-1">Data
                                Partite</label>
                            <input type="date" id="tips-date"
                                class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>

                        <!-- METODO CLASSICO: CSV IN ALTO -->
                        <div class="space-y-4">
                            <!-- STEP 1: Tips principale -->
                            <div class="border-2 border-blue-200 rounded-lg p-4 bg-blue-50/30">
                                <label for="tips-csv-file" class="block text-sm font-medium text-gray-700 mb-1">
                                    <span class="bg-blue-600 text-white text-xs px-2 py-1 rounded mr-2">TIPS</span>
                                    File CSV Tips (senza risultati)
                                </label>
                                <input type="file" id="tips-csv-file" accept=".csv"
                                    class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                                <div id="tips-file-status" class="mt-2 text-xs text-gray-500 hidden">
                                    <i class="fa-solid fa-check-circle text-green-500 mr-1"></i>
                                    <span id="tips-file-name"></span>
                                </div>
                            </div>

                            <!-- STEP 2: HT opzionale -->
                            <div class="border-2 border-purple-200 rounded-lg p-4 bg-purple-50/30">
                                <label for="tips-ht-file"
                                    class="block text-sm font-medium text-gray-700 mb-1 flex items-center gap-2">
                                    <span class="bg-purple-600 text-white text-xs px-2 py-1 rounded mr-2">HT</span>
                                    File CSV 0.5 HT (Opzionale - per boost ranking)
                                    <span class="text-xs text-gray-500 font-normal cursor-help"
                                        title="Aggiungi dati Over 0.5 HT per timing gol e boost ranking">
                                        <i class="fa-solid fa-circle-info"></i>
                                    </span>
                                </label>
                                <input type="file" id="tips-ht-file" accept=".csv"
                                    class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100">
                                <div id="ht-file-status" class="mt-2 text-xs text-gray-500 hidden">
                                    <i class="fa-solid fa-check-circle text-green-500 mr-1"></i>
                                    <span id="ht-file-name"></span> - <span id="ht-match-count"></span> partite con HT
                                </div>
                            </div>

                            <div id="tips-upload-preview" class="hidden bg-gray-50 p-4 rounded-lg border"></div>
                        </div>

                        <div class="relative py-4">
                            <div class="absolute inset-0 flex items-center" aria-hidden="true">
                                <div class="w-full border-t-2 border-dashed border-gray-200"></div>
                            </div>
                            <div class="relative flex justify-center">
                                <span
                                    class="px-4 bg-white text-[10px] font-black text-gray-400 uppercase tracking-widest">Oppure
                                    Integra con Palinsesto Mondiale AI</span>
                            </div>
                        </div>

                        <!-- üî• NEW v13.0: Magia AI World Domination Button (IN BASSO) -->
                        <div
                            class="p-4 bg-gradient-to-br from-purple-50 to-indigo-50 border-2 border-purple-200 rounded-xl shadow-sm">
                            <h3
                                class="text-xs font-black text-purple-700 uppercase tracking-widest mb-3 flex items-center gap-2">
                                <i class="fa-solid fa-wand-magic-sparkles"></i> Nuova Era: Riempimento Automatico AI
                            </h3>
                            <button id="load-magia-ai-btn"
                                class="w-full bg-gradient-to-r from-purple-600 to-indigo-600 text-white py-4 rounded-2xl font-black hover:from-purple-700 hover:to-indigo-700 transition-all shadow-lg flex items-center justify-center gap-3 group">
                                <i class="fa-solid fa-globe text-xl group-hover:rotate-12 transition-transform"></i>
                                CARICA PARTITE MAGIA AI
                            </button>

                            <div class="grid grid-cols-2 gap-3 mt-4">
                                <button id="view-magia-ai-btn"
                                    class="bg-white border-2 border-purple-300 text-purple-700 py-2 rounded-xl font-black text-xs hover:bg-purple-50 transition-all flex items-center justify-center gap-2">
                                    <i class="fa-solid fa-eye"></i> VISUALIZZA
                                </button>
                                <button id="download-magia-ai-btn"
                                    class="bg-white border-2 border-indigo-300 text-indigo-700 py-2 rounded-xl font-black text-xs hover:bg-indigo-50 transition-all flex items-center justify-center gap-2">
                                    <i class="fa-solid fa-download"></i> SCARICA CSV
                                </button>
                            </div>

                            <p
                                class="text-[10px] text-purple-600 mt-2 text-center font-bold uppercase tracking-tighter">
                                <i class="fa-solid fa-bolt"></i> Riempie i vuoti del DB Oro con i match mancanti scovati
                                dall'AI
                            </p>

                            <!-- üî• VISUALIZZAZIONE SANDBOX COMPLETA -->
                            <div id="sandbox-preview-container"
                                class="hidden mt-4 bg-white border-2 border-purple-300 rounded-xl p-4 max-h-96 overflow-y-auto">
                                <div class="flex items-center justify-between mb-3">
                                    <h4
                                        class="text-sm font-black text-purple-700 uppercase tracking-wider flex items-center gap-2">
                                        <i class="fa-solid fa-table"></i> Sandbox: Partite Caricate
                                    </h4>
                                    <button
                                        onclick="document.getElementById('sandbox-preview-container').classList.add('hidden')"
                                        class="text-gray-400 hover:text-gray-600 transition-colors">
                                        <i class="fa-solid fa-times text-lg"></i>
                                    </button>
                                </div>
                                <div class="overflow-x-auto">
                                    <table class="w-full text-[10px]">
                                        <thead class="bg-purple-100 sticky top-0">
                                            <tr class="text-purple-800 font-black uppercase">
                                                <th class="p-2 text-left">#</th>
                                                <th class="p-2 text-left">Partita</th>
                                                <th class="p-2 text-left">Lega</th>
                                                <th class="p-2 text-center">Data</th>
                                                <th class="p-2 text-center">Ora</th>
                                                <th class="p-2 text-center">ID</th>
                                                <th class="p-2 text-center">fixtureId</th>
                                                <th class="p-2 text-center">leagueId</th>
                                                <th class="p-2 text-center">teamHome</th>
                                                <th class="p-2 text-center">teamAway</th>
                                                <th class="p-2 text-center">Tag</th>
                                            </tr>
                                        </thead>
                                        <tbody id="sandbox-preview-tbody" class="text-gray-700">
                                            <!-- Rows populated via JS -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>


                    </div>
                </div>

                <!-- Gestione Giornate Tips -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4">üóëÔ∏è Gestione Giornate Caricate</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="delete-tips-date" class="block text-sm font-medium text-gray-700 mb-1">Seleziona
                                data da cancellare</label>
                            <select id="delete-tips-date" class="w-full p-2 border rounded-lg">
                                <option value="">Seleziona una data...</option>
                            </select>
                        </div>

                        <!-- Info box with count -->
                        <div id="tips-days-info" class="bg-gray-50 border border-gray-300 rounded-lg p-3 text-sm">
                            <i class="fa-solid fa-calendar-days text-gray-600 mr-2"></i>
                            <span class="text-gray-700 font-medium">Giornate disponibili: 0</span>
                        </div>

                        <button id="delete-tips-day-btn"
                            class="w-full bg-gradient-to-r from-red-600 to-red-700 text-white py-3 rounded-lg font-bold hover:from-red-700 hover:to-red-800 shadow-md transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                            <i class="fa-solid fa-trash-can mr-2"></i>Cancella Tutte le Partite della Data Selezionata
                        </button>

                        <div class="bg-yellow-50 border border-yellow-300 rounded-lg p-3 text-xs text-yellow-800">
                            <i class="fa-solid fa-triangle-exclamation mr-1"></i>
                            <strong>Attenzione:</strong> Questo canceller√† TUTTE le partite senza risultato della data
                            selezionata. L'azione √® irreversibile!
                        </div>
                    </div>
                </div>
            </div>

            <!-- PAGINA RISULTATI -->
            <div id="page-risultati" class="page max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4 border-b pb-2">‚úÖ Aggiorna Risultati</h2>
                    <div class="space-y-6">
                        <div>
                            <label for="results-date" class="block text-sm font-medium text-gray-700 mb-1">Data
                                Risultati</label>
                            <input type="date" id="results-date"
                                class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div class="p-4 bg-blue-50 border border-blue-200 rounded-xl">
                            <h3 class="text-sm font-bold text-blue-800 mb-2">üöÄ Novit√†: Sincronizzazione Intelligente
                            </h3>
                            <button id="auto-sync-results-btn"
                                class="w-full bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700 transition-all shadow-md">
                                <i class="fa-solid fa-sync-alt mr-2"></i>Auto-Sincronizza Risultati API
                            </button>
                            <p class="text-[10px] text-blue-600 mt-2 text-center uppercase tracking-wider font-bold">1
                                Chiamata = Risultati HT/FT per tutto il palinsesto</p>
                        </div>
                        <div class="relative">
                            <div class="absolute inset-0 flex items-center" aria-hidden="true">
                                <div class="w-full border-t border-gray-300"></div>
                            </div>
                            <div class="relative flex justify-center">
                                <span class="px-2 bg-white text-xs text-gray-500 uppercase">Oppure Carica CSV</span>
                            </div>
                        </div>
                        <div>
                            <label for="results-csv-file" class="block text-sm font-medium text-gray-700 mb-1">File
                                CSV
                                Risultati (con risultati finali)</label>
                            <input type="file" id="results-csv-file" accept=".csv"
                                class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100">
                        </div>
                        <div id="results-upload-preview" class="hidden bg-gray-50 p-4 rounded-lg border"></div>
                    </div>
                </div>

                <!-- Gestione Giornate Risultati -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4">üóëÔ∏è Gestione Giornate con Risultati</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="delete-results-date"
                                class="block text-sm font-medium text-gray-700 mb-1">Seleziona data da
                                cancellare</label>
                            <select id="delete-results-date" class="w-full p-2 border rounded-lg">
                                <option value="">Seleziona una data...</option>
                            </select>
                        </div>
                        <button id="delete-results-day-btn"
                            class="w-full bg-red-600 text-white py-2 rounded-lg font-semibold hover:bg-red-700">
                            <i class="fa-solid fa-trash mr-2"></i>Cancella Risultati Giornata Selezionata
                        </button>
                        <div id="results-days-info" class="text-sm text-gray-600"></div>
                    </div>
                </div>
            </div>

            <!-- PAGINA RANKING -->
            <div id="page-ranking" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Filtri Ranking -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4">üèÜ Ranking Partite del Giorno</h2>
                    <p class="text-sm text-gray-600 mb-6">Seleziona un filtro salvato e genera il ranking delle
                        migliori
                        partite</p>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <!-- Prima riga -->
                        <div>
                            <label class="block text-sm font-medium mb-1">Data Partite</label>
                            <input type="date" id="ranking-date" class="w-full p-3 border rounded-lg">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1">Filtro Strategia</label>
                            <select id="ranking-filter-select" class="w-full p-3 border rounded-lg bg-white">
                                <option value="">Nessun filtro (tutte le partite)</option>
                            </select>
                        </div>
                    </div>

                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-1">Max Partite da Mostrare</label>
                        <input type="number" id="ranking-max-matches" value="20" min="1" max="50"
                            class="w-full p-3 border rounded-lg">
                        <p class="text-xs text-gray-500 mt-1">Numero massimo di partite per ogni tip nel ranking</p>
                    </div>

                    <button id="generate-ranking-btn"
                        class="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-3 rounded-lg font-bold hover:opacity-90">
                        <i class="fa-solid fa-magic mr-2"></i>Applica e Genera Ranking
                    </button>
                </div>

                <!-- Toggle Visualizzazione v3.5.3 -->
                <div id="ranking-view-toggle" class="mb-4 hidden">
                    <div class="bg-white p-4 rounded-lg shadow border border-gray-200">
                        <div class="flex items-center space-x-2">
                            <button id="view-by-tip-btn"
                                class="flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white">
                                <i class="fa-solid fa-chart-bar mr-2"></i>Per Tip e Ranking
                            </button>
                            <button id="view-by-time-btn"
                                class="flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300">
                                <i class="fa-solid fa-clock mr-2"></i>Per Orario
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Risultati Ranking -->
                <div id="ranking-results"></div>
            </div>

            <!-- PAGINA STORICO PREVISIONI -->
            <div id="page-storico" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Strategy Management Header -->
                <div class="bg-white p-6 rounded-xl shadow-sm border border-gray-100 mb-8">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold text-gray-800 flex items-center">
                            <i class="fa-solid fa-wand-magic-sparkles text-purple-600 mr-2"></i>
                            Gestione Strategie
                        </h2>
                        <button id="recalc-strategies-btn"
                            class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition shadow-md flex items-center text-sm">
                            <i class="fa-solid fa-rotate mr-2"></i> Ricalcola Data Selezionata
                        </button>
                    </div>
                </div>
                <!-- Selezione Data -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4">
                        <i class="fa-solid fa-clock-rotate-left text-purple-600 mr-2"></i>
                        Storico Previsioni
                    </h2>
                    <p class="text-sm text-gray-600 mb-6">Visualizza le previsioni salvate e verifica i risultati
                    </p>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                        <div>
                            <label class="block text-sm font-medium mb-1">Data Previsioni</label>
                            <input type="date" id="storico-date" class="w-full p-3 border rounded-lg">
                        </div>
                        <div>
                            <button id="load-storico-btn"
                                class="w-full bg-purple-600 text-white py-3 rounded-lg font-bold hover:bg-purple-700">
                                <i class="fa-solid fa-search mr-2"></i>Cerca Previsioni
                            </button>
                        </div>
                        <div>
                            <button id="load-all-storico-btn"
                                class="w-full bg-gray-600 text-white py-3 rounded-lg font-bold hover:bg-gray-700">
                                <i class="fa-solid fa-list mr-2"></i>Ultime 10 Giornate
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Lista Strategie per Data -->
                <div id="storico-strategie-list" class="hidden">
                    <div class="bg-gradient-to-r from-purple-500 to-indigo-600 text-white p-4 rounded-t-xl">
                        <h3 class="text-xl font-bold" id="storico-date-title">Strategie del --</h3>
                        <p class="text-sm opacity-90" id="storico-count">-- strategie salvate</p>
                    </div>
                    <div id="storico-strategie-container"
                        class="bg-white rounded-b-xl shadow-md border border-gray-200 p-4">
                        <!-- Strategie caricate dinamicamente -->
                    </div>
                </div>

                <!-- Dettaglio Strategia Selezionata -->
                <div id="storico-dettaglio" class="hidden mt-6">
                    <!-- Dettaglio caricato dinamicamente -->
                </div>

                <!-- Stats Globali -->
                <div id="storico-stats-globali" class="hidden mt-6">
                    <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                        <h3 class="text-xl font-bold mb-4">üìä Statistiche Globali</h3>
                        <div id="storico-stats-content" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <!-- Stats caricate dinamicamente -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- PAGINA PRONOSTICI (Unified with single date selector) -->
            <div id="page-pronostici" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Header with unified controls -->
                <div class="bg-gradient-to-r from-purple-600 to-blue-600 text-white p-6 rounded-2xl shadow-lg mb-8">
                    <h1 class="text-3xl font-bold flex items-center gap-3 mb-6">
                        <i class="fa-solid fa-trophy"></i>
                        Pronostici
                    </h1>

                    <!-- Buttons Row -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
                        <!-- Date Selector -->
                        <div>
                            <label class="block text-xs font-medium mb-1 opacity-80">Data</label>
                            <input type="date" id="pronostici-unified-date"
                                class="w-full p-2.5 border rounded-lg text-gray-900 font-semibold text-sm">
                        </div>
                        <!-- NEW 3-STEP WORKFLOW CONTROLS -->
                        <div class="col-span-2 flex items-end gap-2">
                            <!-- STEP 1: CALCOLAZIONE RAM -->
                            <button id="btn-step1-calc"
                                class="flex-1 bg-white border-2 border-purple-200 text-purple-700 px-2 py-2.5 rounded-lg font-bold transition hover:bg-purple-50 shadow flex items-center justify-center gap-2 text-xs uppercase tracking-wide">
                                <i class="fa-solid fa-microchip"></i>
                                1. Calcola (RAM)
                            </button>

                            <!-- STEP 2: PUBBLICAZIONE DB -->
                            <button id="btn-step2-dist"
                                class="flex-1 bg-green-600 text-white border-2 border-transparent px-2 py-2.5 rounded-lg font-bold transition shadow hover:bg-green-700 flex items-center justify-center gap-2 text-xs uppercase tracking-wide">
                                <i class="fa-solid fa-cloud-upload-alt"></i>
                                2. Pubblica
                            </button>
                        </div>

                        <!-- Hidden Report Area -->
                        <div id="step1-report"
                            class="col-span-full hidden bg-purple-50 border border-purple-200 rounded-lg p-3 text-xs text-purple-800 font-mono mt-2">
                            <span id="step1-stats">Calcolati: 0 | Pronti per Step 2</span>
                        </div>
                        <!-- Storico Strategie -->
                        <div class="flex items-end">
                            <button id="pronostici-history-btn"
                                class="w-full bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2.5 rounded-lg font-bold transition shadow flex items-center justify-center gap-2 text-sm">
                                <i class="fa-solid fa-calendar-days"></i>
                                Storico
                            </button>
                        </div>
                        <!-- Backup Strategie -->
                        <div class="flex items-end">
                            <button id="backup-strategie-btn"
                                class="w-full bg-amber-500 hover:bg-amber-600 text-white px-4 py-2.5 rounded-lg font-bold transition shadow flex items-center justify-center gap-2 text-sm"
                                title="Salva una copia delle strategie per Machine Learning">
                                <i class="fa-solid fa-file-export"></i>
                                Backup Strategie
                            </button>
                        </div>
                        <!-- Restore Strategie -->
                        <div class="flex items-end">
                            <button id="restore-strategie-btn"
                                class="w-full bg-slate-600 hover:bg-slate-700 text-white px-4 py-2.5 rounded-lg font-bold transition shadow flex items-center justify-center gap-2 text-sm"
                                title="Ripristina le strategie da un backup precedente">
                                <i class="fa-solid fa-file-import"></i>
                                Restore Strategie
                            </button>
                            <input type="file" id="restore-strategie-input" class="hidden" accept=".json">
                        </div>
                        <!-- Blacklist -->
                        <div class="flex items-end">
                            <button id="open-blacklist-btn"
                                class="w-full bg-slate-800 hover:bg-slate-900 text-white px-4 py-2.5 rounded-lg font-bold transition shadow flex items-center justify-center gap-2 text-sm">
                                <i class="fa-solid fa-ban"></i>
                                Blacklist
                            </button>
                        </div>
                    </div>

                    <!-- ========== SIMPLIFIED BLACKLIST MANAGER ========== -->
                    <div id="blacklist-manager-panel"
                        class="hidden mt-6 bg-white rounded-2xl shadow-xl border border-gray-200 overflow-hidden">
                        <!-- Header -->
                        <div class="bg-gray-800 text-white px-6 py-4 flex items-center justify-between">
                            <h2 class="text-xl font-bold flex items-center gap-3">
                                <i class="fa-solid fa-ban"></i>
                                Blacklist Manager
                            </h2>
                            <div class="flex items-center gap-4">
                                <span id="blacklist-count-header" class="text-sm bg-white/20 px-3 py-1 rounded-full">
                                    0 leghe in blacklist
                                </span>
                                <button id="close-blacklist-btn" class="text-white/70 hover:text-white text-2xl">
                                    <i class="fa-solid fa-xmark"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Content -->
                        <div class="p-6">
                            <!-- Filter Section -->
                            <div class="bg-purple-50 rounded-xl p-5 border border-purple-200 mb-6">
                                <h3 class="font-bold text-purple-800 mb-3 flex items-center gap-2 text-lg">
                                    <i class="fa-solid fa-filter"></i>
                                    Filtro Winrate
                                </h3>
                                <p class="text-sm text-gray-600 mb-4">
                                    Modifica la soglia: la lista si aggiorna <strong>automaticamente</strong>.
                                </p>
                                <div class="flex items-center gap-3 flex-wrap">
                                    <label class="text-gray-700 font-medium">Winrate minore di:</label>
                                    <input type="number" id="bl-winrate-threshold" value="50" min="20" max="90"
                                        class="w-20 p-2 border-2 border-purple-400 rounded-lg text-center font-bold text-purple-800 text-lg">
                                    <span class="text-purple-800 font-bold text-lg">%</span>
                                </div>
                                <div class="mt-3 text-xs text-gray-500" id="bl-last-threshold">
                                    Soglia salvata: <span class="font-semibold">--</span>
                                </div>
                            </div>

                            <!-- Results Section -->
                            <div class="bg-gray-50 rounded-xl p-5 border border-gray-200">
                                <div class="flex items-center justify-between mb-4">
                                    <h3 class="font-bold text-gray-800 flex items-center gap-2">
                                        <i class="fa-solid fa-list"></i>
                                        Risultati: <span id="bl-results-count" class="text-purple-600">0</span> leghe
                                    </h3>
                                    <label class="flex items-center gap-2 text-sm text-gray-600 cursor-pointer">
                                        <input type="checkbox" id="bl-selectall" class="rounded">
                                        Seleziona tutte
                                    </label>
                                </div>

                                <p class="text-xs text-gray-500 mb-3">
                                    <span class="inline-block w-3 h-3 bg-green-200 rounded mr-1"></span> Verde = lega
                                    migliorata (winrate ora SOPRA soglia)
                                    <span class="inline-block w-3 h-3 bg-gray-200 rounded ml-3 mr-1"></span> Grigio =
                                    gi√† in blacklist
                                </p>

                                <div id="bl-results-list" class="max-h-80 overflow-y-auto space-y-2">
                                    <div class="text-gray-400 italic text-center py-8">
                                        Caricamento in corso...
                                    </div>
                                </div>
                            </div>

                            <!-- Save Section -->
                            <div class="mt-6 pt-4 border-t border-gray-200">
                                <div class="flex flex-wrap items-center justify-between gap-4">
                                    <div id="bl-save-status" class="text-sm text-gray-600">
                                        Seleziona le leghe e clicca Salva
                                    </div>
                                    <div class="flex gap-3">
                                        <button id="bl-clear-all-btn"
                                            class="bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded-lg font-semibold flex items-center gap-2">
                                            <i class="fa-solid fa-trash"></i>
                                            Svuota
                                        </button>
                                        <button id="bl-save-btn"
                                            class="bg-purple-600 hover:bg-purple-700 text-white px-6 py-2 rounded-lg font-bold flex items-center gap-2 shadow-lg">
                                            <i class="fa-solid fa-save"></i>
                                            Salva Blacklist
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- PRONOSTICI LIVE DASHBOARD (5 Strategie + Magia AI) -->
                <div id="pronostici-live-section" class="mb-6 hidden">
                    <div class="bg-white p-6 rounded-2xl shadow-md border-2 border-green-400">
                        <div class="flex items-center justify-between mb-4">
                            <h2 class="text-2xl font-black flex items-center gap-2 text-green-700">
                                <i class="fa-solid fa-satellite-dish animate-pulse"></i>
                                LIVE SU APP (Pronostici di Oggi)
                            </h2>
                            <div class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-xs font-bold"
                                id="pronostici-live-date">
                                Caricamento...
                            </div>
                        </div>

                        <div id="pronostici-live-content" class="min-h-[100px]">
                            <!-- Content loaded via JS -->
                            <div class="flex items-center justify-center h-full text-gray-400">
                                <i class="fas fa-spinner fa-spin mr-2"></i> Sto cercando le strategie di oggi su
                                Firebase...
                            </div>
                        </div>
                    </div>
                </div>


                <!-- Ranking Section -->
                <div id="pronostici-ranking-section" class="hidden">
                    <div
                        class="bg-gradient-to-br from-purple-50 to-blue-50 p-6 rounded-2xl shadow-md border-2 border-purple-200 mb-6">
                        <h2 class="text-2xl font-bold mb-4 flex items-center gap-2">
                            <i class="fa-solid fa-chart-line text-purple-600"></i>
                            üìä Ranking Salvati
                        </h2>

                        <!-- Lista Strategie del Giorno -->
                        <div id="ranking-strategies-list" class="hidden">
                            <h3 class="text-lg font-bold mb-3 text-gray-800">Strategie Disponibili:</h3>
                            <div id="ranking-strategies-grid"
                                class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 mb-4">
                                <!-- Populated dynamically -->
                            </div>
                        </div>

                        <!-- Dettaglio Partite della Strategia Selezionata -->
                        <div id="ranking-matches-detail" class="hidden">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-bold text-gray-800" id="ranking-strategy-name"></h3>
                                <button id="ranking-back-btn"
                                    class="text-sm text-gray-600 hover:text-gray-800 underline">
                                    <i class="fa-solid fa-arrow-left mr-1"></i>Torna alle strategie
                                </button>
                            </div>
                            <div id="ranking-matches-container" class="space-y-3">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Storico Section -->
                <div id="pronostici-storico-section" class="hidden">
                    <!-- Lista Strategie per Data -->
                    <div id="pronostici-storico-list" class="mb-6">
                        <div class="bg-gradient-to-r from-purple-500 to-indigo-600 text-white p-4 rounded-t-xl">
                            <h3 class="text-xl font-bold" id="pronostici-storico-title">Strategie del --</h3>
                            <p class="text-sm opacity-90" id="pronostici-storico-count">-- strategie salvate (Solo
                                Database Oro)</p>
                        </div>
                        <div id="pronostici-storico-container"
                            class="bg-white rounded-b-xl shadow-md border border-gray-200 p-4">
                            <!-- Strategie caricate dinamicamente -->
                        </div>
                    </div>

                    <!-- Dettaglio Strategia Selezionata -->
                    <div id="storico-dettaglio" class="hidden mt-6">
                        <!-- Dettaglio caricato dinamicamente -->
                    </div>

                    <!-- Stats Globali -->
                    <div id="storico-stats-globali" class="hidden mt-6">
                        <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                            <h3 class="text-xl font-bold mb-4">üìä Statistiche Globali</h3>
                            <div id="storico-stats-content" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                                <!-- Stats caricate dinamicamente -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- STORICO TRADING SPORTIVO SECTION -->
                <div id="trading-storico-section" class="hidden mt-8">
                    <div class="bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden">
                        <div class="bg-gradient-to-r from-purple-600 to-blue-600 px-6 py-4">
                            <h3 class="text-xl font-bold text-white">üìä Storico Trading Sportivo</h3>
                            <p class="text-sm text-white/80">Backtest strategie BACK OVER 2.5 e LAY THE DRAW</p>
                        </div>

                        <div class="p-6">
                            <!-- Date Selector + Stats -->
                            <div class="grid grid-cols-1 lg:grid-cols-4 gap-4 mb-6">
                                <div class="lg:col-span-1">
                                    <label class="block text-sm font-semibold text-gray-700 mb-2">Data</label>
                                    <select id="trading-date-select"
                                        class="w-full p-3 border border-gray-300 rounded-lg">
                                        <option value="">-- Caricamento... --</option>
                                    </select>
                                </div>
                                <div class="lg:col-span-3 grid grid-cols-3 gap-3">
                                    <div class="bg-green-50 p-3 rounded-lg border border-green-200">
                                        <div class="text-xs font-semibold text-green-700">WIN RATE</div>
                                        <div id="trading-stat-winrate" class="text-xl font-bold text-green-800">--%
                                        </div>
                                    </div>
                                    <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
                                        <div class="text-xs font-semibold text-blue-700">ROI</div>
                                        <div id="trading-stat-roi" class="text-xl font-bold text-blue-800">--‚Ç¨</div>
                                    </div>
                                    <div class="bg-purple-50 p-3 rounded-lg border border-purple-200">
                                        <div class="text-xs font-semibold text-purple-700">PICKS</div>
                                        <div id="trading-stat-picks" class="text-xl font-bold text-purple-800">--</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Picks Table -->
                            <div id="trading-picks-table-container">
                                <div class="text-center text-gray-500 py-12">
                                    <i class="fa-solid fa-calendar-days text-4xl mb-4"></i>
                                    <p>Seleziona una data per visualizzare le picks</p>
                                </div>
                            </div>

                            <!-- Strategy Stats -->
                            <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div class="bg-purple-50 rounded-lg p-4 border border-purple-200">
                                    <h4 class="text-sm font-bold text-purple-700 mb-3">BACK OVER 2.5</h4>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">Picks:</span>
                                            <span id="over25-count" class="font-semibold">--</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">Win Rate:</span>
                                            <span id="over25-winrate" class="font-semibold">--%</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">ROI:</span>
                                            <span id="over25-roi" class="font-semibold">--‚Ç¨</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
                                    <h4 class="text-sm font-bold text-blue-700 mb-3">LAY THE DRAW</h4>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">Picks:</span>
                                            <span id="ltd-count" class="font-semibold">--</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">Win Rate:</span>
                                            <span id="ltd-winrate" class="font-semibold">--%</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">ROI:</span>
                                            <span id="ltd-roi" class="font-semibold">--‚Ç¨</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <!-- PAGINA TEST STRATEGIE (Functional UI) -->
            <!-- PAGINA TRADING 3.0 -->
            <div id="page-trading-30" class="page hidden max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <div
                    class="bg-gradient-to-br from-emerald-600 to-teal-700 text-white p-6 rounded-2xl shadow-xl mb-8 relative overflow-hidden">
                    <div class="absolute top-0 right-0 p-4 opacity-10">
                        <i class="fa-solid fa-chart-line text-9xl"></i>
                    </div>
                    <h1 class="text-3xl font-black flex items-center gap-3 mb-6">
                        <i class="fa-solid fa-bolt-lightning text-emerald-300"></i>
                        Professional Trading 3.0
                    </h1>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <div>
                            <label
                                class="block text-xs font-black mb-1 opacity-80 uppercase tracking-widest text-emerald-100">DATA
                                STUDIO</label>
                            <input type="date" id="trading-30-date"
                                class="w-full p-3 border-none rounded-xl text-gray-900 font-black text-sm shadow-xl focus:ring-4 focus:ring-emerald-400/50 outline-none">
                        </div>
                        <div class="flex items-end gap-2">
                            <button id="trading-30-generate-btn"
                                class="flex-1 bg-white text-emerald-700 px-4 py-3 rounded-xl font-black transition hover:scale-[1.02] shadow-xl flex items-center justify-center gap-2 text-sm">
                                <i class="fa-solid fa-wand-magic-sparkles"></i> 3. Genera Studio 3.0 (RAM)
                            </button>
                            <button id="trading-30-regenerate-btn" title="Forza Rigenerazione"
                                class="hidden bg-emerald-400/20 text-white border border-white/30 hover:bg-emerald-400/30 px-3 py-3 rounded-xl font-bold transition">
                                <i class="fa-solid fa-arrows-rotate"></i>
                            </button>
                        </div>
                        <div class="flex items-end">
                            <button id="trading-30-calculate-btn"
                                class="w-full bg-emerald-900 border border-emerald-400/30 text-emerald-100 px-4 py-3 rounded-xl font-black transition hover:bg-emerald-800 shadow-xl flex items-center justify-center gap-2 text-sm">
                                <i class="fa-solid fa-check-double text-emerald-400"></i> CALCOLA ESITI
                            </button>
                        </div>
                        <div class="flex items-end">
                            <button id="trading-30-history-btn"
                                class="w-full bg-purple-700 border border-purple-400/30 text-white px-4 py-3 rounded-xl font-black transition hover:bg-purple-600 shadow-xl flex items-center justify-center gap-2 text-sm">
                                <i class="fa-solid fa-clock-rotate-left"></i> STORICO TRADING
                            </button>
                        </div>
                    </div>
                </div>


                <!-- Opportunit√† Rilevate Section (Scegliere Pick) -->
                <div id="trading-30-opportunities-section" class="mb-8 hidden">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-black text-gray-800 flex items-center gap-2">
                            <i class="fa-solid fa-microchip text-indigo-600"></i>
                            Opportunit√† Rilevate AI (Campionati Top)
                        </h2>
                        <span
                            class="text-xs bg-indigo-100 text-indigo-700 px-3 py-1 rounded-full font-black uppercase tracking-widest">Seleziona
                            i tuoi Pick</span>
                    </div>
                    <div id="trading-30-opportunities-grid"
                        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Populated dynamically -->
                    </div>
                </div>

                <!-- STORICO TRADING Section -->
                <div id="trading-30-history-section" class="mb-8 hidden">
                    <div class="bg-white rounded-2xl shadow-lg border-2 border-purple-400 overflow-hidden">
                        <div class="bg-gradient-to-r from-purple-600 to-indigo-600 px-6 py-4">
                            <div class="flex items-center justify-between">
                                <h2 class="text-2xl font-black text-white flex items-center gap-2">
                                    <i class="fa-solid fa-clock-rotate-left"></i> STORICO TRADING
                                </h2>
                                <button id="trading-30-history-close" class="text-white/70 hover:text-white transition">
                                    <i class="fa-solid fa-times text-xl"></i>
                                </button>
                            </div>
                        </div>
                        <div id="trading-30-history-content" class="p-6">
                            <div class="flex items-center justify-center py-12 text-gray-400">
                                <i class="fas fa-spinner fa-spin text-2xl mr-3"></i>
                                <span>Caricamento storico...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Dashboard Trading 3.0 Live Opportunities -->
                <div id="trading-live-section" class="mb-6 hidden">

                    <div class="bg-white p-6 rounded-2xl shadow-md border-2 border-emerald-500">
                        <div class="flex items-center justify-between mb-6">
                            <h2 class="text-2xl font-black flex items-center gap-2 text-emerald-800">
                                <i class="fa-solid fa-shield-halved animate-pulse"></i>
                                STUDI PROFESSIONALI ATTIVI (Live su App)
                            </h2>
                            <div class="bg-emerald-100 text-emerald-800 px-4 py-1.5 rounded-full text-xs font-black uppercase tracking-widest"
                                id="trading-live-date">--/--/--</div>
                        </div>
                        <div id="trading-live-content">
                            <!-- Populated by loadTradingLiveOpportunities() -->
                            <div class="flex items-center justify-center py-12 text-gray-400">
                                <i class="fas fa-spinner fa-spin text-2xl mr-3"></i>
                                <span>Caricamento studio...</span>
                            </div>
                        </div>
                    </div>
                </div>

            </div>


            <!-- PAGINA GESTIONE DB -->
            <div id="page-gestione-db" class="page max-w-7xl mx-auto px-4 py-8">

                <!-- ========== GRIGLIA OPERAZIONI DATABASE ========== -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">

                    <!-- 1. BACKUP (Top-Left) -->
                    <div
                        class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 hover:shadow-lg transition-shadow">
                        <h2 class="text-xl font-bold mb-2 text-gray-800 flex items-center">
                            <i class="fa-solid fa-download mr-2 text-green-600"></i>Backup Database
                        </h2>
                        <p class="text-sm text-gray-500 mb-4">Scarica l'intero database corrente in CSV.</p>
                        <button id="export-full-db-btn"
                            class="w-full bg-green-600 text-white py-3 rounded-xl font-semibold hover:bg-green-700 shadow-sm flex items-center justify-center">
                            <i class="fa-solid fa-file-csv mr-2"></i>Scarica Backup
                        </button>
                    </div>

                    <!-- 2. RESTORE (Top-Middle) -->
                    <div
                        class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 hover:shadow-lg transition-shadow">
                        <h2 class="text-xl font-bold mb-2 text-gray-800 flex items-center">
                            <i class="fa-solid fa-cloud-upload-alt mr-2 text-orange-600"></i>Restore DB
                        </h2>
                        <p class="text-sm text-gray-500 mb-4">Ripristina/Aggiorna da CSV.</p>
                        <div class="relative">
                            <input type="file" id="backup-csv-file" accept=".csv" class="hidden">
                            <label for="backup-csv-file"
                                class="w-full cursor-pointer bg-orange-100 text-orange-700 py-3 rounded-xl font-semibold hover:bg-orange-200 shadow-sm flex items-center justify-center border border-orange-200 transition-colors">
                                <i class="fa-solid fa-upload mr-2"></i>Seleziona CSV
                            </label>
                            <div id="backup-file-status" class="mt-2 text-xs text-center text-gray-500 hidden">
                                <i class="fa-solid fa-check-circle text-green-500 mr-1"></i>
                                <span id="backup-file-name"></span>
                            </div>
                        </div>
                        <div id="backup-upload-preview" class="hidden mt-4 bg-gray-50 p-4 rounded-lg border text-sm">
                        </div>
                    </div>

                    <!-- 3. RICALCOLA ESITI (Top-Right) -->
                    <div
                        class="bg-white p-6 rounded-2xl shadow-md border border-yellow-200 hover:shadow-lg transition-shadow">
                        <h2 class="text-xl font-bold mb-2 text-gray-800 flex items-center">
                            <i class="fa-solid fa-calculator mr-2 text-yellow-600"></i>Ricalcola Esiti
                        </h2>
                        <p class="text-sm text-gray-500 mb-4">Fix esiti mancanti per match conclusi.</p>
                        <button id="bulk-recalculate-esito-btn"
                            class="w-full bg-yellow-500 text-white py-3 rounded-xl font-semibold hover:bg-yellow-600 shadow-sm flex items-center justify-center">
                            <i class="fa-solid fa-rotate mr-2"></i>Ricalcola Tutto
                        </button>
                        <div id="recalc-status" class="hidden mt-2 text-xs text-center"></div>
                    </div>

                    <!-- 4. EXPORT STORICO (Bottom-Left) -->
                    <div
                        class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 hover:shadow-lg transition-shadow">
                        <h2 class="text-xl font-bold mb-2 text-gray-800 flex items-center">
                            <i class="fa-solid fa-file-export mr-2 text-blue-600"></i>Export Storico
                        </h2>
                        <div class="flex gap-2 mb-3">
                            <input type="date" id="export-start-date"
                                class="w-1/2 p-2 border rounded-lg bg-gray-50 text-sm">
                            <input type="date" id="export-end-date"
                                class="w-1/2 p-2 border rounded-lg bg-gray-50 text-sm">
                        </div>
                        <label class="flex items-center text-sm text-gray-600 mb-3">
                            <input type="checkbox" id="export-only-results" checked class="mr-2 rounded text-blue-600">
                            Solo con ris.
                        </label>
                        <button id="export-storico-btn"
                            class="w-full bg-blue-600 text-white py-3 rounded-xl font-semibold hover:bg-blue-700 shadow-sm flex items-center justify-center">
                            <i class="fa-solid fa-download mr-2"></i>Esporta CSV
                        </button>
                    </div>

                    <!-- 5. CANCELLA GIORNATA (Bottom-Middle) -->
                    <div
                        class="bg-white p-6 rounded-2xl shadow-md border border-red-100 hover:border-red-300 transition-colors hover:shadow-lg">
                        <h2 class="text-xl font-bold mb-2 text-gray-800 flex items-center">
                            <i class="fa-solid fa-trash-can mr-2 text-red-600"></i>Cancella Data
                        </h2>
                        <p class="text-sm text-gray-500 mb-4">Rimuovi match di una data.</p>
                        <input type="date" id="delete-full-date"
                            class="w-full p-2 border border-red-200 rounded-lg bg-red-50 text-gray-700 mb-3">
                        <button id="delete-full-date-btn"
                            class="w-full bg-red-100 text-red-700 py-3 rounded-xl font-semibold hover:bg-red-200 hover:text-red-800 shadow-sm flex items-center justify-center transition-colors">
                            <i class="fa-solid fa-trash mr-2"></i>Elimina Definitivamente
                        </button>
                        <div id="delete-date-status" class="hidden mt-2 text-xs text-center"></div>
                    </div>
                </div>

                <!-- ========== TROVA E SOSTITUISCI MASSIVO (Migliorato) ========== -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-8">
                    <h2 class="text-xl font-bold mb-4 text-gray-800 flex items-center">
                        <i class="fa-solid fa-magnifying-glass-chart mr-2 text-purple-600"></i>Trova e Sostituisci
                        Massivo
                    </h2>
                    <p class="text-sm text-gray-500 mb-4">Correggi nomi di leghe, squadre o tip in blocco. Supporta
                        anche match parziale (es. "PRT" sostituito in "EU-PRT 1").</p>

                    <!-- Row 1: Search inputs -->
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
                        <div>
                            <label class="block text-xs font-bold text-gray-500 uppercase mb-1">Cerca</label>
                            <input type="text" id="bulk-find-input" placeholder="Testo da trovare"
                                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
                        </div>
                        <div>
                            <label class="block text-xs font-bold text-gray-500 uppercase mb-1">Sostituisci Con</label>
                            <input type="text" id="bulk-replace-input" placeholder="Nuovo testo"
                                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500">
                        </div>
                        <div>
                            <label class="block text-xs font-bold text-gray-500 uppercase mb-1">In Colonna</label>
                            <select id="bulk-column-select"
                                class="w-full p-3 border border-gray-300 rounded-lg bg-white">
                                <option value="lega">Lega</option>
                                <option value="partita">Partita</option>
                                <option value="tip">Tip</option>
                                <option value="mercato">Mercato</option>
                            </select>
                        </div>
                        <div class="flex flex-col gap-2">
                            <label class="flex items-center text-sm text-gray-600">
                                <input type="checkbox" id="bulk-exact-match" class="mr-2 rounded text-purple-600"> Match
                                Esatto
                            </label>
                            <button id="bulk-preview-btn"
                                class="w-full bg-blue-600 text-white py-3 rounded-lg font-semibold hover:bg-blue-700 shadow-md flex items-center justify-center">
                                <i class="fa-solid fa-magnifying-glass mr-2"></i>Cerca Anteprima
                            </button>
                        </div>
                    </div>

                    <!-- Row 2: Date Filter -->
                    <div class="flex flex-wrap gap-4 mt-3 items-center">
                        <span class="text-xs font-bold text-gray-500 uppercase">Filtra per data:</span>
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Da:</label>
                            <input type="date" id="bulk-date-from"
                                class="p-2 border border-gray-300 rounded-lg text-sm">
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">A:</label>
                            <input type="date" id="bulk-date-to" class="p-2 border border-gray-300 rounded-lg text-sm">
                        </div>
                        <button id="bulk-clear-dates" class="text-xs text-purple-600 hover:underline">Cancella
                            date</button>
                    </div>

                    <!-- Preview Results Area -->
                    <div id="bulk-preview-area" class="hidden mt-4">
                        <div class="flex items-center justify-between mb-2 flex-wrap gap-2">
                            <div class="flex items-center gap-3">
                                <span id="bulk-preview-count" class="text-sm font-bold text-gray-700"></span>
                                <button id="bulk-select-all"
                                    class="text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300">
                                    <i class="fa-solid fa-check-double mr-1"></i>Seleziona tutti
                                </button>
                                <button id="bulk-deselect-all"
                                    class="text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300">
                                    <i class="fa-solid fa-xmark mr-1"></i>Deseleziona tutti
                                </button>
                            </div>
                            <button id="bulk-replace-btn" disabled
                                class="bg-purple-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-purple-700 shadow-md flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                                <i class="fa-solid fa-retweet mr-2"></i>Sostituisci Selezionati
                            </button>
                        </div>
                        <div id="bulk-preview-list"
                            class="max-h-80 overflow-y-auto bg-gray-50 rounded-lg border border-gray-200 p-2 text-sm">
                            <!-- Preview items will be inserted here -->
                        </div>
                    </div>
                    <div id="bulk-replace-status" class="hidden mt-4 p-3 rounded-lg text-sm"></div>
                </div>

                <!-- Quick Search & Edit Table -->
                <div class="mt-8 bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4 text-gray-800"><i
                            class="fa-solid fa-search mr-2 text-purple-600"></i>Ricerca e Modifica Rapida DB</h2>
                    <div class="mb-4">
                        <input type="text" id="quick-db-search" placeholder="Cerca qualsiasi cosa nel DB..."
                            class="w-full p-3 border-2 border-purple-100 rounded-lg focus:ring-2 focus:ring-purple-500">
                    </div>
                    <div class="max-h-[500px] overflow-y-auto custom-scrollbar">
                        <table class="w-full text-sm text-left">
                            <thead class="text-xs text-gray-700 uppercase bg-gray-50 sticky top-0">
                                <tr>
                                    <th class="px-4 py-3">Data</th>
                                    <th class="px-4 py-3">Lega</th>
                                    <th class="px-4 py-3">Partita</th>
                                    <th class="px-4 py-3">Tip</th>
                                    <th class="px-4 py-3 text-center">Risultato</th>
                                    <th class="px-4 py-3 text-center">Azioni</th>
                                </tr>
                            </thead>
                            <tbody id="quick-db-results">
                                <tr>
                                    <td colspan="6" class="p-4 text-center text-gray-500">Usa la barra di ricerca
                                        per trovare record...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- PAGINA ISTRUZIONI AI (euGENIO Configuration) -->
            <div id="page-ai-instructions" class="page max-w-4xl mx-auto px-4 py-8">
                <div
                    class="bg-gradient-to-r from-purple-50 to-blue-50 p-8 rounded-2xl shadow-lg border-2 border-purple-300">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="bg-gradient-to-r from-purple-600 to-blue-600 text-white p-4 rounded-full">
                            <i class="fa-solid fa-robot text-2xl"></i>
                        </div>
                        <div>
                            <h1 class="text-2xl font-bold text-gray-800">üßû Configurazione euGENIO AI</h1>
                            <p class="text-sm text-gray-500">Gestisci le conoscenze e istruzioni dell'assistente AI</p>
                        </div>
                    </div>

                    <div class="space-y-6">
                        <!-- Trading Knowledge -->
                        <div>
                            <label class="block text-sm font-bold text-gray-700 mb-2">
                                <i class="fa-solid fa-chart-line text-green-600 mr-1"></i>
                                Conoscenze Trading Sportivo
                            </label>
                            <textarea id="eugenio-trading-knowledge" rows="8"
                                class="w-full p-4 border-2 border-purple-200 rounded-xl focus:ring-2 focus:ring-purple-500 focus:border-purple-500 font-mono text-sm bg-white"
                                placeholder="Inserisci qui le istruzioni sul trading sportivo che euGENIO deve conoscere..."></textarea>
                        </div>

                        <!-- Custom Instructions -->
                        <div>
                            <label class="block text-sm font-bold text-gray-700 mb-2">
                                <i class="fa-solid fa-cog text-blue-600 mr-1"></i>
                                Istruzioni Personalizzate
                            </label>
                            <textarea id="eugenio-custom-instructions" rows="5"
                                class="w-full p-4 border-2 border-purple-200 rounded-xl focus:ring-2 focus:ring-purple-500 focus:border-purple-500 font-mono text-sm bg-white"
                                placeholder="Istruzioni aggiuntive per il comportamento di euGENIO..."></textarea>
                        </div>

                        <!-- Additional Context -->
                        <div>
                            <label class="block text-sm font-bold text-gray-700 mb-2">
                                <i class="fa-solid fa-book text-orange-600 mr-1"></i>
                                Contesto Aggiuntivo (FAQ, Info App)
                            </label>
                            <textarea id="eugenio-additional-context" rows="5"
                                class="w-full p-4 border-2 border-purple-200 rounded-xl focus:ring-2 focus:ring-purple-500 focus:border-purple-500 font-mono text-sm bg-white"
                                placeholder="FAQ, informazioni sull'app, novit√† da comunicare..."></textarea>
                        </div>

                        <!-- Telegram Bot Knowledge -->
                        <div>
                            <label class="block text-sm font-bold text-gray-700 mb-2">
                                <i class="fa-solid fa-paper-plane text-blue-400 mr-1"></i>
                                Telegram Bot Knowledge
                            </label>
                            <textarea id="eugenio-telegram-knowledge" rows="5"
                                class="w-full p-4 border-2 border-purple-200 rounded-xl focus:ring-2 focus:ring-purple-500 focus:border-purple-500 font-mono text-sm bg-white"
                                placeholder="Informazioni specifiche sulle notifiche e il bot Telegram..."></textarea>
                        </div>

                        <!-- Action Buttons -->
                        <div class="flex gap-4 pt-4 border-t border-purple-200">
                            <button id="load-eugenio-prompt-btn"
                                class="flex-1 bg-gray-500 text-white py-4 rounded-xl font-bold hover:bg-gray-600 transition-all text-lg">
                                <i class="fa-solid fa-download mr-2"></i>Carica da Firebase
                            </button>
                            <button id="save-eugenio-prompt-btn"
                                class="flex-1 bg-gradient-to-r from-purple-600 to-blue-600 text-white py-4 rounded-xl font-bold hover:from-purple-700 hover:to-blue-700 transition-all text-lg">
                                <i class="fa-solid fa-save mr-2"></i>Salva su Firebase
                            </button>
                        </div>
                        <div id="eugenio-status" class="hidden mt-3 text-sm text-center"></div>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <!-- Modal -->
    <div id="modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-2xl p-6 max-w-md mx-4">
            <h3 id="modal-title" class="text-xl font-bold mb-4"></h3>
            <p id="modal-message" class="mb-6"></p>
            <div class="flex justify-end space-x-4">
                <button id="modal-cancel" class="bg-gray-200 px-4 py-2 rounded-lg font-semibold">Annulla</button>
                <button id="modal-confirm"
                    class="bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold">Conferma</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== CREDENZIALI FIREBASE E GEMINI ====================
        // TispsterAI-APP (Single Database - Admin + App)
        // MODALIT√Ä IBRIDA: Admin locale (DB Oro su file) -> App (Strategie su Firebase)
        window.USE_LOCAL_DB_ONLY = true; // SE TRUE: Le partite NON vengono caricate su Firebase, ma restano in memoria locale

        // --- PERSISTENCE LAYER (IndexedDB) ---
        // LocalDB implementation removed (now in js/database.js)

        window.firebaseConfig = {
            apiKey: "AIzaSyD7aXUbEshUFsUnpIDR3ZO1tAIgMsb_zpc",
            authDomain: "tispsterai-app.firebaseapp.com",
            projectId: "tispsterai-app",
            storageBucket: "tispsterai-app.firebasestorage.app",
            messagingSenderId: "166289799388",
            appId: "1:166289799388:web:d8b31f2c24eb1d75f11c19"
        };

        // Split key to avoid GitHub "Leaked Key" auto-revocation
        const PART_A = "AIzaSyADskGhRN1E5UqXon";
        const PART_B = "Y11qL05e-gA4fFkYs";
        window.GEMINI_API_KEY = PART_A + PART_B;
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, writeBatch, query, where, doc, addDoc, deleteDoc, setDoc, getDoc, updateDoc, orderBy, limit, onSnapshot, deleteField } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-functions.js";

        // ==================== CONFIGURAZIONE FIREBASE ====================
        const firebaseConfig = window.firebaseConfig;

        let db;
        let auth;

        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            // Set persistence
            setPersistence(auth, browserLocalPersistence);

            // EXPOSE FIREBASE TO WINDOW for external scripts (js/database.js)
            window.db = db;
            window.auth = auth;

            // --- HELPER: Sanitize Object for Firestore (Remove undefined) ---
            window.sanitizeForFirestore = function (obj) {
                if (obj === null || typeof obj !== 'object') return obj;
                if (Array.isArray(obj)) return obj.map(v => window.sanitizeForFirestore(v));

                return Object.fromEntries(
                    Object.entries(obj)
                        .filter(([_, v]) => v !== undefined)
                        .map(([k, v]) => [k, window.sanitizeForFirestore(v)])
                );
            };
            window.writeBatch = writeBatch;
            window.doc = doc;
            window.collection = collection;
            window.setDoc = setDoc;
            window.getDocs = getDocs;
            window.getDoc = getDoc;
            window.query = query;
            window.where = where;
            window.orderBy = orderBy;
            window.limit = limit;
            window.deleteDoc = deleteDoc;
            window.updateDoc = updateDoc;

            // üì° FUNCTIONS BRIDGE (To bypass CORS)
            const functions = getFunctions(app);
            window.getFootballData = httpsCallable(functions, 'getFootballData');

        } catch (error) {
            console.error("Critical Firebase Init Error:", error);
        }

        // ==================== ADMIN AUTO-LOGIN LOGIC (Anonymous) ====================
        const ADMIN_EMAIL = "mpetazmor@gmail.com"; // Legacy check skipped for anonymous

        // Auth state observer & Auto-Login
        onAuthStateChanged(auth, async (user) => {
            const loginScreen = document.getElementById('admin-login-screen');
            const loadingOverlay = document.getElementById('loading-overlay');
            const adminContent = document.getElementById('admin-content');
            const emailDisplay = document.getElementById('admin-email-display');

            if (user) {
                // User logged in
                console.log('[Auth] User detected (ID):', user.uid);

                // Admin verified!
                console.log('[Auth] Admin access granted (Anonymous/Local)');
                if (loginScreen) loginScreen.classList.add('hidden');
                if (loadingOverlay) loadingOverlay.classList.remove('hidden');
                if (adminContent) adminContent.classList.remove('hidden');

                // Initialize App
                if (typeof initializeAdminApp === 'function') {
                    initializeAdminApp(user);
                } else {
                    // Poll if function not ready
                    const checkInit = setInterval(() => {
                        if (typeof initializeAdminApp === 'function') {
                            clearInterval(checkInit);
                            initializeAdminApp(user);
                        }
                    }, 100);
                }

            } else {
                // No user - AUTO LOGIN ANONYMOUSLY
                console.log('[Auth] No user, attempting Auto-Login...');
                try {
                    // Start loading immediately
                    if (loginScreen) loginScreen.classList.add('hidden');
                    if (loadingOverlay) loadingOverlay.classList.remove('hidden');

                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("[Auth] Auto-login failed:", error);
                    alert("Errore accesso automatico: " + error.message);
                    // Show error in login screen just in case
                    if (loginScreen) loginScreen.classList.remove('hidden');
                }
            }
        });

        // ==================== GLOBAL STATE ====================
        let allMatches = [];
        window.allMatches = allMatches; // Expose to window for global access
        let dataToUpload = [];
        let filteredMatches = [];
        let savedFilters = [];
        let editingMatchId = null; // Track currently editing match
        let favoriteLeagues = [];
        let stagedFavoriteLeagues = [];
        let sortState = { column: 'data', direction: 'desc' };
        let lastGeneratedRanking = null;

        // Forward declaration - will be assigned later
        let initializeAdminApp;

        // HT MERGE STATE
        let rawMainData = [];
        let rawHtData = [];

        // API FOOTBALL CONFIG
        const API_FOOTBALL_KEY = '62706d306e456ad02769b5bf985b8973';
        const API_FOOTBALL_URL = 'https://v3.football.api-sports.io';
        const API_FOOTBALL_HOST = 'v3.football.api-sports.io';
        let apiCallsToday = 0; // Initialize global counter

        // LEAGUE MAPPING is now dynamic via LocalDB and Auto-Discovery
        window.LEAGUE_MAPPING = {}; // Placeholder for legacy compatibility
        window.leaguesRegistry = new Map(); // üîó Dynamic registry map for engine.js synchronous lookup

        const CONTINENT_MAP = {
            'EU': 'Europe', 'AS': 'Asia', 'AF': 'Africa', 'SA': 'South-America', 'NA': 'North-America', 'OC': 'Oceania'
        };

        const COUNTRY_MAP = {
            'ENG': 'England', 'ITA': 'Italy', 'ESP': 'Spain', 'GER': 'Germany', 'FRA': 'France',
            'NED': 'Netherlands', 'BEL': 'Belgium', 'POR': 'Portugal', 'SCO': 'Scotland', 'TUR': 'Turkey',
            'ARG': 'Argentina', 'BRA': 'Brazil', 'USA': 'USA', 'MEX': 'Mexico', 'JPN': 'Japan',
            'KOR': 'South Korea', 'TUN': 'Tunisia', 'JOR': 'Jordan', 'SAU': 'Saudi Arabia', 'EGY': 'Egypt',
            'GRE': 'Greece', 'ROM': 'Romania', 'NIR': 'Northern Ireland', 'IRL': 'Ireland', 'HRV': 'Croatia',
            'AUT': 'Austria', 'SUI': 'Switzerland', 'DEN': 'Denmark', 'NOR': 'Norway', 'SWE': 'Sweden',
            'POL': 'Poland', 'UKR': 'Ukraine', 'RUS': 'Russia', 'CZE': 'Czech Republic'
        };

        /**
         * AUTO-DISCOVERY: Busca l'ID della lega tramite API-Football
         */
        async function autoDiscoverLeague(leagueLabel) {
            // 1. Estrazione Paese o Continente
            const ln = leagueLabel.toLowerCase().trim();
            let searchCountry = null;
            let cleanLabel = leagueLabel;
            let prefix = null; // üî• NEW: Track continent prefix (EU-, AF-, etc.)

            // Pattern 1: "XX-YYY Nome" (es. EU-ENG Premier League)
            const countryMatch = leagueLabel.match(/^([A-Z]{2,3})-([A-Z]{2,4})\s+(.+)$/i);
            if (countryMatch) {
                prefix = countryMatch[1].toUpperCase();
                const countryCode = countryMatch[2];
                searchCountry = COUNTRY_MAP[countryCode] || null;
                cleanLabel = countryMatch[3];
            } else {
                // Pattern 2: "XX-Nome" o "XX Nome" (es. EU-Champions League, AF Coppa d'Africa)
                const continentMatch = leagueLabel.match(/^([A-Z]{2,3})[\s-]+(.+)$/i);
                if (continentMatch) {
                    prefix = continentMatch[1].toUpperCase();
                    const restOfLabel = continentMatch[2];

                    // Verifica se il resto inizia con un codice paese (es. "ENG Premier")
                    const innerCountryMatch = restOfLabel.match(/^([A-Z]{2,4})\s+(.+)$/i);
                    if (innerCountryMatch && COUNTRY_MAP[innerCountryMatch[1]]) {
                        searchCountry = COUNTRY_MAP[innerCountryMatch[1]];
                        cleanLabel = innerCountryMatch[2];
                    } else {
                        // √à una competizione continentale (es. Champions League in Europe)
                        searchCountry = CONTINENT_MAP[prefix] || null;
                        cleanLabel = restOfLabel;
                    }
                }
            }

            // Pulizia finale
            cleanLabel = cleanLabel.replace(/\[.*?\]\s*/g, '').trim();
            if (!cleanLabel) return null;

            console.log(`[Auto-Discovery] Sniper targeting: "${cleanLabel}" ${searchCountry ? `in ${searchCountry}` : '(worldwide)'}...`);

            try {
                // PRIMA: Cerca nel catalogo locale (se popolato)
                const catalog = await window.LocalDB.getCatalog();
                if (catalog && catalog.length > 0) {
                    const cleanLower = cleanLabel.toLowerCase();
                    const words = cleanLower.split(/\s+/).filter(w => w.length > 2);

                    let matches = catalog.filter(l => {
                        const catalogName = l.name.toLowerCase();
                        const catalogCountry = (l.country || "").toLowerCase();

                        // üî• NEW: RIGID CONTINENT FILTER (Professional Cleaner)
                        if (prefix) {
                            const continentName = CONTINENT_MAP[prefix]?.toLowerCase();
                            if (continentName) {
                                // Se cerchiamo EU-, il catalogo deve essere in Europa o il paese deve mappare a Europa
                                const catalogIsExpectedContinent = catalogCountry === continentName;
                                // Fallback mapping per paesi nel catalogo (se possibile)
                                if (!catalogIsExpectedContinent) {
                                    // Se abbiamo prefix, controlliamo se il paese del catalogo √® coerente
                                    const mappedCountry = Object.entries(COUNTRY_MAP).find(([code, name]) => name.toLowerCase() === catalogCountry);
                                    if (mappedCountry) {
                                        // TODO: verify mapping if mismatch?
                                    }
                                }
                                // BLOCCA CROSS-CONTINENT (es. NO Messico per EU-)
                                if (prefix === 'EU' && !['england', 'italy', 'spain', 'germany', 'france', 'netherlands', 'belgium', 'portugal', 'scotland', 'turkey', 'greece', 'romania', 'austria', 'switzerland', 'denmark', 'norway', 'sweden', 'poland', 'ukraine', 'russia', 'czech republic', 'croatia', 'serbia', 'bosnia', 'albania', 'macedonia', 'montenegro', 'northern ireland', 'ireland', 'wales', 'bulgaria', 'slovakia', 'hungary', 'slovenia', 'luxembourg', 'cyprus', 'malta', 'iceland', 'estonia', 'latvia', 'lithuania', 'georgia', 'europe'].includes(catalogCountry)) return false;
                                if (prefix === 'SA' && !['argentina', 'brazil', 'chile', 'colombia', 'uruguay', 'paraguay', 'bolivia', 'ecuador', 'peru', 'venezuela', 'south america'].includes(catalogCountry)) return false;
                                if (prefix === 'NA' && !['usa', 'mexico', 'canada', 'costa rica', 'honduras', 'panama', 'jamaica', 'guatemala', 'north america'].includes(catalogCountry)) return false;
                                if (prefix === 'AF' && !['egypt', 'morocco', 'tunisia', 'algeria', 'south africa', 'nigeria', 'ghana', 'kenya', 'uganda', 'tanzania', 'senegal', 'cameroon', 'ivory coast', 'mali', 'africa'].includes(catalogCountry)) return false;
                                if (prefix === 'AS' && !['japan', 'south korea', 'china', 'australia', 'saudi arabia', 'uae', 'qatar', 'india', 'asia'].includes(catalogCountry)) return false;
                            }
                        }

                        // Match esatto
                        if (catalogName === cleanLower) return true;
                        // Contiene o √® contenuto
                        if (catalogName.includes(cleanLower) || cleanLower.includes(catalogName)) return true;
                        // Match parole chiave (tutte le parole devono essere presenti)
                        if (words.length > 0) {
                            const allWordsMatch = words.every(w => catalogName.includes(w));
                            if (allWordsMatch) return true;
                        }

                        return false;
                    }).filter(l => {
                        // Filtro paese se specificato
                        if (!searchCountry) return true;
                        return l.country.toLowerCase() === searchCountry.toLowerCase();
                    });

                    // Prova match esatto
                    const exactMatch = matches.find(l => l.name.toLowerCase() === cleanLower);
                    if (exactMatch) {
                        console.log(`[Auto-Discovery] üéØ Catalog Hit! ${exactMatch.name} (ID: ${exactMatch.id})`);
                        await window.LocalDB.saveLeagueMapping(leagueLabel, exactMatch.id, {
                            apiName: exactMatch.name,
                            country: exactMatch.country,
                            source: 'catalog'
                        });
                        return { id: exactMatch.id, status: 'found' };
                    }

                    // Match univoco
                    if (matches.length === 1) {
                        const m = matches[0];
                        console.log(`[Auto-Discovery] üéØ Catalog Hit! ${m.name} (ID: ${m.id})`);
                        await window.LocalDB.saveLeagueMapping(leagueLabel, m.id, {
                            apiName: m.name,
                            country: m.country,
                            source: 'catalog'
                        });
                        return { id: m.id, status: 'found' };
                    }

                    // Match ambiguo
                    if (matches.length > 1) {
                        console.log(`[Auto-Discovery] ‚ö†Ô∏è Catalog: ${matches.length} matches for "${cleanLabel}"`);
                        return {
                            status: 'ambiguous',
                            options: matches.map(l => ({
                                id: l.id,
                                name: l.name,
                                country: l.country
                            }))
                        };
                    }

                    // Nessun match nel catalogo - ritorna not_found senza chiamare API
                    console.log(`[Auto-Discovery] ‚ùå Catalog: no match for "${cleanLabel}"`);
                    return { status: 'not_found' };
                }

                // FALLBACK: Se catalogo vuoto, usa API (vecchio comportamento)
                if (typeof window.getFootballData !== 'function') return null;

                const params = { name: cleanLabel };
                if (searchCountry) params.country = searchCountry;

                const result = await window.getFootballData({
                    endpoint: 'leagues',
                    params: params
                });

                if (result && result.data && result.data.response) {
                    const leagues = result.data.response;

                    // Match Univoco o Quasi
                    if (leagues.length === 1) {
                        const l = leagues[0].league;
                        const c = leagues[0].country;
                        console.log(`[Auto-Discovery] üéØ Hit! ${l.name} (ID: ${l.id}) in ${c.name}`);

                        // üî• AUTO-SAVE TO LOCAL DB
                        await window.LocalDB.saveLeagueMapping(leagueLabel, l.id, {
                            apiName: l.name,
                            country: c.name,
                            type: l.type,
                            source: 'api_auto_discovered'
                        });

                        return { id: l.id, status: 'found', isNewSave: true };
                    }

                    // Multipli risultati -> Match Esatto
                    if (leagues.length > 1) {
                        const exactMatch = leagues.find(l => l.league.name.toLowerCase() === cleanLabel.toLowerCase());
                        if (exactMatch) {
                            const l = exactMatch.league;
                            await window.LocalDB.saveLeagueMapping(leagueLabel, l.id, {
                                apiName: l.name,
                                country: exactMatch.country.name
                            });
                            return { id: l.id, status: 'found' };
                        }

                        return {
                            status: 'ambiguous', options: leagues.map(l => ({
                                id: l.league.id,
                                name: l.league.name,
                                country: l.country.name
                            }))
                        };
                    }
                }

                return { status: 'not_found' };
            } catch (err) {
                console.error("[Auto-Discovery] sniper failure:", err);
                return null;
            }
        }
        window.autoDiscoverLeague = autoDiscoverLeague;

        const STANDINGS_BLACKLIST_KEYWORDS = [
            'cup', 'coppa', 'trofeo', 'trophy', 'champions', 'europa', 'conference', 'fa',
            'super cup', 'supercoppa', 'qualifiers', 'play-off', 'friendlies', 'friendly', 'international'
        ];

        // NEW: Fetch Real Odds from API-Football via Cloud Function bridge (Bypass CORS)
        // NEW: Fetch Real Odds from API-Football (Direct Fetch - Restored from Backup)
        async function getOddsFromAPI(fixtureId) {
            if (!fixtureId) return [];
            try {
                // Check cache first
                const cacheKey = `odds_${fixtureId}`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const data = JSON.parse(cached);
                    if (data.odds && Date.now() - data.timestamp < 1 * 60 * 60 * 1000) { // 1h cache
                        // console.log(`[API ODDS] Cache hit for ${fixtureId}`);
                        return data.odds;
                    }
                }

                console.log(`[API ODDS] Fetching odds for fixture ${fixtureId} via bridge...`);

                if (typeof window.getFootballData !== 'function') {
                    console.error('[API ODDS] Bridge not ready');
                    return null;
                }

                // üõë UI LOCK: Temporaneamente disabilitato per evitare flash in loop (Step 1 gestisce il progresso internamente)
                // const lockOverlay = showCsvLoadingOverlay('Aggiornamento Quote in corso... Attendere...');

                const result = await window.getFootballData({
                    endpoint: 'odds',
                    params: { fixture: fixtureId }
                });

                const data = result.data;
                const odds = data.response && data.response.length > 0 ? data.response[0].bookmakers : null;

                if (odds) {
                    safeSetItem(cacheKey, JSON.stringify({ odds, timestamp: Date.now() }));
                }

                // hideCsvLoadingOverlay(); // ‚úÖ Release Lock
                return odds;

            } catch (e) {
                console.error('[API ODDS] Error (Direct):', e);
                // Ensure overlay is removed even on error
                // hideCsvLoadingOverlay();
                return null;
            }
        }
        window.getOddsFromAPI = getOddsFromAPI; // Global expose AFTER definition

        /**
         * Fetch Standings for a specific league and season
         */
        async function getStandingsFromAPI(leagueId, season = null) {
            if (!leagueId) return null;
            if (!season) season = new Date().getFullYear();

            // Handle year for leagues starting in summer
            const now = new Date();
            if (now.getMonth() < 6) season = season - 1; // E.g. Jan 2026 -> 2025 season

            try {
                // Check cache
                const cacheKey = `standings_${leagueId}_${season}`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const data = JSON.parse(cached);
                    if (data.standings && Date.now() - data.timestamp < 12 * 60 * 60 * 1000) { // 12h cache
                        return data.standings;
                    }
                }

                console.log(`[API STANDINGS] Fetching standings for league ${leagueId} season ${season}...`);

                if (typeof window.getFootballData !== 'function') return null;

                const result = await window.getFootballData({
                    endpoint: 'standings',
                    params: { league: leagueId, season: season }
                });

                // üì¶ UNWRAP BRIDGE DATA
                const apiData = result.data || result; // Handle both direct and bridge responses

                if (apiData && apiData.response && apiData.response.length > 0) {
                    const leagueData = apiData.response[0].league;
                    if (leagueData.standings && leagueData.standings.length > 0) {
                        // Support both single table (regular leagues) and multiple groups (International Cups)
                        const standings = Array.isArray(leagueData.standings[0])
                            ? leagueData.standings.flat()
                            : leagueData.standings;

                        if (standings) {
                            console.log(`[API STANDINGS] ‚úÖ Success! League ${leagueId} (${leagueData.name}): ${standings.length} teams.`);
                            localStorage.setItem(cacheKey, JSON.stringify({
                                standings: standings,
                                timestamp: Date.now()
                            }));
                            return standings;
                        }
                    }
                }

                // üî• FALLBACK: Try previous season if current is empty (Transition Period)
                console.warn(`[API STANDINGS] ‚ö†Ô∏è Empty response for ${leagueId} season ${season}. Trying ${season - 1}...`);
                const resultOld = await window.getFootballData({
                    endpoint: 'standings',
                    params: { league: leagueId, season: season - 1 }
                });
                const apiDataOld = resultOld.data || resultOld;
                if (apiDataOld && apiDataOld.response && apiDataOld.response.length > 0) {
                    const leagueDataOld = apiDataOld.response[0].league;
                    if (leagueDataOld.standings && leagueDataOld.standings.length > 0) {
                        const standingsOld = Array.isArray(leagueDataOld.standings[0])
                            ? leagueDataOld.standings.flat()
                            : leagueDataOld.standings;
                        if (standingsOld) {
                            console.log(`[API STANDINGS] ‚úÖ Fallback Success! League ${leagueId} season ${season - 1}`);
                            return standingsOld;
                        }
                    }
                }

                return null;
            } catch (err) {
                console.error("[API STANDINGS] Error:", err);
                return null;
            }
        }
        window.getStandingsFromAPI = getStandingsFromAPI;

        // NEW: Fetch HT and FT scores from API-Football for a fixture
        async function getHTScoreFromAPI(fixtureId) {
            if (!fixtureId) {
                console.warn('[API HT] No fixtureId provided');
                return null;
            }

            try {
                // Check cache first
                const cacheKey = `ht_score_${fixtureId}`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const data = JSON.parse(cached);
                    // HT scores don't change after match ends, cache forever
                    if (data.ht && data.ft) {
                        console.log(`[API HT] Cache hit for fixture ${fixtureId}`);
                        return data;
                    }
                }

                console.log(`[API HT] Fetching fixture ${fixtureId} via bridge...`);
                if (typeof window.getFootballData !== 'function') {
                    console.error('[API HT] Bridge not ready');
                    return null;
                }

                const result = await window.getFootballData({
                    endpoint: 'fixtures',
                    params: { id: fixtureId }
                });

                const data = result.data;
                apiCallsToday++;

                if (!data.response || data.response.length === 0) {
                    console.warn('[API HT] No fixture data returned');
                    return null;
                }

                const fixture = data.response[0];
                const scores = {
                    ht: fixture.score?.halftime || { home: null, away: null },
                    ft: fixture.score?.fulltime || { home: null, away: null },
                    status: fixture.fixture?.status?.short || 'UNKNOWN'
                };

                console.log(`[API HT] Fixture ${fixtureId}: HT=${scores.ht.home}-${scores.ht.away}, FT=${scores.ft.home}-${scores.ft.away}`);

                // Cache if we have valid scores
                if (scores.ht.home !== null && scores.ft.home !== null) {
                    safeSetItem(cacheKey, JSON.stringify(scores));
                }

                return scores;
            } catch (e) {
                console.error('[API HT] Error:', e);
                return null;
            }
        }


        // Helper: Safe LocalStorage Set with Auto-Cleanup
        function safeSetItem(key, value) {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                if (e.name === 'QuotaExceededError' || e.code === 22) {
                    console.warn('[STORAGE] Quota exceeded! Cleaning old odds cache...');

                    // 1. Clear all old odds keys
                    Object.keys(localStorage).forEach(k => {
                        if (k.startsWith('odds_')) {
                            localStorage.removeItem(k);
                        }
                    });

                    // 2. Retry set
                    try {
                        localStorage.setItem(key, value);
                        console.log('[STORAGE] Recovery successful. Cache cleared.');
                    } catch (retryErr) {
                        console.error('[STORAGE] Critical: Cache still full after cleanup.', retryErr);
                    }
                }
            }
        }

        // Helper: Show CSV Loading Overlay (Clessidra)
        function showCsvLoadingOverlay(message = 'Elaborazione...') {
            const overlay = document.createElement('div');
            overlay.id = 'csv-loading-overlay';
            overlay.innerHTML = `
                <div style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center;">
                    <div style="font-size:64px;">‚è≥</div>
                    <div id="csv-loading-message" style="color:white;font-size:18px;margin-top:16px;font-weight:bold;">${message}</div>
                </div>
            `;
            document.body.appendChild(overlay);
            return overlay;
        }

        function hideCsvLoadingOverlay() {
            const overlay = document.getElementById('csv-loading-overlay');
            if (overlay) overlay.remove();
        }

        function updateCsvLoadingMessage(message) {
            const msgEl = document.getElementById('csv-loading-message');
            if (msgEl) msgEl.textContent = message;
        }

        // MATCH TIMES CACHE (Firebase - condiviso tutti utenti, 24h)
        const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 ore

        // Salva orario in Firebase cache temporanea
        async function saveTimeToCache(date, partita, ora) {
            if (!ora || ora.trim() === '') return;

            try {
                const key = `${date}_${partita.replace(/[^a-zA-Z0-9]/g, '_')}`;
                await setDoc(doc(db, "match_times_temp", key), {
                    data: date,
                    partita: partita,
                    ora: ora,
                    timestamp: Date.now()
                });
            } catch (e) {
                console.error('[CACHE] Error saving time:', e);
            }
        }

        // Ottieni orario da Firebase cache
        async function getTimeFromCache(date, partita) {
            try {
                const key = `${date}_${partita.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const docSnap = await getDoc(doc(db, "match_times_temp", key));

                if (!docSnap.exists()) return null;

                const data = docSnap.data();

                // Check se >24h
                if (Date.now() - data.timestamp > CACHE_DURATION) {
                    // Expired, cancella
                    await deleteDoc(doc(db, "match_times_temp", key));
                    return null;
                }

                return data.ora;
            } catch (e) {
                console.error('[CACHE] Error getting time:', e);
                return null;
            }
        }

        // Cleanup automatico cache >24h (batch)
        async function cleanupExpiredTimes() {
            try {
                const q = query(collection(db, "match_times_temp"));
                const snapshot = await getDocs(q);

                const batch = writeBatch(db);
                let cleanedCount = 0;
                const now = Date.now();

                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (now - data.timestamp > CACHE_DURATION) {
                        batch.delete(doc.ref);
                        cleanedCount++;
                    }
                });

                if (cleanedCount > 0) {
                    await batch.commit();
                    console.log(`[CACHE] Cleaned ${cleanedCount} expired times (>24h)`);
                }
            } catch (e) {
                console.error('[CACHE] Cleanup error:', e);
            }
        }

        // Stats cache
        async function getCacheStats() {
            try {
                const q = query(collection(db, "match_times_temp"));
                const snapshot = await getDocs(q);
                return {
                    total: snapshot.size,
                    items: snapshot.docs.map(d => d.data())
                };
            } catch (e) {
                return { total: 0, items: [] };
            }
        }
        // ==================== UI HELPERS ====================

        /**
         * Renders a Simplified Strategy Card (Static DB Data)
         * For: Italia, All, Special AI, Top Eu, WinRate 80%
         */
        window.renderSimpleStrategyCard = function (m, idx) {
            // FIX: Lookup ORIGINAL match directly from Global Store to avoid data loss
            let originalMatch = null;
            if (typeof window.allMatches !== 'undefined' && Array.isArray(window.allMatches)) {
                originalMatch = window.allMatches.find(x => x.id === m.id);
            }

            // Extract TRUE DB Values from Original Source
            const dbTip = originalMatch ? (originalMatch.tip || '') : (m.originalDBTip || m.tip || '');
            const dbQuota = originalMatch ? (originalMatch.quota || '') : (m.originalDBQuota || m.quota || '-');
            const dbProb = originalMatch ? (originalMatch.probabilita || 0) : (m.probabilita || 0);

            // Determine if WIN/LOSS for styling
            // Since these are often past matches in "WinRate 80%", we might show result
            const resultBadge = m.risultato ? `<span class="bg-gray-100 text-gray-800 px-2 py-0.5 rounded text-[10px] font-bold border border-gray-200">${m.risultato}</span>` : '';
            const esitoClass = m.esito === 'Vinto' ? 'bg-green-100 text-green-700 border-green-200' :
                m.esito === 'Perso' ? 'bg-red-100 text-red-700 border-red-200' : 'bg-gray-100 text-gray-500 border-gray-200';
            const esitoBadge = m.esito ? `<span class="${esitoClass} px-2 py-0.5 rounded text-[10px] font-bold border ml-1">${m.esito}</span>` : '';

            return `
                <div class="border-2 border-gray-200 rounded-xl p-3 bg-white shadow-sm hover:shadow-md transition-all mb-3 relative overflow-hidden group">
                    
                    <!-- HEADER: League + Time -->
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center gap-2">
                             <span class="bg-gray-100 text-gray-600 px-1.5 py-0.5 rounded text-[10px] font-bold uppercase tracking-wide border border-gray-200">
                                ${m.lega}
                            </span>
                            <span class="text-[10px] text-gray-400 font-mono flex items-center">
                                <i class="far fa-clock mr-1 text-[9px]"></i>${m.ora || '--:--'}
                            </span>
                        </div>
                         <div class="flex items-center">
                            ${resultBadge}
                            ${esitoBadge}
                        </div>
                    </div>

                    <!-- TEAMS -->
                    <div class="mb-3">
                         <div class="font-bold text-gray-800 text-sm leading-tight truncate">${m.partita}</div>
                    </div>

                    <!-- MAIN INFO ROW (Compact) -->
                    <div class="bg-gradient-to-r from-gray-50 to-white border border-gray-200 rounded-lg p-2.5 flex justify-between items-center">
                        <div class="flex flex-col">
                            <span class="text-[9px] uppercase font-bold text-gray-400 mb-0.5">Tip</span>
                            <span class="text-xl font-black text-purple-700 leading-none">${dbTip}</span>
                        </div>
                        
                        <div class="text-right">
                            <span class="text-[9px] uppercase font-bold text-gray-400 mb-0.5">Quota & Prob</span>
                            <div class="flex items-center justify-end gap-2">
                                <span class="text-xs font-bold text-gray-500 bg-white border border-gray-200 px-1.5 py-0.5 rounded">@${dbQuota}</span>
                                <span class="text-xs font-bold text-blue-600 bg-blue-50 border border-blue-100 px-1.5 py-0.5 rounded">${dbProb}%</span>
                            </div>
                        </div>
                    </div>

                    <!-- üî• RESULT ROW -->
                    ${m.risultato ? `
                        <div class="mt-2 py-1 px-3 rounded-lg text-[10px] font-black text-center border ${m.esito === 'Vinto' ? 'bg-green-50 border-green-200 text-green-700' : m.esito === 'Perso' ? 'bg-red-50 border-red-200 text-red-700' : 'bg-gray-50 border-gray-200 text-gray-600'}">
                            RISULTATO: ${m.risultato} ${m.risultato_ht ? `(HT: ${m.risultato_ht})` : ''} - ${m.esito || '...'}
                        </div>
                    ` : ''}
                </div>
            `;
        };

        /**
         * Renders the Magia AI Strategy Card (Single Source of Truth)
         * Design Versus: IA vs Betmines con esiti indipendenti.
         */
        window.renderMagiaAICard = function (m, idx, isPreview = false) {
            // FIX: Lookup ORIGINAL match direttamente dallo store globale per evitare perdite di dati
            let originalMatch = null;
            if (typeof window.allMatches !== 'undefined' && Array.isArray(window.allMatches)) {
                originalMatch = window.allMatches.find(x => String(x.id) === String(m.id));
            }

            // Dati dal Database originale (Betmines)
            const dbTip = originalMatch ? (originalMatch.tip || '') : (m.originalDBTip || m.tip || '');
            const dbQuota = originalMatch ? (originalMatch.quota || '') : (m.originalDBQuota || m.quota || '-');
            const dbProb = originalMatch ? (originalMatch.probabilita || 0) : (m.probabilita || 0);

            // Dati Magia AI
            const normalizedStats = {
                tipMagiaAI: m.magicStats?.tipMagiaAI || m.tip || '--',
                oddMagiaAI: m.magicStats?.oddMagiaAI || m.quota || 'N/A',
                probMagiaAI: m.magicStats?.probMagiaAI || m.magicStats?.mcProbForTip || m.magicStats?.confidence || m.probabilita || 0,
                smartScore: m.magicStats?.smartScore || m.score || 0,
                top3Scores: m.magicStats?.top3Scores || m.top3Scores || [],
                volatility: m.magicStats?.volatility || null,
                ht05: m.magicStats?.ht05 || 0,
                isReinforced: false
            };

            // Badge Segnale Rafforzato (confronto tip)
            if (dbTip && !m.onlyMagia) {
                const normDb = dbTip.replace('+', '').replace('-', '').replace('Over ', '').replace('Under ', '').trim();
                const normMagia = normalizedStats.tipMagiaAI.replace('+', '').replace('-', '').replace('Over ', '').replace('Under ', '').trim();
                if (normDb === normMagia || dbTip === normMagia) {
                    normalizedStats.isReinforced = true;
                }
            }

            // Calcolo esiti indipendenti
            // Se √® solo AI, la colonna DB va nascosta o segnalata
            const isOnlyAI = m.onlyMagia || !dbTip;

            // Calcolo esiti indipendenti
            const esitoIA = m.risultato ? calculateOutcome({ tip: normalizedStats.tipMagiaAI, risultato: m.risultato }) : '';
            const esitoDB = (m.risultato && !isOnlyAI) ? calculateOutcome({ tip: dbTip, risultato: m.risultato }) : '';

            const isWinIA = esitoIA === 'Vinto';
            const isWinDB = esitoDB === 'Vinto';

            const probDisplay = typeof normalizedStats.probMagiaAI === 'number' ? normalizedStats.probMagiaAI.toFixed(0) : normalizedStats.probMagiaAI;

            // Background color logic (sfumato) - STRETTAMENTE COMPARATIVA
            let rowBg = 'bg-white';
            let rowBorder = 'border-slate-100';

            if (m.risultato) {
                if (isWinIA && esitoDB === 'Perso') {
                    rowBg = 'bg-emerald-100/60';
                    rowBorder = 'border-emerald-200';
                } else if (esitoIA === 'Perso' && isWinDB) {
                    rowBg = 'bg-rose-100/60';
                    rowBorder = 'border-rose-200';
                }
            } else if (isOnlyAI) {
                rowBg = 'bg-sky-50/50';
                rowBorder = 'border-sky-100';
            }

            return `
                <div class="group border-2 ${rowBorder} ${rowBg} rounded-xl hover:shadow-lg transition-all relative py-4 px-5 flex flex-col md:flex-row md:items-center gap-5 mb-5 mx-1">
                    
                    <!-- LEFT: MATCH INFO -->
                    <div class="flex items-center gap-4 flex-1 min-w-[250px]">
                        <span class="text-xl font-black text-slate-200 group-hover:text-indigo-500 transition-colors w-10">#${idx + 1}</span>
                        <div class="flex-1">
                            <div class="font-black text-slate-900 text-sm md:text-base uppercase tracking-tight flex items-center gap-2">
                                ${m.partita}
                                ${normalizedStats.volatility ? `<span class="text-amber-500"><i class="fa-solid fa-bolt-lightning text-[10px]"></i></span>` : ''}
                            </div>
                            <div class="text-[10px] text-slate-500 font-bold uppercase tracking-widest mt-0.5">
                                <span class="text-indigo-600">${m.lega}</span> ${m.ora ? `‚Ä¢ ${m.ora}` : ''}
                            </div>
                        </div>
                    </div>

                    <!-- CENTER: RISULTATO -->
                    <div class="flex flex-col items-center justify-center min-w-[100px] py-1 px-3 bg-white/60 rounded-lg border border-white/80 shadow-sm">
                        <span class="text-[9px] font-black text-slate-400 uppercase tracking-widest mb-0.5 leading-none">RISULTATO</span>
                        <div class="flex items-baseline gap-1.5">
                            <span class="text-xl font-black text-slate-900 leading-none">${m.risultato || '--'}</span>
                            ${m.risultato_ht ? `<span class="text-[10px] font-bold text-slate-400">(${m.risultato_ht})</span>` : ''}
                        </div>
                    </div>

                    <!-- RIGHT: PREVISIONI -->
                    <div class="flex flex-wrap items-center gap-3 flex-[2]">
                        
                        <!-- AI BOX -->
                        <div class="flex-1 min-w-[180px] p-2 bg-white/80 rounded-lg border border-indigo-100 shadow-sm flex items-center justify-between gap-2">
                            <div>
                                <div class="text-[9px] font-black text-indigo-700 uppercase mb-0.5">üîÆ MAGIA AI</div>
                                <div class="font-black text-slate-900 text-sm">
                                    ${normalizedStats.tipMagiaAI} <span class="text-indigo-400 font-bold">@${normalizedStats.oddMagiaAI}</span>
                                    <span class="text-[10px] text-slate-400 ml-1 font-bold">(${probDisplay}%)</span>
                                </div>
                            </div>
                            ${esitoIA ? `
                                <div class="px-2 py-1 rounded text-[9px] font-black uppercase tracking-wider shadow-sm ${isWinIA ? 'bg-green-500 text-white' : 'bg-red-500 text-white'}">
                                    ${esitoIA}
                                </div>
                            ` : ''}
                        </div>

                        <!-- DB BOX -->
                        ${!isOnlyAI ? `
                            <div class="flex-1 min-w-[180px] p-2 bg-white/80 rounded-lg border border-slate-200 shadow-sm flex items-center justify-between gap-2">
                                <div>
                                    <div class="text-[9px] font-black text-slate-500 uppercase mb-0.5">üìÇ BETMINES</div>
                                    <div class="font-black text-slate-900 text-sm">
                                        ${dbTip} <span class="text-slate-400 font-bold">@${dbQuota || '-'}</span>
                                        <span class="text-[10px] text-slate-400 ml-1 font-bold">(${dbProb}%)</span>
                                    </div>
                                </div>
                                ${esitoDB ? `
                                    <div class="px-2 py-1 rounded text-[9px] font-black uppercase tracking-wider shadow-sm ${isWinDB ? 'bg-green-500 text-white' : 'bg-red-500 text-white'}">
                                        ${esitoDB}
                                    </div>
                                ` : ''}
                            </div>
                        ` : `
                            <div class="flex-1 min-w-[180px] p-2 bg-slate-50/50 rounded-lg border border-dashed border-slate-200 flex items-center justify-center text-[10px] font-bold text-slate-400 italic">
                                Nessun dato Betmines
                            </div>
                        `}
                    </div>
                </div>
            `;
        };

        let dailyFixturesCache = null; // Bulk cache giornaliero


        // ==================== FUZZY MATCHING ====================
        // NOTE: levenshteinDistance is now provided by js/utils.js (window.levenshteinDistance)

        // Fuzzy match team name
        const SYNONYMS = {
            "C√¥te d'Ivoire": "Ivory Coast",
            "Cote d'Ivoire": "Ivory Coast",
            "Hapoel Jerusalem": "Hapoel Katamon Jerusalem", // Probabile match
            "Hapoel Katamon": "Hapoel Katamon Jerusalem",
            "Al Hilal": "Al-Hilal Saudi FC", // Tentativo per Saudi
            "Al-Hilal": "Al-Hilal Saudi FC",
            "GAP Connah S Quay FC": "Connah's Quay", // Reverse mapping sometimes needed
            "Connah's Quay": "GAP Connah S Quay FC",
            "TNs": "The New Saints",
            "Greenock Morton": "Morton",
            "Dunfermline Athletic": "Dunfermline",
            "Salzburg": "Red Bull Salzburg",
            "Bragantino": "Red Bull Bragantino",
            "Mirassol": "Mirassol"
        };

        const clean = (name) => {
            if (!name) return '';
            // Check dictionary first
            if (SYNONYMS[name]) return SYNONYMS[name].toLowerCase().trim();

            return name.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase()
                .replace(/\bfc\b/g, '')
                .replace(/\bcf\b/g, '')
                .replace(/\bunited\b/g, 'utd')
                .replace(/\bnorm\b/g, '')
                .replace(/\bred bull\b/g, '') // üî• Ignore Red Bull for better matching
                .replace(/\besporte clube\b/g, '') // üî• Ignore Esporte Clube
                .replace(/\bclube\b/g, '')
                .replace(/\bsporting\b/g, '')
                .replace(/[^a-z0-9]/g, '')
                .trim();
        };

        function fuzzyMatchTeam(csvTeam, apiTeams) {
            // SYNONYM DICTIONARY (Cura manuale per casi impossibili)


            const csvNorm = clean(csvTeam);
            let bestMatch = null;
            let bestScore = Infinity;

            for (let apiTeam of apiTeams) {
                const apiNorm = clean(apiTeam);

                // Match esatto pulito
                if (csvNorm === apiNorm) {
                    return apiTeam;
                }

                // üî• SUBSTRING MATCH (High confidence if one is inside other)
                // Es: "Salzburg" vs "Red Bull Salzburg"
                if (csvNorm.length >= 4 && apiNorm.length >= 4) {
                    if (csvNorm.includes(apiNorm) || apiNorm.includes(csvNorm)) {
                        console.log(`[MATCH DEBUG] üéØ Substring Match: "${csvTeam}" < -> "${apiTeam}"`);
                        return apiTeam;
                    }
                }

                // Contains pulito (Legacy fallback)
                if (csvNorm.length > 3 && (csvNorm.includes(apiNorm) || apiNorm.includes(csvNorm))) {
                    const distance = levenshteinDistance(csvNorm, apiNorm);
                    // console.log(`[MATCH DEBUG] üîç Partial match candidate: "${csvTeam}" vs "${apiTeam}"(Dist: ${ distance })`);
                    if (distance < bestScore) {
                        bestScore = distance;
                        bestMatch = apiTeam;
                    }
                }

                // Levenshtein su nomi puliti
                const distance = levenshteinDistance(csvNorm, apiNorm);
                if (distance < bestScore) {
                    bestScore = distance;
                    bestMatch = apiTeam;
                }
            }

            // Accetta se la distanza √® piccola rispetto alla lunghezza del nome
            const threshold = Math.max(3, csvNorm.length * 0.4);

            if (bestScore < threshold) {
                return bestMatch;
            } else {
                return null;
            }
        }

        // ==================== BULK API FOOTBALL ====================

        // Carica tutte le fixtures del giorno (1 chiamata bulk) con ottimizzazione per ridurre il peso in memoria
        async function loadDailyFixtures(date, teamsToFilter = null, forceRefresh = false) {
            window.loadDailyFixtures = loadDailyFixtures; // Ensure global access immediately

            // AUTO-CLEANUP: Rimuovi vecchie cache di oltre 3 giorni
            try {
                const keys = Object.keys(localStorage);
                const threeDaysAgo = Date.now() - (3 * 24 * 60 * 60 * 1000);
                keys.forEach(k => {
                    if (k.startsWith('fixtures_')) {
                        try {
                            const d = JSON.parse(localStorage.getItem(k));
                            if (d.timestamp < threeDaysAgo) {
                                localStorage.removeItem(k);
                            }
                        } catch (e) { }
                    }
                });
            } catch (e) { }

            // Use Versioned Key v2
            const cacheKey = `fixtures_v2_${date} `;
            const cached = localStorage.getItem(cacheKey);
            let baseFixtures = [];

            // 1. Check if we have a valid cache in localStorage (and NOT forced)
            if (cached && !forceRefresh) {
                try {
                    const data = JSON.parse(cached);
                    // Valid for 6 hours
                    if (Date.now() - data.timestamp < 6 * 60 * 60 * 1000) {
                        baseFixtures = data.fixtures;
                    }
                } catch (e) { localStorage.removeItem(cacheKey); }
            }

            // 2. If no cache or expired, fetch from API
            if (baseFixtures.length === 0) {
                try {
                    console.log(`[API DEBUG] Fetching COMPLETE fixture list from API - Football...`);
                    if (typeof window.getFootballData !== 'function') return [];
                    const result = await window.getFootballData({
                        endpoint: 'fixtures',
                        params: { date: date }
                    });
                    const data = result.data;
                    apiCallsToday++;
                    const allFixtures = data.response || [];

                    // Safety Check
                    if (allFixtures.length === 0) return [];

                    // Simplify ALL fixtures
                    baseFixtures = allFixtures.map(f => ({
                        fixture: { id: f.fixture.id, date: f.fixture.date, status: f.fixture.status },
                        teams: {
                            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
                            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo }
                        },
                        league: {
                            id: f.league.id,
                            name: f.league.name,
                            country: f.league.country,
                            logo: f.league.logo
                        },
                        score: f.score,
                        goals: f.goals
                    }));

                    // Save the FULL set
                    try {
                        localStorage.setItem(cacheKey, JSON.stringify({
                            fixtures: baseFixtures,
                            timestamp: Date.now()
                        }));
                    } catch (storageErr) {
                        console.warn('[API DEBUG] localStorage full, flushing old fixtures...');
                        Object.keys(localStorage).filter(k => k.startsWith('fixtures_')).forEach(fk => localStorage.removeItem(fk));
                    }
                } catch (e) {
                    return [];
                }
            }
            dailyFixturesCache = baseFixtures;

            // 3. APPLY FILTER
            if (teamsToFilter) {
                const cleanForFilter = (s) => s.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^a-z0-9]/g, '').trim();
                const filterList = teamsToFilter.map(t => cleanForFilter(t));

                const filtered = baseFixtures.filter(f => {
                    const homeClean = cleanForFilter(f.teams.home.name);
                    const awayClean = cleanForFilter(f.teams.away.name);

                    return filterList.some(t => {
                        if (homeClean.includes(t) || t.includes(homeClean) ||
                            awayClean.includes(t) || t.includes(awayClean)) return true;

                        const tWords = t.split(/\d/).filter(w => w.length > 2);
                        const homeWords = homeClean.split(/\d/).filter(w => w.length > 2);
                        const awayWords = awayClean.split(/\d/).filter(w => w.length > 2);

                        if (tWords.some(tw => homeWords.some(hw => hw.includes(tw) || tw.includes(hw)))) return true;
                        if (tWords.some(tw => awayWords.some(aw => aw.includes(tw) || tw.includes(aw)))) return true;

                        if (t.length > 4 && (homeClean.startsWith(t.slice(0, 4)) || awayClean.startsWith(t.slice(0, 4)))) return true;
                        if (homeClean.length > 4 && t.startsWith(homeClean.slice(0, 4))) return true;
                        if (awayClean.length > 4 && t.startsWith(awayClean.slice(0, 4))) return true;

                        return false;
                    });
                });

                return filtered;
            }

            return baseFixtures;
        }
        window.loadDailyFixtures = loadDailyFixtures; // Global expose AFTER definition

        // Cache per classifiche per evitare chiamate ridondanti nella stessa sessione
        let standingsCache = new Map();
        window.standingsCache = standingsCache;
        const STANDINGS_TTL = 60 * 60 * 1000; // 1 ora
        const MAX_STANDINGS_CACHE_SIZE = 50; // Prevent memory leak

        // Helper: Auto-cleanup oldest entries if cache grows too large
        function cleanupStandingsCache() {
            if (standingsCache.size > MAX_STANDINGS_CACHE_SIZE) {
                const keysToDelete = Array.from(standingsCache.keys()).slice(0, standingsCache.size - MAX_STANDINGS_CACHE_SIZE);
                keysToDelete.forEach(k => standingsCache.delete(k));
                console.log(`[Standings] Cache cleanup: removed ${keysToDelete.length} old entries`);
            }
        }

        async function fetchLeagueStandings(leagueId, season = 2025) {
            const cacheKey = `standings_${leagueId}_${season}`;

            // 1. Check in-memory cache (sessione corrente)
            if (standingsCache.has(cacheKey)) {
                console.log(`[Standings] Using memory cache for league ${leagueId}`);
                return standingsCache.get(cacheKey);
            }

            // 2. Check localStorage cache (persiste tra refresh)
            try {
                const stored = localStorage.getItem(cacheKey);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    if (Date.now() - parsed.timestamp < STANDINGS_TTL) {
                        console.log(`[Standings] Using localStorage cache for league ${leagueId}`);
                        standingsCache.set(cacheKey, parsed.data);
                        return parsed.data;
                    }
                }
            } catch (e) { /* ignore parse errors */ }

            // 3. Fetch from API (solo se non in cache)
            try {
                // Piccola pausa per evitare rate limiting (solo quando chiamiamo API)
                await new Promise(r => setTimeout(r, 200));

                if (typeof window.getFootballData !== 'function') return [];
                const result = await window.getFootballData({
                    endpoint: 'standings',
                    params: { league: leagueId, season: season }
                });
                const data = result.data;

                const standings = data.response?.[0]?.league?.standings?.[0] || [];

                // Salva in entrambe le cache
                standingsCache.set(cacheKey, standings);
                cleanupStandingsCache(); // Prevent memory leak
                try {
                    localStorage.setItem(cacheKey, JSON.stringify({ data: standings, timestamp: Date.now() }));
                } catch (e) { /* localStorage pieno, ignora */ }

                return standings;
            } catch (e) {
                console.error(`[Standings API] Error for league ${leagueId}:`, e);
                return [];
            }
        }


        // Trova fixture matchante con logica sequenziale (Step 1-2)
        function findMatchingFixture(csvMatch, pool, mode = 'both') {
            if (!pool || pool.length === 0) return null;

            const [csvHome, csvAway] = csvMatch.split(' - ').map(t => t.trim());
            const apiHomeTeams = pool.map(f => f.teams.home.name);
            const apiAwayTeams = pool.map(f => f.teams.away.name);

            // STEP 1: Match per Casa
            if (mode === 'home' || mode === 'both') {
                const matchedHome = fuzzyMatchTeam(csvHome, apiHomeTeams);
                if (matchedHome) {
                    const fixture = pool.find(f => f.teams.home.name === matchedHome);
                    if (fixture) return fixture;
                }
            }

            // STEP 2: Match per Trasferta
            if (mode === 'away' || mode === 'both') {
                const matchedAway = fuzzyMatchTeam(csvAway, apiAwayTeams);
                if (matchedAway) {
                    const fixture = pool.find(f => f.teams.away.name === matchedAway);
                    if (fixture) return fixture;
                }
            }

            return null;
        }
        window.findMatchingFixture = findMatchingFixture; // Global expose (MUST be after function def)

        // Ottieni orario da bulk cache
        function getTimeFromBulkCache(date, match) {
            if (!dailyFixturesCache) return null;

            const fixture = findMatchingFixture(match, dailyFixturesCache);
            if (!fixture || !fixture.fixture || !fixture.fixture.date) return null;

            // Converti UTC a ora italiana
            const utcDate = new Date(fixture.fixture.date);
            const italianTime = new Date(utcDate.getTime() + (1 * 60 * 60 * 1000)); // UTC+1

            const hours = String(italianTime.getHours()).padStart(2, '0');
            const minutes = String(italianTime.getMinutes()).padStart(2, '0');

            return `${hours}:${minutes}`;
        }

        // ODDS CORRELATIONS LOOKUP TABLE - CALIBRATE SU 12,414 MATCH REALI
        // Aggiornato v3.3 con dati storici effettivi
        const ODDS_CORRELATIONS = {
            "+1.5": {
                "+2.5": {
                    // Basato su analisi: Over1.5@1.00-1.15 ‚Üí 63.5% Over2.5 ‚Üí @1.65
                    "1.00-1.15": [1.58, 1.72],
                    "1.10-1.20": [1.60, 1.75],
                    // Over1.5@1.15-1.25 ‚Üí 56.5% Over2.5 ‚Üí @1.86
                    "1.15-1.25": [1.78, 1.95],
                    "1.20-1.30": [1.80, 2.00],
                    // Over1.5@1.25-1.35 ‚Üí 51.6% Over2.5 ‚Üí @2.03
                    "1.25-1.35": [1.95, 2.15],
                    "1.30-1.40": [2.00, 2.20],
                    // Over1.5@1.35-1.50 ‚Üí 42.6% Over2.5 ‚Üí @2.47
                    "1.35-1.50": [2.35, 2.60],
                    "1.40-1.50": [2.40, 2.65]
                },
                "+3.5": {
                    // Basato su: Over1.5@1.00-1.15 ‚Üí 43.1% Over3.5 ‚Üí @2.44
                    "1.00-1.15": [2.30, 2.55],
                    "1.10-1.20": [2.35, 2.60],
                    // Over1.5@1.15-1.25 ‚Üí 34.5% Over3.5 ‚Üí @3.04
                    "1.15-1.25": [2.90, 3.20],
                    "1.20-1.30": [2.95, 3.25],
                    // Over1.5@1.25-1.35 ‚Üí 29.7% Over3.5 ‚Üí @3.54
                    "1.25-1.35": [3.35, 3.75],
                    "1.30-1.40": [3.45, 3.85]
                },
                "-2.5": {
                    "1.10-1.20": [2.50, 3.00],
                    "1.20-1.30": [2.20, 2.70],
                    "1.30-1.40": [2.00, 2.40]
                }
            },
            "+2.5": {
                "+3.5": {
                    "1.10-1.20": [1.50, 1.75],
                    "1.20-1.30": [1.70, 2.00],
                    "1.30-1.40": [1.90, 2.30],
                    "1.40-1.60": [2.10, 2.60]
                },
                "+4.5": {
                    "1.10-1.20": [2.30, 2.80],
                    "1.20-1.30": [2.50, 3.00],
                    "1.30-1.40": [2.70, 3.30]
                },
                "-3.5": {
                    "1.10-1.20": [2.00, 2.40],
                    "1.20-1.30": [1.80, 2.20],
                    "1.30-1.40": [1.60, 2.00]
                }
            }
        };

        // TOP LEGHE PER OVER (dalla nostra analisi)
        const TOP_OVER_LEAGUES = [
            'EU-FIN Kakkonen', 'EU-TUR Turkish Cup', 'EU-SVK Slovakia Cup',
            'EU-NOR Eliteserien', 'EU-NOR Obos-Ligaen', 'EU-FIN Veikkausliiga',
            'EU-NLD Eredivisie', 'EU-Champions League', 'NA-USA Major League Soccer',
            'EU-EST Meistriliiga', 'EU-SWE Ettan: North', 'EU-WAL Premier League',
            'EU-DEU 3. Liga', 'EU-SWE Ettan: South', 'EU-POL 1. Liga'
        ];

        // UTILS: Date formatting and parsing moved to js/utils.js

        // ==================== GLOBAL STATS VARS ====================
        let tipsFileCount = 0;
        let htFileCount = 0;

        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', async () => {
            const loadingOverlay = document.getElementById('loading-overlay');
            const authStatus = document.getElementById('auth-status');
            const retryBtn = document.getElementById('retry-auth-btn');




            // ==================== MODAL (Global) ====================
            function showModal(title, message, onConfirm = null) {
                document.getElementById('modal-title').textContent = title;
                document.getElementById('modal-message').innerHTML = message;

                const confirmBtn = document.getElementById('modal-confirm');
                const cancelBtn = document.getElementById('modal-cancel');

                // Reset listeners
                const newConfirm = confirmBtn.cloneNode(true);
                const newCancel = cancelBtn.cloneNode(true);
                confirmBtn.parentNode.replaceChild(newConfirm, confirmBtn);
                cancelBtn.parentNode.replaceChild(newCancel, cancelBtn);

                newConfirm.addEventListener('click', () => {
                    document.getElementById('modal').classList.add('hidden');
                    if (onConfirm) onConfirm();
                });

                newCancel.addEventListener('click', () => {
                    document.getElementById('modal').classList.add('hidden');
                });

                if (!onConfirm) {
                    newCancel.classList.add('hidden');
                    newConfirm.textContent = "OK";
                } else {
                    newCancel.classList.remove('hidden');
                    newConfirm.textContent = "Conferma";
                }

                document.getElementById('modal').classList.remove('hidden');
            }

            // --- GESTIONE AUTH ---

            async function authenticate() {
                authStatus.textContent = "Connessione a Firebase...";
                authStatus.className = "text-blue-200 text-sm font-mono bg-gray-800 p-2 rounded border border-gray-700";
                retryBtn.classList.add('hidden');

                try {
                    await setPersistence(auth, browserLocalPersistence);
                    await signInAnonymously(auth);
                    // Non nascondiamo ancora l'overlay, aspettiamo il caricamento dati
                    authStatus.textContent = "Autenticato. Caricamento dati...";
                    authStatus.className = "text-green-400 text-sm font-mono bg-gray-800 p-2 rounded border border-green-700";

                    // Avvia l'app vera e propria
                    await startApp();

                } catch (error) {
                    console.error("Auth Error:", error);
                    let msg = "Errore sconosciuto.";
                    if (error.code === 'auth/api-key-not-valid') {
                        msg = "CHIAVE API NON VALIDA. Controlla il codice HTML.";
                    } else if (error.code === 'auth/operation-not-allowed') {
                        msg = "AUTH ANONIMA NON ABILITATA in Firebase Console.";
                    } else {
                        msg = error.message;
                    }

                    authStatus.innerHTML = `<strong class="text-red-500">ERRORE:</strong><br>${msg}`;
                    authStatus.className = "text-red-300 text-xs font-mono bg-red-900/50 p-2 rounded border border-red-700 text-left break-words";
                    document.getElementById('loading-spinner').textContent = "‚ö†Ô∏è Connessione Fallita";
                    document.getElementById('loading-spinner').classList.remove('animate-pulse');
                    retryBtn.classList.remove('hidden');
                }
            }

            retryBtn.addEventListener('click', authenticate);

            // Global state variables
            let showOnlyNoResult = false;

            // --- START APP LOGIC ---
            initializeAdminApp = async function () {
                try {
                    // üîó LOAD LEAGUE REGISTRY INTO GLOBAL MAP (for synchronous engine.js lookup)
                    try {
                        await window.LocalDB.init();
                        const registry = await window.LocalDB.getAllLeagueMappings();
                        if (registry && registry.length > 0) {
                            window.leaguesRegistry = new Map();
                            window.leaguesRegistryById = new Map(); // üî• NEW: ID-CENTRIC LOOKUP
                            window.LEAGUE_MAPPING = {};
                            registry.forEach(r => {
                                const key = r.name.toLowerCase().trim();
                                window.leaguesRegistry.set(key, r);
                                if (r.leagueId) window.leaguesRegistryById.set(parseInt(r.leagueId), r);
                                window.LEAGUE_MAPPING[key] = r.leagueId;
                            });
                            console.log(`[Registry] ‚úÖ Loaded ${registry.length} leagues into global registry Maps`);
                        }
                    } catch (regErr) {
                        console.warn('[Registry] Failed to load:', regErr);
                    }
                    await window.databaseManager.loadLeagueTrust(db);
                    console.log("[Trust] ‚úÖ League Trust System Initialized");

                    await loadAllMatches();
                    await loadFavorites();
                    await updateGlobalStats(); // Calculate and save stats for client
                    setupFilters();
                    populateFilters();
                    applyFiltersAndRender();
                    await loadSavedFilters();
                    await loadClientFiltersForAdmin(); // Load Client Filters

                    showPage('page-dashboard');
                    loadingOverlay.classList.add('hidden');
                } catch (e) {
                    console.error("Data Load Error:", e);
                    authStatus.textContent = "Errore caricamento dati Firestore.";
                    authStatus.classList.add('text-red-400');
                }
            } // Close startApp early

            // ==================== STATISTICAL ENGINE ====================

            // Store calculated results for saving strategy
            let currentStatResults = null;
            let currentStatConfig = null;

            // Mapping tip codes to user-friendly names
            // Mapping tip codes to user-friendly names (Moved to utils.js)

            // Save Statistical Strategy to Firestore
            async function saveStatisticalStrategy() {
                if (!currentStatResults || currentStatResults.length === 0) {
                    alert('Prima esegui un calcolo per generare delle partite!');
                    return;
                }

                const targetDate = document.getElementById('stat-target-date').value;
                const tipOutput = document.getElementById('stat-tip-output').value;
                const tipDisplayName = getTipDisplayName(tipOutput);

                // Generate strategy name in user-friendly format
                const strategyName = `‚ú® ${tipDisplayName} AI`;
                const strategyId = `ai_${tipOutput.replace('+', 'over').replace('-', 'under').replace('.', '')}`;

                // Prepare matches with user-friendly fields (no technical jargon)
                const matches = currentStatResults.map((r, idx) => {
                    // Parse teams for stats
                    const teams = r.partita.split(' - ');
                    let homeWinrate = 0, awayWinrate = 0;
                    let homeCount = 0, homeTotal = 0, awayCount = 0, awayTotal = 0;

                    if (teams.length === 2) {
                        // Use analyzeTeamStats to get Over 2.5 winrate from last 9 matches
                        const homeStats = analyzeTeamStats(teams[0].trim(), true, tipOutput, allMatches);
                        const awayStats = analyzeTeamStats(teams[1].trim(), false, tipOutput, allMatches);

                        homeCount = homeStats.count || 0;
                        homeTotal = homeStats.total || 0;
                        awayCount = awayStats.count || 0;
                        awayTotal = awayStats.total || 0;

                        if (homeTotal > 0) homeWinrate = Math.round((homeCount / homeTotal) * 100);
                        if (awayTotal > 0) awayWinrate = Math.round((awayCount / awayTotal) * 100);
                    }

                    // REBALANCED FORMULA (to avoid 99 saturation):
                    // Base Probability: 55-88 range (was 65-95)
                    // Team Winrate: 4/7/10 (was 5/10/15)
                    // Value Bet: 5 (was 10)
                    // HT Boost: +3 (Decisive for Gold)

                    const avgTeamWinrate = (homeWinrate + awayWinrate) / 2;
                    // Lowered base from 60 to 55, cap from 95 to 88
                    const probBoost = Math.max(60, Math.min(88, 55 + (r.calculatedProb * 0.4)));

                    // Reduced team boosts
                    const teamBoost = avgTeamWinrate >= 70 ? 10 : avgTeamWinrate >= 50 ? 7 : 4;
                    const valueBetBoost = r.isValueBet ? 5 : 0;

                    let htBoost = 0;
                    if (r.info_ht) {
                        const match = r.info_ht.match(/@([\d\.]+)/);
                        if (match) {
                            const htQuota = parseFloat(match[1]);
                            if (htQuota <= 1.45) htBoost = 3;
                        }
                    }

                    // PROFESSIONAL FORMULA (Reality Check):
                    // Base (Prob+Winrate)/2 + 15 (AI) + Bonuses.
                    // 6/9 match -> ~90. 8/9 match -> ~99.
                    const realBase = (r.calculatedProb + avgTeamWinrate) / 2;
                    const boostedScore = Math.min(99, Math.round(realBase + 15 + (r.isValueBet ? 4 : 0) + htBoost));

                    return {
                        // Basic match info
                        data: r.data,
                        ora: r.ora || r.time || '', // FALLBACK: try 'ora', then 'time', then empty
                        info_ht: r.info_ht || '', // NEW: Pass HT info for display
                        partita: r.partita,
                        lega: r.lega,
                        tip: tipOutput,
                        quota: r.calculatedQuota,
                        probabilita: r.calculatedProb,
                        fixtureId: r.fixtureId || null,

                        // BOOSTED Score (now 70-95 range typically)
                        score: boostedScore,

                        // Team stats for display
                        teamStats: {
                            home: {
                                text: `üè† ${homeCount}/${homeTotal} Over 2.5 (${homeWinrate}%)`,
                                count: homeCount,
                                total: homeTotal,
                                percentage: homeWinrate,
                                color: homeWinrate >= 70 ? 'green' : homeWinrate >= 50 ? 'yellow' : 'red'
                            },
                            away: {
                                text: `‚úàÔ∏è ${awayCount}/${awayTotal} Over 2.5 (${awayWinrate}%)`,
                                count: awayCount,
                                total: awayTotal,
                                percentage: awayWinrate,
                                color: awayWinrate >= 70 ? 'green' : awayWinrate >= 50 ? 'yellow' : 'red'
                            }
                        },

                        aiConfidence: r.calculatedProb >= 70 ? 'üîÆ Alta Fiducia AI' :
                            r.calculatedProb >= 55 ? 'üìä Buona Probabilit√†' : '‚ö° Da Valutare',

                        isValueBet: r.isValueBet,
                        valueBetText: r.isValueBet ? 'üíé QUOTA VANTAGGIOSA' : null,

                        _originalTip: r.tip,
                        _originalQuota: r.quota,
                        _lambdaHome: r.lambdaHome,
                        _lambdaAway: r.lambdaAway
                    };
                });

                // Sort by score descending
                matches.sort((a, b) => b.score - a.score);

                // Prepare strategy object
                const strategyData = {
                    name: strategyName,
                    totalMatches: matches.length,
                    matches: matches,
                    lastUpdated: Date.now(),
                    type: 'ai_statistical',
                    description: `Selezione intelligente basata su analisi avanzata di oltre 15.000 partite storiche. Le picks sono ordinate per affidabilit√† AI.`
                };

                try {
                    // Save to daily_strategies/{date} - inside 'strategies' object to match standard format
                    const stratDocRef = doc(db, 'daily_strategies', targetDate);

                    // Get existing strategies for this date
                    const existingDoc = await getDoc(stratDocRef);
                    let docData = existingDoc.exists() ? existingDoc.data() : { strategies: {}, date: targetDate };

                    // Ensure strategies object exists
                    if (!docData.strategies) {
                        docData.strategies = {};
                    }

                    // Add/update this AI strategy inside the strategies object
                    docData.strategies[strategyId] = strategyData;
                    docData.lastUpdated = Date.now();

                    await setDoc(stratDocRef, docData);

                    console.log('[AI Strategy] ‚úÖ Saved:', strategyId, 'for date:', targetDate);
                    alert(`‚úÖ Strategia "${strategyName}" salvata!\n\n${matches.length} partite per il ${targetDate}\n\nVai su Pronostici ‚Üí Carica per vedere le strategie aggiornate!`);

                } catch (error) {
                    console.error('[AI Strategy] Save error:', error);
                    alert('‚ùå Errore nel salvataggio: ' + error.message);
                }
            }

            // Factorial function (memoized for performance)
            const factorialCache = { 0: 1, 1: 1 };
            function factorial(n) {
                if (n < 0) return 1;
                if (factorialCache[n]) return factorialCache[n];
                let result = 1;
                for (let i = 2; i <= n; i++) {
                    result *= i;
                    factorialCache[i] = result;
                }
                return result;
            }

            // Poisson probability: P(X = k) = (Œª^k √ó e^(-Œª)) / k!
            function poissonProbability(lambda, k) {
                if (lambda <= 0 || k < 0) return 0;
                return (Math.pow(lambda, k) * Math.exp(-lambda)) / factorial(k);
            }

            // Calculate cumulative probability for Over/Under
            function calculateOverUnderProbability(lambdaHome, lambdaAway, threshold, isOver = true) {
                // Calculate probability of exactly k total goals
                let underProb = 0;
                const maxGoals = Math.ceil(threshold);

                // Sum probabilities of all scores that total <= threshold
                for (let homeGoals = 0; homeGoals <= maxGoals + 3; homeGoals++) {
                    for (let awayGoals = 0; awayGoals <= maxGoals + 3; awayGoals++) {
                        const totalGoals = homeGoals + awayGoals;
                        if (totalGoals <= threshold) {
                            const probHome = poissonProbability(lambdaHome, homeGoals);
                            const probAway = poissonProbability(lambdaAway, awayGoals);
                            underProb += probHome * probAway;
                        }
                    }
                }

                return isOver ? (1 - underProb) : underProb;
            }

            // parseResult and parseTeams moved to js/utils.js

            // Calculate average goals for a team
            function calculateTeamGoalStats(teamName, allMatches, lastN = 9) {
                const teamMatches = [];

                allMatches.forEach(m => {
                    const teams = parseTeams(m.partita);
                    const result = parseResult(m.risultato);
                    if (!teams || !result) return;

                    if (teams.home.toLowerCase().includes(teamName.toLowerCase())) {
                        teamMatches.push({ scored: result.home, conceded: result.away, isHome: true, date: m.data });
                    } else if (teams.away.toLowerCase().includes(teamName.toLowerCase())) {
                        teamMatches.push({ scored: result.away, conceded: result.home, isHome: false, date: m.data });
                    }
                });

                // Sort by date descending and take last N
                teamMatches.sort((a, b) => new Date(b.date) - new Date(a.date));
                const recent = teamMatches.slice(0, lastN);

                if (recent.length < 3) return null; // Not enough data

                const avgScored = recent.reduce((sum, m) => sum + m.scored, 0) / recent.length;
                const avgConceded = recent.reduce((sum, m) => sum + m.conceded, 0) / recent.length;
                const totalGoals = recent.reduce((sum, m) => sum + m.scored + m.conceded, 0) / recent.length;

                return {
                    avgScored,
                    avgConceded,
                    avgTotal: totalGoals,
                    matchCount: recent.length
                };
            }

            // Calculate league average goals
            function calculateLeagueAverage(leagueName, allMatches) {
                const leagueMatches = allMatches.filter(m =>
                    m.lega && m.lega.toLowerCase().includes(leagueName.toLowerCase()) && m.risultato
                );

                if (leagueMatches.length < 10) return 2.5; // Default if not enough data

                let totalGoals = 0;
                let count = 0;

                leagueMatches.forEach(m => {
                    const result = parseResult(m.risultato);
                    if (result) {
                        totalGoals += result.home + result.away;
                        count++;
                    }
                });

                return count > 0 ? totalGoals / count : 2.5;
            }

            // probabilityToOdds and parseQuota moved to js/utils.js

            // Main calculation function
            async function executeStatisticalCalculation() {
                console.log('[Statistical Engine] üöÄ executeStatisticalCalculation called!');

                const tipInput = document.getElementById('stat-tip-input').value;
                const tipOutput = document.getElementById('stat-tip-output').value;
                const probMin = parseInt(document.getElementById('stat-prob-min').value) || 0;
                const quotaMax = parseFloat(document.getElementById('stat-quota-max').value) || 10;
                const targetDate = document.getElementById('stat-target-date').value;
                const calcQuota = document.getElementById('stat-calc-quota').checked;
                const calcProb = document.getElementById('stat-calc-prob').checked;
                const method = document.querySelector('input[name="stat-method"]:checked')?.value || 'poisson';

                console.log('[Statistical Engine] Config:', { tipInput, tipOutput, probMin, quotaMax, targetDate, method });

                if (!targetDate) {
                    alert('Seleziona una data');
                    return;
                }

                // Show results section
                const resultsSection = document.getElementById('stat-results-section');
                const matchesList = document.getElementById('stat-matches-list');
                resultsSection.classList.remove('hidden');
                matchesList.innerHTML = '<div class="text-center py-4"><i class="fa-solid fa-spinner fa-spin text-2xl text-indigo-600"></i><p class="text-gray-500 mt-2">Caricamento dati...</p></div>';

                try {
                    console.log('[Statistical Engine] Using local matches cache...');
                    // Use the global allMatches array that's already loaded from LocalDB
                    // This is populated by loadAllMatches() on app initialization
                    const localMatches = window.allMatches || allMatches || [];
                    console.log('[Statistical Engine] Found', localMatches.length, 'matches in local cache');

                    // Filter matches for target date
                    const matchesForDate = localMatches.filter(m => {
                        const matchDate = m.data;
                        return matchDate === targetDate;
                    });
                    console.log('[Statistical Engine] Matches for date', targetDate, ':', matchesForDate.length);

                    // Filter by tip and probability
                    const normalized = tipInput.replace('Over ', '+').replace('Under ', '-');
                    const filteredMatches = matchesForDate.filter(m => {
                        const matchTip = (m.tip || '').toLowerCase().trim();
                        const matchProb = parseInt(m.probabilita) || 0;
                        const matchQuota = parseQuota(m.quota) || 0;

                        const tipMatch = matchTip === normalized.toLowerCase() ||
                            matchTip === tipInput.toLowerCase() ||
                            (tipInput === '+1.5' && matchTip.includes('1.5') && matchTip.includes('+'));

                        return tipMatch && matchProb >= probMin && matchQuota <= quotaMax;
                    });

                    // Calculate statistics for each match
                    const results = [];

                    for (const match of filteredMatches) {
                        const teams = parseTeams(match.partita);
                        if (!teams) continue;

                        // Get goal averages for both teams
                        const homeStats = calculateTeamGoalStats(teams.home, localMatches);
                        const awayStats = calculateTeamGoalStats(teams.away, localMatches);

                        // Calculate lambda (expected goals)
                        const leagueAvg = calculateLeagueAverage(match.lega, localMatches);

                        let lambdaHome = 1.3; // Default
                        let lambdaAway = 1.0; // Default

                        if (homeStats && awayStats) {
                            lambdaHome = (homeStats.avgScored + awayStats.avgConceded) / 2;
                            lambdaAway = (awayStats.avgScored + homeStats.avgConceded) / 2;
                        }

                        // Calculate output probability based on method
                        let outputProb = 0;
                        let outputQuota = 0;

                        if (method === 'poisson') {
                            const threshold = parseFloat(tipOutput.replace('+', '').replace('-', ''));
                            const isOver = tipOutput.startsWith('+');
                            outputProb = calculateOverUnderProbability(lambdaHome, lambdaAway, threshold, isOver);
                            outputQuota = probabilityToOdds(outputProb);
                        } else {
                            // For other methods, use original probability as base
                            outputProb = (parseInt(match.probabilita) || 50) / 100;
                            outputQuota = parseQuota(match.quota) || 1.5;
                        }

                        // Check if it's a value bet
                        const originalQuota = parseQuota(match.quota) || 1.5;
                        const isValueBet = outputQuota < originalQuota;

                        results.push({
                            ...match,
                            calculatedProb: Math.round(outputProb * 100),
                            calculatedQuota: outputQuota.toFixed(2),
                            outputTip: tipOutput === 'stesso' ? match.tip : tipOutput,
                            lambdaHome: lambdaHome.toFixed(2),
                            lambdaAway: lambdaAway.toFixed(2),
                            isValueBet,
                            homeStats,
                            awayStats
                        });
                    }

                    // Update summary stats
                    document.getElementById('stat-matches-found').textContent = results.length;

                    if (results.length > 0) {
                        const avgProb = results.reduce((sum, r) => sum + r.calculatedProb, 0) / results.length;
                        const avgQuota = results.reduce((sum, r) => sum + parseFloat(r.calculatedQuota), 0) / results.length;
                        const valueBets = results.filter(r => r.isValueBet).length;

                        document.getElementById('stat-avg-prob').textContent = avgProb.toFixed(0) + '%';
                        document.getElementById('stat-avg-quota').textContent = avgQuota.toFixed(2);
                        document.getElementById('stat-value-bets').textContent = valueBets;
                    }

                    // Render results
                    if (results.length === 0) {
                        matchesList.innerHTML = '<div class="text-center py-8 text-gray-400">Nessuna partita trovata con i criteri selezionati</div>';
                    } else {
                        matchesList.innerHTML = results.map((r, idx) => `
                            <div class="p-4 rounded-xl border ${r.isValueBet ? 'border-green-300 bg-green-50' : 'border-gray-200 bg-white'} shadow-sm">
                                <div class="flex justify-between items-start">
                                    <div>
                                        <div class="font-bold text-gray-800">${r.partita}</div>
                                        <div class="text-sm text-gray-500">${r.lega} ‚Ä¢ ${r.ora || ''}</div>
                                    </div>
                                    <div class="text-right">
                                        <div class="font-bold ${r.isValueBet ? 'text-green-600' : 'text-indigo-600'}">${r.outputTip} @${r.calculatedQuota}</div>
                                        <div class="text-sm text-gray-500">Prob: ${r.calculatedProb}%</div>
                                    </div>
                                </div>
                                <div class="mt-2 flex gap-2 text-xs">
                                    <span class="bg-indigo-100 text-indigo-700 px-2 py-1 rounded">Œª Casa: ${r.lambdaHome}</span>
                                    <span class="bg-purple-100 text-purple-700 px-2 py-1 rounded">Œª Trasf: ${r.lambdaAway}</span>
                                    <span class="bg-gray-100 text-gray-700 px-2 py-1 rounded">DB: ${r.tip} @${r.quota}</span>
                                    ${r.isValueBet ? '<span class="bg-green-500 text-white px-2 py-1 rounded">üí∞ VALUE</span>' : ''}
                                </div>
                            </div>
                        `).join('');
                    }

                    // Store results globally for saving
                    currentStatResults = results;
                    console.log('[Statistical Engine] Results stored for saving:', results.length, 'matches');

                } catch (error) {
                    console.error('[Statistical Calculation Error]', error);
                    matchesList.innerHTML = `<div class="text-center py-8 text-red-500">Errore: ${error.message}</div>`;
                }
            }

            // Setup statistical engine event listeners
            function setupStatisticalEngine() {
                console.log('[Statistical Engine] Setting up...');

                // Event listener for execute button
                const executeBtn = document.getElementById('stat-execute-btn');
                if (executeBtn) {
                    executeBtn.addEventListener('click', executeStatisticalCalculation);
                    console.log('[Statistical Engine] Execute button listener attached');
                }

                // Event listener for save strategy button
                const saveBtn = document.getElementById('stat-save-strategy-btn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', saveStatisticalStrategy);
                    console.log('[Statistical Engine] Save button listener attached');
                }

                // Set default date to today
                const statToday = new Date().toISOString().split('T')[0];
                const dateInput = document.getElementById('stat-target-date');
                if (dateInput) {
                    dateInput.value = statToday;
                    console.log('[Statistical Engine] Date set to', statToday);
                }

                // Method description updates
                const methodDescriptions = {
                    poisson: '<strong>Poisson:</strong> Usa la distribuzione di Poisson per calcolare la probabilit√† esatta di qualsiasi risultato basandosi sulla media gol delle squadre.',
                    elo: '<strong>ELO Rating:</strong> Sistema di rating dinamico che calcola la forza relativa delle squadre basandosi sui risultati storici. (In sviluppo)',
                    trend: '<strong>Trend Analysis:</strong> Analizza la forma recente delle squadre (ultime 9 partite) per identificare tendenze. (In sviluppo)',
                    value: '<strong>Value Betting:</strong> Identifica quote con valore positivo confrontando la probabilit√† reale con quella implicita nella quota. (In sviluppo)'
                };

                document.querySelectorAll('input[name="stat-method"]').forEach(radio => {
                    radio.addEventListener('change', () => {
                        document.getElementById('method-description').innerHTML = methodDescriptions[radio.value] || '';
                        // Update visual selection
                        document.querySelectorAll('#stat-methods-list label').forEach(label => {
                            label.classList.remove('border-2', 'border-indigo-500', 'bg-indigo-50');
                            label.classList.add('border', 'border-gray-200');
                        });
                        radio.closest('label').classList.remove('border', 'border-gray-200');
                        radio.closest('label').classList.add('border-2', 'border-indigo-500', 'bg-indigo-50');
                    });
                });

                console.log('[Statistical Engine] ‚úÖ Setup complete');
            }

            // Call setup when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setupStatisticalEngine);
            } else {
                // DOM already loaded, run immediately but with slight delay to ensure elements are ready
                setTimeout(setupStatisticalEngine, 100);
            }

            // ==================== END STATISTICAL ENGINE ====================


            // Avvia flusso auth
            // authenticate(); // OLD - Now using onAuthStateChanged with email/password login

            // UI Elements
            const pages = document.querySelectorAll('.page');
            const navButtons = document.querySelectorAll('.nav-button');
            const filterDateStart = document.getElementById('filter-date-start');
            const filterDateEnd = document.getElementById('filter-date-end');
            const leagueFiltersGrid = document.getElementById('league-filters-grid');
            const tipFiltersContainer = document.getElementById('tip-filters-container');
            const probabilitySliderEl = document.getElementById('probability-slider');
            const oddsSliderEl = document.getElementById('odds-slider');
            const probMinInput = document.getElementById('prob-min-input');
            const probMaxInput = document.getElementById('prob-max-input');
            const oddsMinInput = document.getElementById('odds-min-input');
            const oddsMaxInput = document.getElementById('odds-max-input');
            const searchInput = document.getElementById('search-input');
            const sortableHeaders = document.querySelectorAll('.sortable-header');

            // --- TEST STRATEGIES UI ELEMENTS ---
            const testProbSliderEl = document.getElementById('test-prob-slider');
            const testOddsSliderEl = document.getElementById('test-odds-slider');
            const testProbMinVal = document.getElementById('test-prob-min-val');
            const testProbMaxVal = document.getElementById('test-prob-max-val');
            const testOddsMinVal = document.getElementById('test-odds-min-val');
            const testOddsMaxVal = document.getElementById('test-odds-max-val');
            const testStrategiesList = document.getElementById('test-strategies-list');
            const testTipContainer = document.getElementById('test-tip-container');
            const testLeaguesContainer = document.getElementById('test-leagues-container');
            const testResultsBody = document.getElementById('test-results-body');
            const testRunBtn = document.getElementById('test-run-btn');
            const testSaveBtn = document.getElementById('test-save-btn');
            const testPublishBtn = document.getElementById('test-publish-btn');

            let currentTestStrategyId = null; // ID della strategia correntemente caricata nel lab
            let currentTestState = { tips: [], leagues: [], prob: [0, 100], odds: [1.0, 10.0] };

            // Sliders Dashboard
            if (probabilitySliderEl) {
                noUiSlider.create(probabilitySliderEl, {
                    start: [0, 100],
                    connect: true,
                    range: { min: 0, max: 100 },
                    step: 1,
                    tooltips: false
                });
            }

            if (oddsSliderEl) {
                noUiSlider.create(oddsSliderEl, {
                    start: [1.0, 10.0],
                    connect: true,
                    range: { min: 1.0, max: 10.0 },
                    step: 0.01,
                    tooltips: false
                });
            }

            // Sliders Laboratorio Test
            if (testProbSliderEl) {
                noUiSlider.create(testProbSliderEl, {
                    start: [0, 100],
                    connect: true,
                    range: { min: 0, max: 100 },
                    step: 1
                });
            }

            if (testOddsSliderEl) {
                noUiSlider.create(testOddsSliderEl, {
                    start: [1.0, 10.0],
                    connect: true,
                    range: { min: 1.0, max: 10.0 },
                    step: 0.01
                });
            }

            if (testProbSliderEl && testProbSliderEl.noUiSlider) {
                testProbSliderEl.noUiSlider.on('update', (v) => {
                    testProbMinVal.textContent = parseInt(v[0]) + '%';
                    testProbMaxVal.textContent = parseInt(v[1]) + '%';

                    // In Lab mode, update temporary state
                    if (currentTestState) {
                        currentTestState.prob = [parseInt(v[0]), parseInt(v[1])];
                    }
                });
            }

            if (testOddsSliderEl && testOddsSliderEl.noUiSlider) {
                testOddsSliderEl.noUiSlider.on('update', (v) => {
                    testOddsMinVal.textContent = parseFloat(v[0]).toFixed(2);
                    testOddsMaxVal.textContent = parseFloat(v[1]).toFixed(2);

                    // In Lab mode, update temporary state
                    if (currentTestState) {
                        currentTestState.odds = [parseFloat(v[0]), parseFloat(v[1])];
                    }
                });
            }

            // Sincronizzazione SLIDER ‚Üí INPUT (Probabilit√†)
            probabilitySliderEl.noUiSlider.on('update', (values) => {
                probMinInput.value = parseInt(values[0]);
                probMaxInput.value = parseInt(values[1]);
            });

            probabilitySliderEl.noUiSlider.on('set', () => {
                applyFiltersAndRender();
            });

            // Sincronizzazione INPUT ‚Üí SLIDER (Probabilit√†)
            probMinInput.addEventListener('change', () => {
                const min = parseInt(probMinInput.value) || 0;
                const max = parseInt(probMaxInput.value) || 100;
                if (min <= max) {
                    probabilitySliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            probMaxInput.addEventListener('change', () => {
                const min = parseInt(probMinInput.value) || 0;
                const max = parseInt(probMaxInput.value) || 100;
                if (min <= max) {
                    probabilitySliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            // Sincronizzazione SLIDER ‚Üí INPUT (Quota)
            oddsSliderEl.noUiSlider.on('update', (values) => {
                oddsMinInput.value = parseFloat(values[0]).toFixed(2);
                oddsMaxInput.value = parseFloat(values[1]).toFixed(2);
            });

            oddsSliderEl.noUiSlider.on('set', () => {
                applyFiltersAndRender();
            });

            // Sincronizzazione INPUT ‚Üí SLIDER (Quota)
            oddsMinInput.addEventListener('change', () => {
                const min = parseFloat(oddsMinInput.value) || 1.0;
                const max = parseFloat(oddsMaxInput.value) || 10.0;
                if (min <= max) {
                    oddsSliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            oddsMaxInput.addEventListener('change', () => {
                const min = parseFloat(oddsMinInput.value) || 1.0;
                const max = parseFloat(oddsMaxInput.value) || 10.0;
                if (min <= max) {
                    oddsSliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            // Buttons
            const resetFiltersBtn = document.getElementById('reset-filters-btn');
            const resetLeaguesBtn = document.getElementById('reset-leagues-btn');
            const resetTipsBtn = document.getElementById('reset-tips-btn');
            const exportFilteredBtn = document.getElementById('export-filtered-btn');
            const saveFilterBtn = document.getElementById('save-filter-btn'); // Publish
            const saveLocalBtn = document.getElementById('save-local-btn');   // Save Test
            const loadFilterBtn = document.getElementById('load-filter-btn');
            const deleteFilterBtn = document.getElementById('delete-filter-btn');
            const updateFavoritesBtn = document.getElementById('update-favorites-btn');

            if (saveFilterBtn) saveFilterBtn.addEventListener('click', handlePublishStrategy);
            if (saveLocalBtn) saveLocalBtn.addEventListener('click', handleSaveFilter);
            if (loadFilterBtn) loadFilterBtn.addEventListener('click', handleLoadFilter);
            if (deleteFilterBtn) deleteFilterBtn.addEventListener('click', handleDeleteFilter);

            // Dates - Dashboard VUOTA all'inizio
            filterDateStart.value = '';
            filterDateEnd.value = '';

            // Altre pagine mantengono data odierna
            const today = new Date();
            document.getElementById('tips-date').value = today.toISOString().split('T')[0];
            document.getElementById('results-date').value = today.toISOString().split('T')[0];
            document.getElementById('ranking-date').value = today.toISOString().split('T')[0];

            // ==================== NAVIGATION ====================
            function showPage(pageId) {
                pages.forEach(p => p.classList.remove('active'));
                document.getElementById(pageId).classList.add('active');

                navButtons.forEach(btn => {
                    if (btn.dataset.page === pageId) {
                        btn.classList.remove('bg-gray-200', 'text-gray-700');
                        btn.classList.add('bg-blue-600', 'text-white');
                    } else {
                        btn.classList.remove('bg-blue-600', 'text-white');
                        btn.classList.add('bg-gray-200', 'text-gray-700');
                    }
                });

                if (pageId === 'page-oggi') updateTipsDaysList();
                if (pageId === 'page-risultati') updateResultsDaysList();
                if (pageId === 'page-test') loadAIStrategies(); // Load AI strategies when opening page
            }

            navButtons.forEach(btn => btn.addEventListener('click', (e) => showPage(e.currentTarget.dataset.page)));

            // ==================== LOAD DATA ====================
            // ==================== LOAD DATA ====================
            async function loadAllMatches() {
                // MODALIT√Ä LOCALE: Carica da IndexedDB (persistente)
                if (window.USE_LOCAL_DB_ONLY) {
                    try {
                        console.log("[Local Mode] Loading persisted matches from IndexedDB...");
                        // Use global databaseManager wrapper if available, or direct js/database.js object
                        const matches = await window.LocalDB.loadMatches();

                        if (matches && matches.length > 0) {
                            allMatches = matches;
                            window.allMatches = allMatches; // Sync global
                            document.getElementById('matches-count').textContent = `Locale (${matches.length})`;
                            updateStatsDisplay(matches);

                            // Visual feedback
                            const previewEl = document.getElementById('backup-upload-preview');
                            if (previewEl) {
                                previewEl.innerHTML = `
                                    <div class="bg-blue-50 p-3 rounded text-center text-sm">
                                        <i class="fa-solid fa-database text-blue-600"></i>
                                        Database Locale caricato: ${matches.length} partite.
                                    </div>
                                `;
                            }
                        } else {
                            console.log("[Local Mode] No persisted matches found in IndexedDB (Version Reset?). Waiting for CSV.");
                            document.getElementById('matches-count').textContent = `Locale (0)`;
                        }
                    } catch (e) {
                        console.error("[Local Mode] Failed to load from IndexedDB:", e);
                    }
                    return;
                }

                // MODALIT√Ä ONLINE (Vecchio codice)
                try {
                    const matchesCol = collection(db, "matches");
                    const snapshot = await getDocs(matchesCol);
                    allMatches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    allMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                    window.allMatches = allMatches; // Sync global
                } catch (e) {
                    console.error('Error loading matches:', e);
                    allMatches = [];
                    window.allMatches = []; // Sync global
                }

                // üî• POINT 4: INITIALIZE ELO RATINGS
                if (allMatches.length > 0 && window.engine && window.engine.calculateELORatings) {
                    window.teamELORatings = window.engine.calculateELORatings(allMatches);
                }
            }

            // ==================== UPDATE GLOBAL STATS ====================
            // Calculate and save global stats to /system/global_stats for client access
            async function updateGlobalStats() {
                try {
                    console.log('[Admin] Calculating global stats...');

                    // Calculate from allMatches (already loaded)
                    const matchesWithResults = allMatches.filter(m => m.risultato && m.risultato !== '');

                    let total = matchesWithResults.length;
                    let wins = matchesWithResults.filter(m => m.esito === 'Vinto').length;
                    let losses = matchesWithResults.filter(m => m.esito === 'Perso').length;
                    let winrate = total > 0 ? ((wins / total) * 100).toFixed(1) : 0;

                    // Find most recent published strategy date (honest update tracking)
                    let lastUpdate = '';
                    try {
                        const strategiesSnapshot = await getDocs(collection(db, "daily_strategies"));
                        strategiesSnapshot.forEach(doc => {
                            const date = doc.id; // Document ID is the date (YYYY-MM-DD)
                            if (date > lastUpdate) lastUpdate = date;
                        });
                    } catch (e) {
                        console.warn('[Admin] Could not read daily_strategies for lastUpdate, using fallback');
                    }

                    // Fallback to today if no strategies published yet
                    if (!lastUpdate) {
                        const today = new Date();
                        const year = today.getFullYear();
                        const month = String(today.getMonth() + 1).padStart(2, '0');
                        const day = String(today.getDate()).padStart(2, '0');
                        lastUpdate = `${year}-${month}-${day}`;
                    }

                    // Save to Firestore
                    const statsData = {
                        total,
                        wins,
                        losses,
                        winrate: parseFloat(winrate),
                        lastUpdate,
                        updatedAt: new Date().toISOString()
                    };

                    await setDoc(doc(db, "system", "global_stats"), statsData);
                    console.log('[Admin] ‚úÖ Global stats updated:', statsData);

                } catch (e) {
                    console.error('[Admin] Error updating global stats:', e);
                }
            }



            // ==================== RENAME STRATEGY ====================
            /**
             * Rename a strategy's display name while preserving its ID and history
             * @param {string} strategyId - Immutable strategy ID (e.g., '___magia_ai', 'italia')
             * @param {string} newName - New display name for the strategy
             */
            async function renameStrategy(strategyId, newName) {
                try {
                    console.log(`[Rename] Updating strategy ${strategyId} to: ${newName}`);

                    if (!strategyId || !newName || newName.trim() === '') {
                        alert('‚ö†Ô∏è Nome non pu√≤ essere vuoto');
                        return false;
                    }

                    newName = newName.trim();

                    // 1. Update Local Storage (Admin saved filters)
                    const localStrategiesRaw = localStorage.getItem('saved_strategy_filters');
                    const localStrategies = localStrategiesRaw ? JSON.parse(localStrategiesRaw) : null;
                    let localUpdated = false;
                    if (localStrategies && localStrategies[strategyId]) {
                        localStrategies[strategyId].name = newName;
                        localStorage.setItem('saved_strategy_filters', JSON.stringify(localStrategies));
                        console.log('[Rename] ‚úÖ Local storage updated');
                        localUpdated = true;
                    }

                    // 2. Update Firebase (Public client strategies)
                    const firebaseRef = doc(db, "system", "client_strategies");
                    let firebaseUpdated = false;
                    try {
                        const firebaseDoc = await getDoc(firebaseRef);

                        if (firebaseDoc.exists()) {
                            const strategies = firebaseDoc.data().strategies || {};
                            if (strategies[strategyId]) {
                                strategies[strategyId].name = newName;
                                await setDoc(firebaseRef, { strategies }, { merge: true });
                                console.log('[Rename] ‚úÖ Firebase updated');
                                firebaseUpdated = true;
                            }
                        }
                    } catch (fbErr) {
                        console.error('[Rename] Firebase update failed:', fbErr);
                        // Continue even if Firebase fails - local update still valid
                    }

                    // 3. Note: Historical data (daily_strategies) uses strategyId as KEY
                    //    so no update needed there - references remain valid!

                    if (!localUpdated && !firebaseUpdated) {
                        alert(`‚ö†Ô∏è Strategia "${strategyId}" non trovata.\n\nPotrebbe essere una strategia preset o non ancora salvata.`);
                        return false;
                    }

                    alert(`‚úÖ Strategia rinominata: "${newName}"\n\n` +
                        `ID: ${strategyId}\n` +
                        `Storico: Preservato ‚úÖ\n` +
                        (localUpdated ? 'Local: ‚úÖ\n' : '') +
                        (firebaseUpdated ? 'Firebase: ‚úÖ' : ''));

                    return true;

                } catch (e) {
                    console.error('[Rename] Error:', e);
                    alert('‚ùå Errore durante rename: ' + e.message);
                    return false;
                }
            }

            // Expose to window for easy testing
            window.renameStrategy = renameStrategy;


            // ==================== FILTERS ====================
            function setupFilters() {
                searchInput.addEventListener('input', applyFiltersAndRender);
                filterDateStart.addEventListener('change', applyFiltersAndRender);
                filterDateEnd.addEventListener('change', applyFiltersAndRender);

                // üî• Filtro Magia (AI / Betmines)
                const magiaFilterSelect = document.getElementById('magia-filter');
                if (magiaFilterSelect) {
                    magiaFilterSelect.addEventListener('change', applyFiltersAndRender);
                }

                document.getElementById('show-no-result-btn').addEventListener('click', function () {
                    showOnlyNoResult = !showOnlyNoResult;
                    if (showOnlyNoResult) {
                        this.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                        this.classList.add('bg-green-600', 'hover:bg-green-700');
                        this.innerHTML = '<i class="fa-solid fa-check mr-1"></i> Senza Risultato';
                    } else {
                        this.classList.remove('bg-green-600', 'hover:bg-green-700');
                        this.classList.add('bg-orange-500', 'hover:bg-orange-600');
                        this.innerHTML = '<i class="fa-solid fa-filter mr-1"></i> Senza Risultato';
                    }
                    applyFiltersAndRender();
                });
            }

            function categorizeLeague(leagueName) {
                try {
                    if (!leagueName) return 'Non Classificati';
                    const ln = String(leagueName).toLowerCase().trim();

                    // 1. Preferiti (Safe check)
                    if (typeof favoriteLeagues !== 'undefined' && Array.isArray(favoriteLeagues)) {
                        if (favoriteLeagues.some(f => String(f || "").toLowerCase().trim() === ln)) return '‚≠ê Preferiti';
                    }

                    // 2. Coppe Europee (Specific to EU- prefix)
                    if (ln.startsWith('eu-') && (ln.includes('champions league') || ln.includes('europa league') || ln.includes('conference league'))) return 'Coppe Europee';

                    // 3. Africa (Specific to AF- prefix)
                    if (ln.startsWith('af-')) return 'Africa';

                    // 4. Competizioni Nazionali (WCQ, NAZ)
                    if (ln.includes('wcq') || ln.endsWith('-naz')) return 'Competizioni Nazionali';

                    // 5. Coppe Nazionali (Cup, Coppa, etc.)
                    if (/(cup|coppa|copa|beker|ta√ßa)/i.test(ln)) return 'Coppe Nazionali';

                    // 6. Resto del Mondo (AS, NA, SA, OC) - AF moved to "Africa"
                    if (/^(as|na|sa|oc)-/i.test(ln)) return 'Resto del Mondo';

                    // 7. Europa (EU-)
                    if (ln.startsWith('eu-')) return 'Europa';

                    return 'Non Classificati';
                } catch (e) {
                    console.error("[Categorization Error]", e);
                    return 'Non Classificati';
                }
            }

            function populateFilters() {
                // Leagues categorizzate
                // üî• FIX: Usa leagueId per evitare duplicati (es. "eu-cyp 1 division" vs "eu-cyp 1. division")
                const uniqueLeagueIds = [...new Set(allMatches.map(m => m.leagueId).filter(Boolean))];

                // Mappa leagueId -> {id, name, registryEntry} usando il registry per il nome canonico
                const leagueMap = new Map();
                uniqueLeagueIds.forEach(leagueId => {
                    // Cerca nel registry il nome canonico per questo leagueId
                    let registryEntry = null;
                    let leagueName = null;

                    if (window.leaguesRegistry) {
                        // Scan registry to find entry with this leagueId
                        for (const [key, value] of window.leaguesRegistry.entries()) {
                            if (value.leagueId === leagueId) {
                                registryEntry = value;
                                leagueName = value.name || key; // Use canonical name from registry
                                break;
                            }
                        }
                    }

                    // Fallback: se non trovato nel registry, usa il primo nome trovato nei match
                    if (!leagueName) {
                        const matchWithThisId = allMatches.find(m => m.leagueId === leagueId);
                        leagueName = matchWithThisId ? matchWithThisId.lega : `League ${leagueId}`;
                    }

                    leagueMap.set(leagueId, {
                        id: leagueId,
                        name: leagueName,
                        registryEntry: registryEntry
                    });
                });

                // Ora categorizza usando il nome canonico
                const categorized = Array.from(leagueMap.values()).reduce((acc, league) => {
                    const category = categorizeLeague(league.name);
                    if (!acc[category]) acc[category] = [];
                    acc[category].push(league);
                    return acc;
                }, {});

                const categoryOrder = ['‚≠ê Preferiti', 'Europa', 'Africa', 'Resto del Mondo', 'Coppe Europee', 'Competizioni Nazionali', 'Coppe Nazionali', 'Non Classificati'];
                leagueFiltersGrid.innerHTML = '';

                // Change container style to flex column for accordions
                leagueFiltersGrid.className = 'flex flex-col gap-2';

                categoryOrder.forEach(category => {
                    if (!categorized[category] || categorized[category].length === 0) return;

                    const details = document.createElement('details');
                    details.className = 'group bg-gray-50 border rounded-lg overflow-hidden shadow-sm';
                    // Open Favorites by default - DISABLED
                    // if (category === '‚≠ê Preferiti') details.open = true;

                    const leaguesInCategory = categorized[category]
                        .sort((a, b) => a.name.localeCompare(b.name)) // Sort by canonical name
                        .map(league => {
                            const leagueName = league.name;
                            const leagueId = league.id;
                            const registryEntry = league.registryEntry;

                            const trust = (window.LEAGUE_TRUST && window.LEAGUE_TRUST[leagueName]) ? window.LEAGUE_TRUST[leagueName] : null;
                            let badge = '';
                            if (trust) {
                                const color = trust.mode === 'SNIPER' ? 'bg-purple-100 text-purple-700 border-purple-200' :
                                    (trust.mode === 'DEFENDER' ? 'bg-red-100 text-red-700 border-red-200' : 'bg-gray-100 text-gray-700 border-gray-200');
                                const icon = trust.mode === 'SNIPER' ? 'üéØ' : (trust.mode === 'DEFENDER' ? 'üõ°Ô∏è' : 'üìä');
                                badge = `<span class="text-[10px] px-1.5 py-0.5 rounded border ${color} font-bold mr-2" title="Trust: ${trust.trust}/10 | Mode: ${trust.mode}">${icon} ${trust.trust}</span>`;
                            }

                            // Checkbox value = leagueId (numeric ID for filtering)
                            const cbValue = leagueId;

                            return `
                            <div class="flex items-center justify-between p-2 hover:bg-blue-50 border-b border-gray-100 last:border-0 transition-colors">
                                <label class="flex items-center space-x-3 cursor-pointer flex-grow">
                                    <input type="checkbox" value="${cbValue}" data-name="${leagueName}" class="league-checkbox form-checkbox h-4 w-4 rounded text-blue-600 border-gray-300 focus:ring-blue-500">
                                    <span class="text-sm text-gray-700" title="${leagueName}">${badge}${leagueName}</span>
                                </label>
                                <i class="fa-solid fa-star favorite-star ${stagedFavoriteLeagues.includes(leagueName) ? 'is-favorite' : ''} text-gray-300 hover:text-yellow-400 transition-colors cursor-pointer p-1" data-league="${leagueName}"></i>
                            </div>`;
                        }).join('');

                    details.innerHTML = `
                        <summary class="flex items-center justify-between p-3 cursor-pointer bg-white hover:bg-gray-50 transition-colors list-none select-none">
                            <div class="flex items-center space-x-2 font-semibold text-gray-700">
                                <input type="checkbox" class="category-select-all form-checkbox h-4 w-4 rounded text-blue-600 border-gray-300 focus:ring-blue-500" onclick="event.stopPropagation()">
                                <span>${category}</span>
                                <span class="text-xs font-normal text-gray-500 bg-gray-100 px-2 py-0.5 rounded-full">${categorized[category].length}</span>
                            </div>
                            <i class="fa-solid fa-chevron-down text-gray-400 transition-transform duration-200 group-open:rotate-180"></i>
                        </summary>
                        <div class="max-h-96 overflow-y-auto custom-scrollbar bg-white border-t border-gray-100">
                            ${leaguesInCategory}
                        </div>`;

                    leagueFiltersGrid.appendChild(details);
                });

                leagueFiltersGrid.querySelectorAll('.league-checkbox').forEach(cb => {
                    cb.addEventListener('change', applyFiltersAndRender);
                });

                leagueFiltersGrid.querySelectorAll('.category-select-all').forEach(masterCb => {
                    masterCb.addEventListener('change', (e) => {
                        const isChecked = e.target.checked;
                        const details = e.target.closest('details');
                        details.querySelectorAll('.league-checkbox').forEach(leagueCb => {
                            leagueCb.checked = isChecked;
                        });
                        applyFiltersAndRender();
                    });
                });

                leagueFiltersGrid.querySelectorAll('.favorite-star').forEach(star => {
                    star.addEventListener('click', handleFavoriteToggle);
                });

                // Predefined Tips by Market
                const predefinedTips = {
                    '1X2': ['1', 'X', '2'],
                    'Doppia Chance': ['1X', '12', 'X2'],
                    'Under/Over': ['-1.5', '+1.5', '-2.5', '+2.5', '-3.5', '+3.5'],
                    'Gol/No Gol': ['S√¨', 'No']
                };

                tipFiltersContainer.innerHTML = `<div class="grid grid-cols-2 md:grid-cols-4 gap-4">${Object.entries(predefinedTips).map(([market, tips]) => {
                    const tipButtons = tips.map(tip => `
                        <button data-tip="${tip}" class="tip-button w-full px-2 py-1 text-xs rounded-full border border-gray-300 bg-white hover:bg-gray-100 transition-colors">${tip}</button>
                    `).join('');
                    return `
                        <div>
                            <h4 class="font-semibold text-xs uppercase text-gray-500 mb-2">${market}</h4>
                            <div class="flex flex-wrap gap-2">${tipButtons}</div>
                        </div>
                    `;
                }).join('')}</div>`;

                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('active');
                        applyFiltersAndRender();
                    });
                });
            }

            function applyFiltersAndRender(customSort = null) {
                const selectedLeagues = Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value);
                const selectedTips = Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip);
                const [probMin, probMax] = probabilitySliderEl.noUiSlider.get().map(v => parseInt(v));
                const [oddsMin, oddsMax] = oddsSliderEl.noUiSlider.get().map(v => parseFloat(v));
                const searchTerm = searchInput.value.toLowerCase().trim();
                const dateStart = filterDateStart.value ? new Date(filterDateStart.value) : null;
                const dateEnd = filterDateEnd.value ? new Date(filterDateEnd.value) : null;
                const magiaFilter = document.getElementById('magia-filter')?.value || 'all';

                filteredMatches = allMatches.filter(m => {
                    if (showOnlyNoResult) {
                        if (m.risultato && m.risultato.trim() !== '') return false;
                    }

                    // üî• Filtro Magia (AI / Betmines / Consenso)
                    if (magiaFilter === 'AI' && m.magia !== 'AI') return false;
                    if (magiaFilter === 'OK' && m.magia !== 'OK') return false;
                    if (magiaFilter === 'betmines' && (m.magia === 'AI' || m.magia === 'OK')) return false;

                    if (selectedLeagues.length > 0) {
                        const matchIdentifier = m.leagueId ? String(m.leagueId) : m.lega;
                        if (!selectedLeagues.includes(matchIdentifier)) return false;
                    }
                    if (selectedTips.length > 0 && !selectedTips.includes(m.tip)) return false;
                    if (m.probabilita < probMin || m.probabilita > probMax) return false;
                    if (m.quota < oddsMin || m.quota > oddsMax) return false;

                    if (searchTerm) {
                        const matchText = `${m.lega} ${m.partita}`.toLowerCase();
                        if (!matchText.includes(searchTerm)) return false;
                    }

                    if (dateStart || dateEnd) {
                        const matchDate = new Date(m.data || '2000-01-01');
                        if (dateStart && matchDate < dateStart) return false;
                        if (dateEnd && matchDate > dateEnd) return false;
                    }

                    return true;
                });

                console.log(`[applyFiltersAndRender] Filtered matches: ${filteredMatches.length} (from ${allMatches.length})`);
                sortAndRenderMatches(customSort);
                updateStatsDisplay(filteredMatches);
            }

            function updateStatsDisplay(filteredMatches) {
                // SMART STATS: 
                // - If NO filters active: show GLOBAL stats (matching Client App)
                // - If filters active: show stats for filtered matches

                const selectedLeagues = Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value);
                const selectedTips = Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip);
                const searchTerm = searchInput.value.toLowerCase().trim();
                const dateStart = filterDateStart.value;
                const dateEnd = filterDateEnd.value;
                const [probMin, probMax] = probabilitySliderEl.noUiSlider.get().map(v => parseInt(v));
                const [oddsMin, oddsMax] = oddsSliderEl.noUiSlider.get().map(v => parseFloat(v));
                const magiaFilter = document.getElementById('magia-filter')?.value || 'all';

                // Detect if filters are active
                const hasActiveFilters =
                    selectedLeagues.length > 0 ||
                    selectedTips.length > 0 ||
                    searchTerm !== '' ||
                    dateStart || dateEnd ||
                    showOnlyNoResult ||
                    probMin > 0 || probMax < 100 ||
                    oddsMin > 1.0 || oddsMax < 10.0 ||
                    magiaFilter !== 'all'; // üî• Filtro Magia

                let matchesToCount;
                if (hasActiveFilters) {
                    // Use filtered matches
                    matchesToCount = filteredMatches;
                    console.log(`[updateStatsDisplay] Filters active - using ${matchesToCount.length} filtered matches`);
                } else {
                    // Use global matches with result (matching Client App)
                    matchesToCount = (window.allMatches || []).filter(m => m.risultato && m.risultato.trim() !== '');
                    console.log(`[updateStatsDisplay] No filters - using ${matchesToCount.length} global matches with result`);
                }

                const matchesWithResult = matchesToCount.filter(m => m.risultato && m.risultato.trim() !== '');

                // DEBUG: Check what values 'esito' actually has
                if (matchesWithResult.length > 0) {
                    const uniqueOutcomes = [...new Set(matchesWithResult.map(m => m.esito))];
                    console.log("[updateStatsDisplay] Unique 'esito' values found:", uniqueOutcomes);
                }

                // Normalizza check (case insensitive + trim)
                const isWon = (s) => ['vinto', 'vinta'].includes(String(s).trim().toLowerCase());
                const isLost = (s) => ['perso', 'persa', 'perse'].includes(String(s).trim().toLowerCase());

                const won = matchesWithResult.filter(m => isWon(m.esito)).length;
                const lost = matchesWithResult.filter(m => isLost(m.esito)).length;

                const totalStake = matchesWithResult.length;
                const winRate = totalStake > 0 ? (won / totalStake) * 100 : 0;

                const matchesWithOutcome = matchesWithResult.filter(m => isWon(m.esito) || isLost(m.esito));

                const profit = matchesWithOutcome.reduce((acc, m) => {
                    return acc + (isWon(m.esito) ? m.quota - 1 : -1);
                }, 0);
                const roi = matchesWithOutcome.length > 0 ? (profit / matchesWithOutcome.length * 100) : 0;

                const label = hasActiveFilters ? 'Totale (Filtrato)' : 'Totale';
                const statsContainer = document.getElementById('stats-container');
                statsContainer.innerHTML = `
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-blue-600">${totalStake}</div><div class="text-xs text-gray-600">${label}</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-green-600">${won}</div><div class="text-xs text-gray-600">Vinte</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-red-600">${lost}</div><div class="text-xs text-gray-600">Perse</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold ${winRate >= 70 ? 'text-green-600' : 'text-red-600'}">${winRate.toFixed(1)}%</div><div class="text-xs text-gray-600">Winrate</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold ${roi >= 0 ? 'text-green-600' : 'text-red-600'}">${roi.toFixed(1)}%</div><div class="text-xs text-gray-600">ROI</div></div>
                `;
            }

            function sortAndRenderMatches(customSort = null) {
                let sorted;

                // v3.5.3: Custom sort da dropdown
                if (customSort) {
                    const sortSelect = document.getElementById('dashboard-sort-select');
                    const sortValue = customSort || (sortSelect ? sortSelect.value : 'data-desc');

                    sorted = [...filteredMatches].sort((a, b) => {
                        if (sortValue === 'orario-asc') {
                            // Ordina per orario cronologico
                            const timeA = a.time || '99:99';
                            const timeB = b.time || '99:99';
                            return timeA.localeCompare(timeB);
                        } else if (sortValue === 'data-desc') {
                            return new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01');
                        } else if (sortValue === 'lega') {
                            return (a.lega || '').localeCompare(b.lega || '');
                        } else if (sortValue === 'quota') {
                            return (a.quota || 0) - (b.quota || 0);
                        }
                        return 0;
                    });
                } else {
                    // Sort normale da header click
                    const { column, direction } = sortState;
                    sorted = [...filteredMatches].sort((a, b) => {
                        const valA = a[column];
                        const valB = b[column];
                        let comparison = 0;
                        if (typeof valA === 'string') comparison = valA.localeCompare(valB);
                        else comparison = valA - valB;
                        return direction === 'asc' ? comparison : -comparison;
                    });
                }

                renderMatchList(sorted);
                updateSortIcons();
            }

            function renderMatchList(matches) {
                const tbody = document.getElementById('match-list-body');
                document.getElementById('filtered-count').textContent = matches.length;

                const displayMatches = matches.slice(0, 200);
                const now = new Date();

                const tableHeader = `
        <thead class="text-xs text-gray-700 uppercase bg-gray-50 sticky top-0">
            <tr>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('data')">DATA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('lega')">LEGA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100">MAGIA</th>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('partita')">PARTITA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('tip')">TIP <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('risultato')">RIS. <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('probabilita')">PROB. <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('quota')">QUOTA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100 w-48" onclick="updateSort('info_ht')">HT <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th> <!-- Expanded HT -->
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('esito')">ESITO <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <!-- Actions Removed -->
            </tr>
        </thead>
        <tbody class="divide-y divide-gray-100">
    `;

                const matchesToRender = matches || filteredMatches;

                if (matchesToRender.length === 0) {
                    tbody.innerHTML = `
            ${tableHeader}
            <tr><td colspan="10" class="p-8 text-center text-gray-500">Nessuna partita trovata.</td></tr>
            </tbody></table>
        `;
                    return;
                }

                tbody.innerHTML = displayMatches.map(m => {
                    const isEditing = String(m.id) === String(editingMatchId);
                    const esitoClass = m.esito === 'Vinto' ? 'text-green-600 font-bold' : m.esito === 'Perso' ? 'text-red-600 font-bold' : '';

                    // Processo info HT
                    let htDisplay = '<span class="ht-badge-none">-</span>';
                    if (m.info_ht && m.info_ht.trim() !== '') {
                        const probMatch = m.info_ht.match(/(\d+)%/);
                        if (probMatch) {
                            const htProb = parseInt(probMatch[1]);
                            let badgeClass = 'ht-badge-low';
                            if (htProb >= 75) badgeClass = 'ht-badge-high';
                            else if (htProb >= 60) badgeClass = 'ht-badge-medium';
                            htDisplay = `<span class="${badgeClass}">${m.info_ht}</span>`;
                        }
                    }

                    // üî• NEW: Colonna Magia (AI / OK / Betmines)
                    let magiaLabel = '<span class="text-gray-300">-</span>';
                    if (m.magia === 'AI') {
                        magiaLabel = '<span class="px-2 py-0.5 bg-purple-100 text-purple-700 rounded-full text-[9px] font-black border border-purple-200">AI</span>';
                    } else if (m.magia === 'OK') {
                        magiaLabel = '<span class="px-2 py-0.5 bg-green-100 text-green-700 rounded-full text-[9px] font-black border border-green-200">OK</span>';
                    }

                    // üî• DEFENSE: Se il dato AI √® grezzo (non calcolato)
                    const tipDisplay = m.tip || ((m.magia === 'AI' || m.magia === 'OK') ? '<span class="text-[9px] text-gray-400 font-bold uppercase italic">Da Calcolare</span>' : '-');
                    const probDisplay = m.probabilita ? `${m.probabilita}%` : ((m.magia === 'AI' || m.magia === 'OK') ? '<span class="text-[9px] text-gray-400 italic">...</span>' : '-');
                    const quotaDisplay = m.quota || ((m.magia === 'AI' || m.magia === 'OK') ? (m.quota1 ? `<span class="text-[10px] text-gray-400">@${m.quota1}</span>` : '-') : '-');

                    if (isEditing) {
                        return `
                            <tr class="bg-blue-50 border-2 border-blue-400">
                                <td class="p-3 text-xs">${m.data}</td>
                                <td class="p-3 text-xs">
                                    <input type="text" id="edit-lega-${m.id}" value="${m.lega || ''}" class="w-full p-1 border rounded text-[10px]">
                                </td>
                                <td class="p-3 text-xs text-center">${magiaLabel}</td>
                                <td class="p-3 text-xs"><input type="text" id="edit-partita-${m.id}" value="${m.partita}" class="w-full p-1 border rounded"></td>
                                <td class="p-3 text-xs font-semibold">${tipDisplay}</td>
                                <td class="p-3 text-xs">
                                    <div class="space-y-1">
                                        <input type="text" id="edit-risultato-${m.id}" value="${m.risultato || ''}" class="w-full p-1 border rounded text-center" placeholder="FT">
                                        <input type="text" id="edit-risultato-ht-${m.id}" value="${m.risultato_ht || ''}" class="w-full p-1 border rounded text-center text-[10px]" placeholder="HT">
                                    </div>
                                </td>
                                <td class="p-3 text-xs text-center">${probDisplay}</td>
                                <td class="p-3 text-xs text-center font-bold">${quotaDisplay}</td>
                                <td class="p-3 text-xs text-center">${htDisplay}</td>
                                <td class="p-3 text-xs">
                                    <select id="edit-esito-${m.id}" class="w-full p-1 border rounded">
                                        <option value="" ${!m.esito ? 'selected' : ''}>-</option>
                                        <option value="Vinto" ${m.esito === 'Vinto' ? 'selected' : ''}>Vinto</option>
                                        <option value="Perso" ${m.esito === 'Perso' ? 'selected' : ''}>Perso</option>
                                    </select>
                                </td>
                                <td class="p-3 text-xs text-center flex gap-2 justify-center">
                                    <button onclick="saveEdit('${m.id}')" class="text-green-600 hover:text-green-800" title="Salva"><i class="fa-solid fa-check fa-lg"></i></button>
                                    <button onclick="cancelEdit()" class="text-red-600 hover:text-red-800" title="Annulla"><i class="fa-solid fa-times fa-lg"></i></button>
                                </td>
                            </tr>
                        `;
                    }

                    return `
                        <tr class="hover:bg-gray-50 group">
                            <td class="p-3 text-xs">${m.data}</td>
                            <td class="p-3 text-xs">${m.lega}</td>
                            <td class="p-3 text-xs text-center">${magiaLabel}</td>
                            <td class="p-3 text-xs font-medium">${m.partita}</td>
                            <td class="p-3 text-xs font-semibold">${tipDisplay}</td>
                            <td class="p-3 text-xs text-center">
                                <div class="font-bold">${m.risultato || '-'}</div>
                                ${m.risultato_ht ? `<div class="text-[10px] text-gray-400 font-bold block">HT: ${m.risultato_ht}</div>` : ''}
                            </td>
                            <td class="p-3 text-xs text-center">${probDisplay}</td>
                            <td class="p-3 text-xs text-center font-bold">${quotaDisplay}</td>
                            <td class="p-3 text-xs text-center w-48 whitespace-nowrap">${htDisplay}</td> <!-- Expanded HT -->
                            <td class="p-3 text-xs text-center ${esitoClass}">${m.esito || '-'}</td>
                            <td class="p-3 text-xs text-center opacity-0 group-hover:opacity-100 transition-opacity flex gap-2 justify-center">
                                <button onclick="enableEditMode('${m.id}')" class="text-blue-600 hover:text-blue-800" title="Modifica"><i class="fa-solid fa-pencil"></i></button>
                                <button onclick="deleteMatch('${m.id}')" class="text-red-600 hover:text-red-800" title="Elimina"><i class="fa-solid fa-trash"></i></button>
                            </td>
                        </tr>
                    `;
                }).join('');

                if (matches.length > 200) {
                    tbody.innerHTML += `<tr><td colspan="11" class="p-3 text-center text-sm text-gray-500">Mostrati primi 200 di ${matches.length}</td></tr>`;
                }
            }

            // ==================== EDIT & DELETE FUNCTIONS ====================
            window.enableEditMode = (matchId) => {
                const scrollPos = window.scrollY; // Remember scroll position
                editingMatchId = String(matchId); // Support both Number and String IDs
                applyFiltersAndRender(); // Re-render to show inputs
                setTimeout(() => window.scrollTo(0, scrollPos), 50); // Restore scroll
            };

            window.cancelEdit = () => {
                const scrollPos = window.scrollY;
                editingMatchId = null;
                applyFiltersAndRender();
                setTimeout(() => window.scrollTo(0, scrollPos), 50);
            };

            window.saveEdit = async (matchId) => {
                const newLega = document.getElementById(`edit-lega-${matchId}`).value;
                const newPartita = document.getElementById(`edit-partita-${matchId}`).value;
                const newRisultato = document.getElementById(`edit-risultato-${matchId}`).value;
                const newRisultatoHT = document.getElementById(`edit-risultato-ht-${matchId}`).value;
                const newEsito = document.getElementById(`edit-esito-${matchId}`).value;

                try {
                    // Update local data first
                    const mIdStr = String(matchId);
                    const matchIndex = allMatches.findIndex(m => String(m.id) === mIdStr);
                    if (matchIndex !== -1) {
                        allMatches[matchIndex].lega = newLega;
                        allMatches[matchIndex].partita = newPartita;
                        allMatches[matchIndex].risultato = newRisultato;
                        allMatches[matchIndex].risultato_ht = newRisultatoHT;
                        allMatches[matchIndex].esito = newEsito;
                    }

                    // Save based on mode
                    if (window.USE_LOCAL_DB_ONLY) {
                        // Local mode - save to IndexedDB
                        await LocalDB.saveMatches(allMatches);
                    } else {
                        // Firebase mode - update remote
                        const matchRef = doc(db, "matches", mIdStr);
                        await updateDoc(matchRef, {
                            lega: newLega,
                            partita: newPartita,
                            risultato: newRisultato,
                            risultato_ht: newRisultatoHT,
                            esito: newEsito
                        });
                    }

                    editingMatchId = null;
                    applyFiltersAndRender();
                    alert("Partita aggiornata con successo!");
                } catch (error) {
                    console.error("Error updating match:", error);
                    alert("Errore durante l'aggiornamento: " + error.message);
                }
            };

            window.deleteMatch = async (matchId) => {
                if (!confirm("Sei sicuro di voler eliminare questa partita? L'operazione √® irreversibile.")) return;

                try {
                    // 0. Trova la data PRIMA di rimuoverlo dalla memoria per la pulizia snapshot
                    const matchObj = window.allMatches.find(m => String(m.id) === String(matchId));
                    const matchDate = matchObj ? matchObj.data : null;

                    // 1. Remove from local data (Memory)
                    allMatches = allMatches.filter(m => String(m.id) !== String(matchId));
                    window.allMatches = allMatches; // Garantisce aggiornamento globale

                    // üî• ALWAYS delete from LocalDB to prevent "fantom" matches
                    await LocalDB.deleteMatch(matchId);
                    await LocalDB.deleteMagiaMatch(matchId); // üî• NEW: Elimina anche se √® un match AI
                    console.log(`[Delete] Rimosso dai database locali (Oro + Magia).`);

                    // Save/Delete based on mode
                    if (!window.USE_LOCAL_DB_ONLY) {
                        // 1. Delete from collection 'matches'
                        await deleteDoc(doc(db, "matches", matchId));
                        console.log(`[Delete] Rimosso da Firestore: matches/${matchId}`);

                        // 2. Clean up snapshots (ranking_history & daily_strategies)
                        if (matchDate) {
                            // Pulizia Firestore (Snapshots)
                            await cleanFirestoreSnapshots(matchId, matchDate);
                            // Pulizia LocalDB (History)
                            await LocalDB.deleteMatchFromHistory(matchDate, matchId);
                            console.log(`[Delete] Puliti snapshot storici per la data ${matchDate}`);
                        }
                    } else {
                        // Se in Local Mode, puliamo comunque la history locale se abbiamo la data
                        const matchObj = window.allMatches.find(m => String(m.id) === String(matchId));
                        if (matchObj && matchObj.data) {
                            await LocalDB.deleteMatchFromHistory(matchObj.data, matchId);
                        }
                    }

                    applyFiltersAndRender();
                    alert("Partita eliminata e rimosso da ogni snapshot storico.");
                } catch (error) {
                    console.error("Error deleting match:", error);
                    alert("Errore durante l'eliminazione: " + error.message);
                }
            };

            function updateSortIcons() {
                document.querySelectorAll('.sortable-header').forEach(header => {
                    const icon = header.querySelector('.sort-icon');
                    if (header.dataset.sort === sortState.column) {
                        header.classList.add('active');
                        if (sortState.direction === 'asc') {
                            icon.classList.remove('fa-sort', 'fa-sort-down');
                            icon.classList.add('fa-sort-up');
                        } else {
                            icon.classList.remove('fa-sort', 'fa-sort-up');
                            icon.classList.add('fa-sort-down');
                        }
                    } else {
                        header.classList.remove('active');
                        icon.classList.remove('fa-sort-up', 'fa-sort-down');
                        icon.classList.add('fa-sort');
                    }
                });
            }

            sortableHeaders.forEach(header => header.addEventListener('click', (e) => {
                const newColumn = e.currentTarget.dataset.sort;
                if (sortState.column === newColumn) {
                    sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.column = newColumn;
                    sortState.direction = ['data', 'probabilita', 'quota'].includes(newColumn) ? 'desc' : 'asc';
                }
                sortAndRenderMatches();
            }));

            // ==================== FAVORITES ====================
            async function loadFavorites() {
                try {
                    const favDocRef = doc(db, "preferences", "favoriteLeagues");
                    const docSnap = await getDoc(favDocRef);
                    if (docSnap.exists()) {
                        favoriteLeagues = docSnap.data().leagues || [];
                        stagedFavoriteLeagues = [...favoriteLeagues];
                    }
                } catch (e) { console.error("Error:", e); }
            };

            const handleUpdateFavorites = async () => {
                favoriteLeagues = [...stagedFavoriteLeagues];
                try {
                    await setDoc(doc(db, "preferences", "favoriteLeagues"), { leagues: favoriteLeagues });
                    populateFilters();
                    applyFiltersAndRender();
                    showModal("Successo", "Preferiti aggiornati!", () => { });
                } catch (e) {
                    showModal("Errore", `Errore: ${e.message}`, () => { });
                }
            };

            async function handleFavoriteToggle(e) {
                const leagueName = e.target.dataset.league;
                if (stagedFavoriteLeagues.includes(leagueName)) {
                    stagedFavoriteLeagues = stagedFavoriteLeagues.filter(l => l !== leagueName);
                } else {
                    stagedFavoriteLeagues.push(leagueName);
                }
                e.target.classList.toggle('is-favorite');
            };

            updateFavoritesBtn.addEventListener('click', handleUpdateFavorites);

            // ==================== CLIENT FILTERS MANAGEMENT (NEW) ====================
            let allClientFilters = {}; // Stores both presets and strategies

            async function loadClientFiltersForAdmin() {
                try {
                    allClientFilters = {};
                    const select = document.getElementById('client-filters-select');
                    select.innerHTML = '<option value="">Seleziona Filtro Client...</option>';

                    // 1. Load Standard Presets
                    const presetsDoc = await getDoc(doc(db, "system", "client_presets"));
                    if (presetsDoc.exists()) {
                        const presets = presetsDoc.data();
                        Object.keys(presets).forEach(key => {
                            if (key === 'lastUpdated') return;
                            const presetData = presets[key];
                            const leagues = Array.isArray(presetData) ? presetData : (presetData.leagues || []);

                            allClientFilters[key] = {
                                type: 'preset',
                                name: key.replace(/_/g, ' ').toUpperCase(),
                                leagues: leagues,
                            };
                            select.innerHTML += `<option value="${key}">üéØ ${allClientFilters[key].name}</option>`;
                        });
                    }

                    // 2. Load Custom Strategies (Published ones with readable names)
                    const strategiesDoc = await getDoc(doc(db, "system", "client_strategies"));
                    if (strategiesDoc.exists()) {
                        const strategies = strategiesDoc.data();
                        Object.keys(strategies).forEach(key => {
                            const isRandomId = /^[A-Z0-9]{20,}$/i.test(key);
                            if (isRandomId) return;

                            allClientFilters[key] = {
                                type: 'strategy',
                                name: strategies[key].name || key.replace(/_/g, ' ').toUpperCase(),
                                ...strategies[key]
                            };
                            select.innerHTML += `<option value="${key}">‚ö° ${allClientFilters[key].name}</option>`;
                        });
                    }
                } catch (e) {
                    console.error("Error loading client filters:", e);
                    showModal("Errore", "Impossibile caricare i filtri client.");
                }
            }

            function handleClientFilterSelect() {
                const selectedKey = document.getElementById('client-filters-select').value;
                if (!selectedKey) return;

                const filter = allClientFilters[selectedKey];
                if (!filter) return;

                // Reset UI first
                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));

                // Apply Leagues (Hybrid ID/Name support for transition)
                if (filter.leagues && Array.isArray(filter.leagues)) {
                    console.log(`[handleClientFilterSelect] Leagues in filter: ${filter.leagues.length}`);
                    let checkedCount = 0;
                    filter.leagues.forEach(league => {
                        // Trial 1: Match by ID (preferred rule)
                        let cb = leagueFiltersGrid.querySelector(`input.league-checkbox[value="${league}"]`);

                        // Trial 2: Match by Name (fallback for legacy presets)
                        if (!cb) {
                            cb = leagueFiltersGrid.querySelector(`input.league-checkbox[data-name="${league}"]`);
                        }

                        if (cb) {
                            cb.checked = true;
                            checkedCount++;
                        } else {
                            console.warn(`[handleClientFilterSelect] Checkbox not found for league: ${league}`);
                        }
                    });
                    console.log(`[handleClientFilterSelect] Checked ${checkedCount} boxes.`);
                } else {
                    console.log(`[handleClientFilterSelect] No leagues in filter or not an array.`);
                }

                // Apply Sliders (if present, otherwise default)
                if (filter.probRange) {
                    probabilitySliderEl.noUiSlider.set(filter.probRange);
                } else {
                    probabilitySliderEl.noUiSlider.set([0, 100]); // Default
                }

                if (filter.oddsRange) {
                    oddsSliderEl.noUiSlider.set(filter.oddsRange);
                } else {
                    oddsSliderEl.noUiSlider.set([1.0, 10.0]); // Default
                }

                // Apply Tips (if present)
                if (filter.tips && Array.isArray(filter.tips)) {
                    filter.tips.forEach(tip => {
                        const btn = tipFiltersContainer.querySelector(`.tip-button[data-tip="${tip}"]`);
                        if (btn) btn.classList.add('active');
                    });
                }

                console.log(`[handleClientFilterSelect] Applying filter: ${filter.name}`);
                applyFiltersAndRender();

                // Show edit name container and populate with current strategy name
                const editContainer = document.getElementById('edit-strategy-name-container');
                const editNameInput = document.getElementById('edit-strategy-name');
                if (editContainer && editNameInput) {
                    editContainer.classList.remove('hidden');
                    editNameInput.value = filter.name || '';
                    editNameInput.dataset.strategyId = selectedKey; // Store ID for update
                }

                // Also populate "Pubblica Nuova" field for creating a duplicate
                const nameInput = document.getElementById('new-strategy-name');
                if (nameInput && filter.name) {
                    nameInput.value = filter.name + ' (Copia)';
                    nameInput.placeholder = 'Nome nuova strategia...';
                }

                showModal("Filtro Caricato", `Caricato filtro: <b>${filter.name}</b>.<br>Puoi modificarlo (incluso il nome) e cliccare "Aggiorna Strategia" o salvarlo come nuova.`);
            }

            // Recalculate Button Handler
            const recalcBtn = document.getElementById('recalc-strategies-btn');
            if (recalcBtn) {
                recalcBtn.addEventListener('click', async () => {
                    const btn = document.getElementById('recalc-strategies-btn');
                    const originalText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i> Calcolo in corso...';

                    try {
                        // USE THE DATE FROM CALENDAR, NOT ALWAYS TODAY!
                        // Try new Pronostici tab first, fallback to old Storico tab
                        const pronosticiDate = document.getElementById('pronostici-date')?.value;
                        const storicoDate = document.getElementById('storico-date')?.value;
                        const calendarDate = pronosticiDate || storicoDate;
                        const targetDate = calendarDate || new Date().toISOString().split('T')[0];

                        console.log(`[Ricalcola Oggi] Recalculating for date: ${targetDate}`);

                        let targetMatches = [];

                        // Local/Remote Logic
                        if (window.USE_LOCAL_DB_ONLY && window.allMatches && window.allMatches.length > 0) {
                            targetMatches = window.allMatches.filter(m => m.data === targetDate);
                        } else {
                            const matchesRef = collection(db, "matches");
                            const q = query(matchesRef, where("data", "==", targetDate));
                            const snapshot = await getDocs(q);
                            snapshot.forEach(doc => targetMatches.push(doc.data()));
                        }

                        if (targetMatches.length > 0) {
                            // üî• NEW WORKFLOW REDIRECT
                            if (typeof runStep1_MonteCarlo === 'function') {
                                console.log("[Legacy Button] Redirecting to New Workflow...");
                                await runStep1_MonteCarlo();
                                await runStep2_Distribution();
                            } else {
                                alert(`‚úÖ Matches found: ${targetMatches.length}. Per favore usa il nuovo workflow a 3 step in fondo alla pagina per calcolare le strategie.`);
                            }
                        } else {
                            alert('‚ö†Ô∏è Nessuna partita trovata per oggi.');
                        }
                    } catch (e) {
                        console.error("Error recalculating:", e);
                        alert('Errore durante il ricalcolo: ' + e.message);
                    } finally {
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                    }
                });
            }

            // === PRONOSTICI TAB: 2 SIMPLE BUTTONS ===

            // Button 1: Carica Previsioni (ricalcola + visualizza)
            const pronosticiLoadBtn = document.getElementById('pronostici-load-btn');
            if (pronosticiLoadBtn) {
                pronosticiLoadBtn.addEventListener('click', async () => {
                    const selectedDate = document.getElementById('pronostici-unified-date').value;
                    if (!selectedDate) {
                        alert('‚ö†Ô∏è Seleziona una data!');
                        return;
                    }

                    const btn = document.getElementById('pronostici-load-btn');
                    const originalText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i> Calcolo in corso...';

                    try {
                        console.log(`[Pronostici] Calculating for date: ${selectedDate}`);

                        let targetMatches = [];

                        // 1. Fetch Matches (Local Priority vs Remote)
                        if (window.USE_LOCAL_DB_ONLY && window.allMatches && window.allMatches.length > 0) {
                            console.log('[Pronostici] Using LOCAL matches for calculation');
                            // Strict date string comparison "YYYY-MM-DD"
                            targetMatches = window.allMatches.filter(m => m.data === selectedDate);
                        } else {
                            console.log('[Pronostici] Using REMOTE matches for calculation');
                            const matchesRef = collection(db, "matches");
                            const q = query(matchesRef, where("data", "==", selectedDate));
                            const snapshot = await getDocs(q);
                            snapshot.forEach(doc => targetMatches.push(doc.data()));
                        }

                        if (targetMatches.length === 0) {
                            alert(`‚ö†Ô∏è Nessuna partita trovata per il ${selectedDate}.\nAssicurati di aver caricato il CSV con le partite di oggi.`);
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                            return;
                        }

                        if (typeof runStep1_MonteCarlo === 'function') {
                            console.log("[Legacy Button] Redirecting to New Workflow...");
                            await runStep1_MonteCarlo();
                            await runStep2_Distribution();
                        } else {
                            alert(`‚úÖ Matches found: ${targetMatches.length}. Per favore usa il nuovo workflow a 3 step in fondo alla pagina per calcolare le strategie.`);
                        }

                        // ‚ö†Ô∏è RIMOSSO: Auto-generazione Trading Picks
                        // Trading 3.0 √® SEPARATO da Pronostici - usa il pulsante dedicato in Trading 3.0

                        console.log('[Pronostici] ‚úÖ Calculation completed, now loading display...');


                        // Step 2: Carica e visualizza ranking
                        console.log('[Pronostici] Fetching from rankings/' + selectedDate);
                        const rankingDoc = await getDoc(doc(db, "rankings", selectedDate));
                        console.log('[Pronostici] Doc exists:', rankingDoc.exists());

                        if (!rankingDoc.exists()) {
                            alert(`Ranking calcolato ma errore visualizzazione`);
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                            return;
                        }

                        const savedRankingData = rankingDoc.data();
                        const strategies = savedRankingData.strategies;
                        console.log('[Pronostici] Strategies loaded:', Object.keys(strategies).length);

                        // LOGICA UNIFICATA:
                        // Se √® OGGI -> Aggiorna e mostra SOLO la Dashboard Verde (Live)
                        // Se √® STORICO -> Mostra la sezione Viola (Ranking)
                        const todayParams = new Date().toISOString().split('T')[0];
                        if (selectedDate === todayParams) {
                            console.log('[Pronostici] Date is TODAY -> Refreshing Live Dashboard');

                            // Nascondi sezione storico/viola
                            document.getElementById('pronostici-ranking-section').classList.add('hidden');
                            document.getElementById('pronostici-storico-section').classList.add('hidden');

                            // Aggiorna e mostra dashboard verde
                            if (window.loadPronosticiLiveStrategies) {
                                await window.loadPronosticiLiveStrategies();
                                // Scroll to top to see dashboard
                                document.getElementById('pronostici-live-section')?.scrollIntoView({ behavior: 'smooth' });
                            }

                            // Reset button
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                            return; // STOP HERE for today
                        }

                        // SOLO SE STORICO (NON OGGI): Mostra sezione ranking viola
                        console.log('[Pronostici] Date is HISTORY -> Showing ranking section...');
                        document.getElementById('live-today-section').classList.add('hidden'); // Hide live dashboard when viewing history
                        document.getElementById('pronostici-ranking-section').classList.remove('hidden');
                        document.getElementById('pronostici-storico-section').classList.add('hidden');

                        const strategiesGrid = document.getElementById('ranking-strategies-grid');
                        strategiesGrid.innerHTML = '';
                        console.log('[Pronostici] Building strategy cards...');

                        Object.keys(strategies).forEach((stratId, index) => {
                            try {
                                console.log(`[Pronostici] Creating card ${index + 1}/${Object.keys(strategies).length}: ${stratId}`);
                                const strat = strategies[stratId];

                                // Calculate stats
                                const matches = strat.partite_by_tip || strat.matches || [];
                                const allPartite = Array.isArray(matches) ? matches : Object.values(matches).flat();

                                // HYDRATION: Update esito/risultato from allMatches
                                // NOTE: Saved rankings don't have 'id', so we use data+partita as key
                                const globalMatchesMap = new Map((window.allMatches || []).map(m => {
                                    const key = `${m.data}_${m.partita}`;
                                    return [key, m];
                                }));

                                let vinte = 0, perse = 0, void_match = 0;
                                allPartite.forEach(p => {
                                    const matchKey = `${p.data}_${p.partita}`;
                                    const latest = globalMatchesMap.get(matchKey);
                                    if (latest) {
                                        p.risultato = latest.risultato || p.risultato;
                                        p.esito = latest.esito || p.esito;
                                    }

                                    if (p.esito === 'Vinto') vinte++;
                                    else if (p.esito === 'Perso') perse++;
                                    else void_match++;
                                });

                                const totalResolved = vinte + perse;
                                const winRate = totalResolved > 0 ? ((vinte / totalResolved) * 100).toFixed(1) : 0;

                                const card = document.createElement('div'); // Changed to div for better control
                                card.className = `p-4 rounded-xl border-2 cursor-pointer transition-all hover:shadow-xl hover:-translate-y-1 ${strat.magic_type === 'gold' ? 'border-yellow-400 bg-yellow-50' :
                                    strat.magic_type === 'silver' ? 'border-gray-300 bg-gray-50' :
                                        'border-purple-100 bg-white hover:border-purple-300'
                                    }`;

                                card.innerHTML = `
                                    <div class="flex justify-between items-start mb-3">
                                        <div class="font-bold text-gray-800 text-lg truncate pr-2" title="${strat.name}">${strat.name}</div>
                                        <div class="text-xs px-2 py-1 rounded font-bold uppercase tracking-wider ${strat.magic_type === 'gold' ? 'bg-yellow-200 text-yellow-800' :
                                        strat.magic_type === 'silver' ? 'bg-gray-200 text-gray-700' :
                                            'bg-purple-100 text-purple-700'
                                    }">
                                            ${strat.magic_type || 'STD'}
                                        </div>
                                    </div>
                                    
                                    <div class="grid grid-cols-3 gap-2 mb-3">
                                        <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                            <div class="text-xs text-gray-500 uppercase">Partite</div>
                                            <div class="font-bold text-gray-800 text-lg">${allPartite.length}</div>
                                        </div>
                                        <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                            <div class="text-xs text-gray-500 uppercase">Win Rate</div>
                                            <div class="font-bold ${parseFloat(winRate) >= 70 ? 'text-green-600' : parseFloat(winRate) >= 50 ? 'text-blue-600' : 'text-orange-500'} text-lg">${winRate}%</div>
                                        </div>
                                        <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                            <div class="text-xs text-gray-500 uppercase">W / L</div>
                                            <div class="font-bold text-gray-800 text-lg">
                                                <span class="text-green-600">${vinte}</span> / <span class="text-red-500">${perse}</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="text-center text-xs text-purple-600 font-medium border-t border-purple-100 pt-2 mt-2">
                                        Clicca per vedere le partite <i class="fa-solid fa-chevron-right ml-1"></i>
                                    </div>
                                `;
                                card.addEventListener('click', () => displayRankingMatches(stratId, strat, savedRankingData));
                                strategiesGrid.appendChild(card);
                                console.log(`[Pronostici] Card ${index + 1} created successfully`);
                            } catch (cardError) {
                                console.error(`[Pronostici] Error creating card for ${stratId}:`, cardError);
                            }
                        });

                        console.log('[Pronostici] All cards created, showing lists...');

                        document.getElementById('ranking-strategies-list').classList.remove('hidden');
                        document.getElementById('ranking-matches-detail').classList.add('hidden');

                        // AUTO-UPDATE: Aggiorna lastUpdate in global_stats
                        try {
                            const statsDoc = await getDoc(doc(db, "system", "global_stats"));
                            const currentStats = statsDoc.exists() ? statsDoc.data() : {};
                            await setDoc(doc(db, "system", "global_stats"), {
                                ...currentStats,
                                lastUpdate: selectedDate,
                                updatedAt: new Date().toISOString()
                            });
                            console.log('[Pronostici] ‚úÖ global_stats.lastUpdate aggiornato a:', selectedDate);
                        } catch (statsErr) {
                            console.error('[Pronostici] ‚ö†Ô∏è Errore aggiornamento lastUpdate:', statsErr);
                        }

                        alert(`‚úÖ Previsioni calcolate per il ${selectedDate}!\n\n${targetMatches.length} partite elaborate.\n${Object.keys(strategies).length} strategie generate.`);

                    } catch (e) {
                        console.error('[Pronostici] Error:', e);
                        alert('Errore: ' + e.message);
                    } finally {
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                    }
                });
            }

            // Button 3: Generate Warning Stats
            const generateWarningBtn = document.getElementById('generate-warning-stats-btn');
            if (generateWarningBtn) {
                generateWarningBtn.addEventListener('click', async () => {
                    const originalText = generateWarningBtn.innerHTML;
                    try {
                        generateWarningBtn.disabled = true;
                        generateWarningBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Analizzando...';

                        const stats = await generateWarningStats();

                        // Store for import button
                        currentWarningStats = stats;

                        const totalWarnings = (stats?.volatileLeagues?.length || 0) +
                            (stats?.lowPerformingTips?.length || 0) +
                            (stats?.overestimatedLeagues?.length || 0);

                        const percentAnomalous = stats?.totalLeaguesWithData > 0
                            ? ((totalWarnings / stats.totalLeaguesWithData) * 100).toFixed(1)
                            : 0;

                        let message = `‚úÖ Warning Stats Generate!\n\n`;
                        message += `üìä TOTALE LEGHE:\n`;
                        message += `‚Ä¢ Analizzate: ${stats?.totalLeaguesAnalyzed || 0}\n`;
                        message += `‚Ä¢ Con dati sufficienti (‚â•20 partite): ${stats?.totalLeaguesWithData || 0}\n`;
                        message += `‚Ä¢ Anomale: ${totalWarnings} (${percentAnomalous}%)\n\n`;

                        message += `‚ö†Ô∏è ANOMALIE RILEVATE:\n`;
                        message += `‚Ä¢ Leghe volatili: ${stats?.volatileLeagues?.length || 0}\n`;
                        message += `‚Ä¢ Tip sotto-performanti: ${stats?.lowPerformingTips?.length || 0}\n`;
                        message += `‚Ä¢ Leghe sovrastimate: ${stats?.overestimatedLeagues?.length || 0}\n\n`;

                        if (stats?.veryAnomalousLeagues && stats.veryAnomalousLeagues.length > 0) {
                            message += `üö® LEGHE MOLTO ANOMALE (${stats.veryAnomalousLeagues.length}):\n`;
                            message += `(Criteri: Vol >46% O WR <38% O Gap >27%)\n\n`;

                            const maxShow = 10; // Limit popup display
                            const toShow = stats.veryAnomalousLeagues.slice(0, maxShow);

                            toShow.forEach(league => {
                                message += `‚Ä¢ ${league.lega}\n`;
                                message += `  ${league.total} partite | WR: ${league.winrate} | Vol: ${league.volatility}\n`;
                                message += `  ${league.reason}\n\n`;
                            });

                            if (stats.veryAnomalousLeagues.length > maxShow) {
                                message += `... e altre ${stats.veryAnomalousLeagues.length - maxShow} leghe.\n`;
                                message += `Vedi box sotto per lista completa.\n\n`;
                            }

                            message += `üí° Consiglio: Elimina queste leghe per migliorare dati.\n\n`;
                        }

                        message += `Dati salvati in /system/warning_stats\n\n`;
                        message += `üí° Usa il pulsante "Blacklist" per gestire le leghe da escludere.`;

                        alert(message);

                    } catch (e) {
                        console.error('[Warning Stats] Error:', e);
                        alert('‚ùå Errore generazione warning stats: ' + e.message);
                    } finally {
                        generateWarningBtn.disabled = false;
                        generateWarningBtn.innerHTML = originalText;
                    }
                });
            }

            // ==================== SIMPLIFIED BLACKLIST MANAGER ====================
            let currentBlacklist = [];
            let savedWinrateThreshold = 50;
            let leagueWinrates = {}; // { "Serie A": 72.5, "Premier League": 68.3, ... }

            // Load blacklist from Firebase
            async function loadBlacklistData() {
                try {
                    console.log("[Blacklist] Loading from Firebase...");
                    const blacklistDoc = await getDoc(doc(db, "system", "blacklisted_leagues"));
                    if (blacklistDoc.exists()) {
                        const data = blacklistDoc.data();
                        currentBlacklist = data.leagues || [];
                        savedWinrateThreshold = data.winrateThreshold || 50;
                        console.log(`[Blacklist] Loaded ${currentBlacklist.length} leagues, threshold: ${savedWinrateThreshold}%`);
                    } else {
                        console.log('[Blacklist] No saved blacklist found');
                    }
                } catch (e) {
                    console.error('[Blacklist] Error loading:', e);
                }
            }

            // Calculate winrate for all leagues from allMatches (one-time)
            function calculateAllLeagueWinrates() {
                leagueWinrates = {};
                const matchesWithResult = allMatches.filter(m => m.risultato && m.risultato.trim() !== '');

                const leagueStats = {};
                matchesWithResult.forEach(m => {
                    const lega = m.lega || 'Unknown';
                    if (!leagueStats[lega]) {
                        leagueStats[lega] = { total: 0, wins: 0 };
                    }
                    leagueStats[lega].total++;
                    if (m.esito === 'Vinto') leagueStats[lega].wins++;
                });

                // Only include leagues with at least 10 matches
                Object.entries(leagueStats).forEach(([lega, stats]) => {
                    if (stats.total >= 10) {
                        leagueWinrates[lega] = (stats.wins / stats.total) * 100;
                    }
                });

                console.log(`[Blacklist] Calculated winrates for ${Object.keys(leagueWinrates).length} leagues`);
                return Object.keys(leagueWinrates).length;
            }

            // Render results based on threshold
            function renderBlacklistResults(threshold) {
                const listEl = document.getElementById('bl-results-list');
                const countEl = document.getElementById('bl-results-count');
                if (!listEl) return;

                let results = [];

                // Add leagues matching threshold + leagues already in blacklist
                Object.entries(leagueWinrates).forEach(([lega, winrate]) => {
                    const matchesThreshold = winrate < threshold;
                    const inBlacklist = currentBlacklist.includes(lega);
                    const improved = inBlacklist && !matchesThreshold; // Was in blacklist but now above threshold

                    if (matchesThreshold || inBlacklist) {
                        results.push({ lega, winrate, inBlacklist, improved });
                    }
                });

                // Sort: worst winrate first
                results.sort((a, b) => a.winrate - b.winrate);

                countEl.textContent = results.length;

                if (results.length === 0) {
                    listEl.innerHTML = '<div class="text-gray-400 italic text-center py-4">Nessuna lega con winrate sotto ' + threshold + '%</div>';
                    return;
                }

                let html = '';
                results.forEach(r => {
                    const bgClass = r.improved
                        ? 'bg-green-100 border-green-400'
                        : (r.inBlacklist ? 'bg-white border-gray-300' : 'bg-white border-gray-200');
                    const textClass = r.improved ? 'text-green-800 font-semibold' : 'text-gray-900';
                    const checkedAttr = r.inBlacklist ? 'checked' : '';
                    const badge = r.improved
                        ? '<span class="text-xs bg-green-200 text-green-800 px-2 py-0.5 rounded font-medium">‚úì migliorata</span>'
                        : (r.inBlacklist ? '<span class="text-xs bg-purple-100 text-purple-700 px-2 py-0.5 rounded font-medium">in blacklist</span>' : '');

                    html += `
                        <label class="flex items-center gap-3 p-3 rounded-lg border ${bgClass} cursor-pointer hover:shadow-sm transition">
                            <input type="checkbox" class="bl-league-checkbox rounded w-5 h-5 text-purple-600" data-lega="${r.lega}" ${checkedAttr}>
                            <span class="flex-1 ${textClass}">${r.lega}</span>
                            <span class="text-sm font-bold ${r.improved ? 'text-green-700' : 'text-gray-800'}">${r.winrate.toFixed(1)}%</span>
                            ${badge}
                        </label>
                    `;
                });

                listEl.innerHTML = html;
            }

            // Open Blacklist Manager
            document.getElementById('open-blacklist-btn')?.addEventListener('click', async () => {
                const panel = document.getElementById('blacklist-manager-panel');
                panel.classList.remove('hidden');

                // Load saved data
                await loadBlacklistData();

                // Update UI
                document.getElementById('bl-winrate-threshold').value = savedWinrateThreshold;
                document.getElementById('blacklist-count-header').textContent = `${currentBlacklist.length} leghe in blacklist`;
                document.getElementById('bl-last-threshold').innerHTML = `Soglia salvata: <span class="font-semibold">${savedWinrateThreshold}%</span>`;

                // Calculate winrates
                const leagueCount = calculateAllLeagueWinrates();

                if (leagueCount === 0) {
                    document.getElementById('bl-results-list').innerHTML =
                        '<div class="text-orange-600 text-center py-4"><i class="fa-solid fa-triangle-exclamation mr-2"></i>Nessun dato. Carica prima le partite.</div>';
                    return;
                }

                // Render with saved threshold
                renderBlacklistResults(savedWinrateThreshold);
            });

            // Close Blacklist Manager
            document.getElementById('close-blacklist-btn')?.addEventListener('click', () => {
                document.getElementById('blacklist-manager-panel').classList.add('hidden');
            });

            // Auto-filter on threshold change (no button needed)
            document.getElementById('bl-winrate-threshold')?.addEventListener('input', () => {
                const threshold = parseInt(document.getElementById('bl-winrate-threshold')?.value) || 50;
                renderBlacklistResults(threshold);
            });

            // Select all checkbox
            document.getElementById('bl-selectall')?.addEventListener('change', (e) => {
                document.querySelectorAll('.bl-league-checkbox').forEach(cb => cb.checked = e.target.checked);
            });

            // Save Blacklist
            document.getElementById('bl-save-btn')?.addEventListener('click', async () => {
                const oldBlacklist = [...currentBlacklist];
                const newBlacklist = [];

                document.querySelectorAll('.bl-league-checkbox:checked').forEach(cb => {
                    newBlacklist.push(cb.dataset.lega);
                });

                const added = newBlacklist.filter(l => !oldBlacklist.includes(l));
                const removed = oldBlacklist.filter(l => !newBlacklist.includes(l));
                const threshold = parseInt(document.getElementById('bl-winrate-threshold')?.value) || 50;

                try {
                    await setDoc(doc(db, "system", "blacklisted_leagues"), {
                        leagues: newBlacklist,
                        winrateThreshold: threshold,
                        lastUpdated: Date.now()
                    });

                    currentBlacklist = newBlacklist;
                    savedWinrateThreshold = threshold;
                    document.getElementById('blacklist-count-header').textContent = `${currentBlacklist.length} leghe in blacklist`;
                    document.getElementById('bl-last-threshold').innerHTML = `Ultimo filtro salvato: <span class="font-semibold">${threshold}%</span>`;

                    alert(`‚úÖ Blacklist salvata!\n\n` +
                        `‚Ä¢ Prima: ${oldBlacklist.length} leghe\n` +
                        `‚Ä¢ Aggiunte: ${added.length} leghe\n` +
                        `‚Ä¢ Rimosse: ${removed.length} leghe\n` +
                        `‚Ä¢ Ora: ${newBlacklist.length} leghe\n\n` +
                        `Soglia salvata: ${threshold}%`);

                } catch (e) {
                    console.error('[Blacklist] Save error:', e);
                    alert('‚ùå Errore salvataggio: ' + e.message);
                }
            });

            // Clear all button
            document.getElementById('bl-clear-all-btn')?.addEventListener('click', async () => {
                if (!confirm('Sei sicuro di voler svuotare la blacklist?')) return;

                try {
                    await setDoc(doc(db, "system", "blacklisted_leagues"), {
                        leagues: [],
                        winrateThreshold: savedWinrateThreshold,
                        lastUpdated: Date.now()
                    });

                    const oldCount = currentBlacklist.length;
                    currentBlacklist = [];
                    document.getElementById('blacklist-count-header').textContent = '0 leghe in blacklist';
                    document.querySelectorAll('.bl-league-checkbox').forEach(cb => cb.checked = false);

                    alert(`‚úÖ Blacklist svuotata!\n\n${oldCount} leghe rimosse.`);

                } catch (e) {
                    console.error('[Blacklist] Clear error:', e);
                    alert('‚ùå Errore: ' + e.message);
                }
            });

            // Load blacklist on page load
            loadBlacklistData();


            // Helper: nasconde TUTTE le sezioni Pronostici
            function hideAllPronosticiSections() {
                const sections = [
                    'live-today-section',
                    'pronostici-ranking-section',
                    'pronostici-storico-section',
                    'trading-picks-container',
                    'trading-storico-section'
                ];
                sections.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.classList.add('hidden');
                });
            }

            // Button 2: Storico Strategie
            const pronosticiHistoryBtn = document.getElementById('pronostici-history-btn');
            if (pronosticiHistoryBtn) {
                pronosticiHistoryBtn.addEventListener('click', async () => {

                    // üî• OPTIMIZATION: Se c'√® una data selezionata, carica direttamente quella (1 lettura!)
                    const datePicker = document.getElementById('pronostici-unified-date');
                    const selectedDate = datePicker?.value;

                    if (selectedDate && selectedDate.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        console.log(`[Storico] üöÄ Fast load for selected date: ${selectedDate}`);

                        try {
                            hideAllPronosticiSections();
                            document.getElementById('pronostici-storico-section').classList.remove('hidden');

                            // üî• STORICO 3.0: Try LocalDB (Database Oro) FIRST
                            console.log(`[Storico] Checking Database Oro for ${selectedDate}...`);
                            let strategiesList = [];
                            const localData = await window.LocalDB.loadStrategyHistory(selectedDate);

                            if (localData && Object.keys(localData).length > 0) {
                                console.log(`[Storico] ‚úÖ Database Oro MATCH! (Instant load)`);
                                Object.entries(localData).forEach(([id, data]) => {
                                    strategiesList.push({
                                        id: id,
                                        filtro_nome: data.name || id,
                                        ...data
                                    });
                                });

                                if (strategiesList.length > 0) {
                                    renderStoricoStrategiesForDate(selectedDate, strategiesList);
                                    return; // üî• FIX: EXIT EARLY after successful local load!
                                }
                            } else {
                                console.log(`[Storico] Low cache miss, fetching from Firebase...`);
                                // Try subcollection first (new structure)
                                const parentDocRef = doc(db, "daily_strategies", selectedDate);
                                const strategiesSubCol = collection(parentDocRef, "strategies");
                                const subColSnapshot = await getDocs(strategiesSubCol);



                                if (!subColSnapshot.empty) {
                                    console.log(`[Storico] Found ${subColSnapshot.size} strategies in subcollection`);
                                    subColSnapshot.forEach(docSnap => {
                                        const data = docSnap.data();
                                        strategiesList.push({
                                            id: docSnap.id,
                                            filtro_nome: data.name || docSnap.id,
                                            name: data.name || docSnap.id,
                                            totalMatches: data.totalMatches || 0,
                                            partite_by_tip: data.matches || [],
                                            matches: data.matches || [],
                                            magic_type: data.type === 'monte_carlo' ? 'CUSTOM' : 'STD',
                                            ...data
                                        });
                                    });
                                } else {
                                    // Fallback to ranking_history
                                    console.log(`[Storico] No subcollection, trying ranking_history...`);
                                    const rhDoc = await getDoc(doc(db, "ranking_history", selectedDate));
                                    if (rhDoc.exists()) {
                                        const rhData = rhDoc.data();
                                        strategiesList = rhData.strategies || [];
                                    }
                                }

                                if (strategiesList.length > 0) {
                                    renderStoricoStrategiesForDate(selectedDate, strategiesList);
                                    console.log(`[Storico] ‚úÖ Loaded ${strategiesList.length} strategies for ${selectedDate}`);
                                    return; // Exit early - don't load full list
                                } else {
                                    console.log(`[Storico] No strategies found for ${selectedDate}, showing full list...`);
                                }
                            }
                        } catch (fastLoadErr) {
                            console.warn(`[Storico] Fast load failed, falling back to full list:`, fastLoadErr.message);
                        }
                    }

                    // === NEW BEHAVIOR: Load ONLY from Local Database Oro (Instant) ===
                    console.log('[Pronostici] Loading history from Local Database Oro...');

                    try {
                        // Hide all, show storico
                        hideAllPronosticiSections();
                        document.getElementById('pronostici-storico-section').classList.remove('hidden');

                        // Update title
                        document.getElementById('pronostici-storico-title').textContent = `Storico Strategie`;
                        document.getElementById('pronostici-storico-count').textContent = `Seleziona una data per vedere i dettagli (Solo Database Oro)`;

                        // Show section
                        const listSection = document.getElementById('pronostici-storico-list');
                        listSection.classList.remove('hidden');

                        // Populate Simple List with DEDUPLICATION
                        const container = document.getElementById('pronostici-storico-container');
                        container.innerHTML = '';
                        container.className = "bg-white rounded-b-xl shadow-md border border-gray-200 overflow-hidden";

                        // Create Header
                        const header = document.createElement('div');
                        header.className = "grid grid-cols-3 bg-gray-50 p-4 font-bold text-gray-700 border-b border-gray-200 uppercase text-xs tracking-wider";
                        header.innerHTML = `
                            <div>Data</div>
                            <div class="text-center">Strategie</div>
                            <div class="text-center">Tot. Partite</div>
                        `;
                        container.appendChild(header);

                        // Deduplicate by date
                        const uniqueDates = new Map();

                        // üî• STORICO 3.0: Merge LocalDB dates (Database Oro)
                        try {
                            const localStrategies = await window.LocalDB.getAllStrategies();
                            console.log(`[Storico] Found ${localStrategies.length} local dates in Database Oro`);
                            localStrategies.forEach(item => {
                                const date = item.date;
                                const strategiesList = Array.isArray(item.strategies) ? item.strategies : Object.values(item.strategies || {});

                                // Se non c'√® gi√† (da Firebase) o se i dati locali sono pi√π completi, usa quelli
                                if (!uniqueDates.has(date) || strategiesList.length >= uniqueDates.get(date).strategiesList.length) {
                                    uniqueDates.set(date, { date, strategiesList, isGold: true });
                                }
                            });
                        } catch (localErr) {
                            console.warn("[Storico] Errore caricamento date locali:", localErr);
                        }

                        // Sort dates descending (CLIENT-SIDE)
                        const sortedDatesArray = Array.from(uniqueDates.values())
                            .sort((a, b) => b.date.localeCompare(a.date))
                            .slice(0, 50); // Mostra fino a 50 date

                        // Render unique rows
                        sortedDatesArray.forEach(({ date, strategiesList, isGold }) => {
                            const count = strategiesList.length;
                            const goldBadge = isGold ? '<span class="ml-2 text-[10px] bg-amber-100 text-amber-700 px-1.5 py-0.5 rounded font-bold border border-amber-200">GOLD</span>' : '';

                            // Calculate total matches
                            let totalMatches = 0;
                            strategiesList.forEach(s => {
                                const matches = s.partite_by_tip || s.matches || [];
                                const matchCount = Array.isArray(matches) ? matches.length : Object.values(matches).flat().length;
                                totalMatches += matchCount;
                            });

                            const row = document.createElement('div');
                            row.className = "grid grid-cols-3 p-4 border-b border-gray-100 hover:bg-purple-50 cursor-pointer transition-colors items-center group";
                            row.innerHTML = `
                                <div class="font-bold text-gray-800 group-hover:text-purple-700 flex items-center gap-2">
                                    <i class="fa-regular fa-calendar text-gray-400 group-hover:text-purple-500"></i>
                                    ${date}${goldBadge}
                                </div>
                                <div class="text-center font-semibold text-gray-700">
                                    <span class="bg-gray-100 text-gray-800 py-1 px-3 rounded-full text-xs">${count}</span>
                                </div>
                                <div class="text-center text-gray-600 font-mono">${totalMatches}</div>
                            `;

                            row.addEventListener('click', async () => {
                                // üî• STORICO 3.0: Try LocalDB FIRST
                                try {
                                    const localData = await window.LocalDB.loadStrategyHistory(date);
                                    if (localData && Object.keys(localData).length > 0) {
                                        const strategiesArray = Object.entries(localData).map(([id, data]) => ({
                                            id: id,
                                            filtro_nome: data.name || id,
                                            ...data
                                        }));
                                        renderStoricoStrategiesForDate(date, strategiesArray);
                                        return;
                                    }
                                } catch (e) { console.warn("[Storico] Local click fetch failed:", e); }

                                // üî• FALLBACK: Read from subcollection (new structure)
                                try {
                                    const parentDocRef = doc(db, "daily_strategies", date);
                                    const strategiesSubCol = collection(parentDocRef, "strategies");
                                    const subColSnapshot = await getDocs(strategiesSubCol);

                                    if (!subColSnapshot.empty) {
                                        console.log(`[Storico] Found ${subColSnapshot.size} strategies in subcollection for ${date}`);
                                        const freshStrategies = [];
                                        subColSnapshot.forEach(docSnap => {
                                            const data = docSnap.data();
                                            freshStrategies.push({
                                                id: docSnap.id,
                                                filtro_nome: data.name || docSnap.id,
                                                name: data.name || docSnap.id,
                                                totalMatches: data.totalMatches || 0,
                                                partite_by_tip: data.matches || [],
                                                matches: data.matches || [],
                                                magic_type: data.type === 'monte_carlo' ? 'CUSTOM' : 'STD',
                                                ...data
                                            });
                                        });
                                        renderStoricoStrategiesForDate(date, freshStrategies);
                                        return;
                                    }
                                } catch (subErr) {
                                    console.warn(`[Storico] Subcollection read failed, using fallback:`, subErr.message);
                                }
                                // Fallback: usa dati da ranking_history
                                renderStoricoStrategiesForDate(date, strategiesList);
                            });

                            container.appendChild(row);
                        });

                        console.log('[Pronostici] History list loaded successfully!');

                    } catch (e) {
                        console.error('[Pronostici] Error loading history:', e);
                        alert('Errore: ' + e.message);
                    }
                });
            }

            // Button 4: Storico Trading
            const storicoTradingBtn = document.getElementById('storico-trading-btn');
            if (storicoTradingBtn) {
                storicoTradingBtn.addEventListener('click', async () => {
                    console.log('[Trading] Loading storico picks...');

                    try {
                        // Hide all, show trading storico
                        hideAllPronosticiSections();
                        document.getElementById('trading-storico-section').classList.remove('hidden');

                        // Load available dates from Firestore (senza orderBy per evitare indice)
                        const tradingRef = collection(db, "daily_trading_picks");
                        const q = query(tradingRef, limit(30));
                        const snapshot = await getDocs(q);

                        if (snapshot.empty) {
                            alert('‚ùå Nessuno storico trading trovato');
                            return;
                        }

                        // Raccogli e ordina le date lato client
                        const dates = [];
                        snapshot.forEach(doc => {
                            dates.push(doc.id);
                        });
                        dates.sort((a, b) => b.localeCompare(a)); // Ordine decrescente

                        // Populate dropdown
                        const dateSelect = document.getElementById('trading-date-select');
                        dateSelect.innerHTML = '<option value="">-- Seleziona data --</option>';

                        dates.forEach(date => {
                            const option = document.createElement('option');
                            option.value = date;
                            option.textContent = date;
                            dateSelect.appendChild(option);
                        });

                        // Event listener for date selection
                        dateSelect.addEventListener('change', async () => {
                            const selectedDate = dateSelect.value;
                            if (!selectedDate) return;

                            console.log('[Trading] Loading picks for', selectedDate);
                            const dayDoc = await getDoc(doc(db, "daily_trading_picks", selectedDate));

                            if (!dayDoc.exists()) {
                                alert('Nessuna pick trovata per questa data');
                                return;
                            }

                            const picks = dayDoc.data().picks || [];
                            renderTradingPicks(picks);
                        });

                        console.log('[Trading] Loaded', snapshot.size, 'dates');
                    } catch (e) {
                        console.error('[Trading] Error:', e);
                        alert('Errore caricamento storico: ' + e.message);
                    }
                });
            }

            function renderTradingPicks(picks) {
                const container = document.getElementById('trading-picks-table-container');

                if (picks.length === 0) {
                    container.innerHTML = '<p class="text-center text-gray-500 py-8">Nessuna pick disponibile</p>';
                    return;
                }

                // Simple table display  
                let html = '<div class="overflow-x-auto"><table class="w-full text-sm"><thead class="bg-gray-50"><tr>';
                html += '<th class="p-2 text-left">Partita</th>';
                html += '<th class="p-2 text-left">Lega</th>';
                html += '<th class="p-2 text-center">Ranking</th>'; // NUOVO
                html += '<th class="p-2 text-left">Strategia</th>';
                html += '<th class="p-2 text-left">Entry Range</th>';
                html += '<th class="p-2 text-left">Liquidit√†</th>';
                html += '<th class="p-2 text-left">Risultato</th>';
                html += '<th class="p-2 text-left">Esito</th>';
                html += '</tr></thead><tbody>';

                picks.forEach((pick, idx) => {
                    // Determine esito color
                    let esitoHtml = '<span class="text-gray-400">-</span>';
                    if (pick.esito) {
                        const colorClass = pick.esitoColor === 'green' ? 'bg-green-500 text-white' :
                            pick.esitoColor === 'yellow' ? 'bg-yellow-400 text-black' :
                                pick.esitoColor === 'red' ? 'bg-red-500 text-white' : 'bg-gray-200';
                        esitoHtml = `<span class="px-2 py-1 rounded text-xs font-bold ${colorClass}">${pick.esito}</span>`;
                    }

                    // If no result, show editable input
                    let risultatoHtml = pick.risultato
                        ? `<span class="font-mono font-bold">${pick.risultato}</span>`
                        : `<input type="text" id="manual-result-${idx}" class="border-2 border-orange-300 rounded px-2 py-1 w-16 text-xs font-mono" placeholder="0-0">`;

                    // Liquidity badge with colors
                    const liquidity = pick.liquidityLevel || 'Media';
                    let liquidityHtml = '';
                    if (liquidity === 'Alta') {
                        liquidityHtml = '<span class="px-2 py-1 rounded text-xs font-bold bg-green-100 text-green-700" title="Alta liquidit√† - Consigliato">üü¢ Alta</span>';
                    } else if (liquidity === 'Bassa') {
                        liquidityHtml = '<span class="px-2 py-1 rounded text-xs font-bold bg-red-100 text-red-700" title="‚ö†Ô∏è Bassa liquidit√† - Verifica sul tuo exchange prima di entrare">üî¥ ‚ö†Ô∏è Bassa</span>';
                    } else {
                        liquidityHtml = '<span class="px-2 py-1 rounded text-xs font-bold bg-yellow-100 text-yellow-700" title="Liquidit√† media - Attenzione alle size">üü° Media</span>';
                    }

                    html += '<tr class="border-b">';
                    html += `<td class="p-2 font-medium">${pick.partita}</td>`;
                    html += `<td class="p-2 text-xs text-gray-600">${pick.lega || '-'}</td>`;

                    // Bollino ranking giallo con valore confidence
                    const rankingValue = pick.confidence || pick.probabilita || 0;
                    html += `<td class="p-2 text-center"><span class="inline-block bg-yellow-400 text-black px-2 py-1 rounded-full text-xs font-bold">${Math.round(rankingValue)}</span></td>`;

                    html += `<td class="p-2"><span class="text-xs font-semibold ${pick.strategy === 'BACK_OVER_25' ? 'text-purple-700' : 'text-blue-700'}">${pick.strategy}</span></td>`;
                    html += `<td class="p-2 text-xs">${pick.tradingInstruction?.entryRange?.join(' - ') || '-'}</td>`;
                    html += `<td class="p-2">${liquidityHtml}</td>`;
                    html += `<td class="p-2">${risultatoHtml}</td>`;
                    html += `<td class="p-2">${esitoHtml}</td>`;
                    html += '</tr>';
                });

                html += '</tbody></table></div>';

                // Add save button if there are picks without results
                const picksWithoutResult = picks.filter(p => !p.risultato);
                if (picksWithoutResult.length > 0) {
                    html += `<div class="mt-4 flex justify-end">
                        <button id="save-manual-results-btn" class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-lg font-bold">
                            <i class="fa-solid fa-save mr-2"></i>Salva Risultati Manuali (${picksWithoutResult.length})
                        </button>
                    </div>`;
                }

                container.innerHTML = html;

                // Attach save button handler
                const saveBtn = document.getElementById('save-manual-results-btn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', async () => {
                        const selectedDate = document.getElementById('trading-date-select').value; // Corrected ID
                        if (!selectedDate) return alert('Seleziona una data!');

                        // Collect manual results
                        let updated = 0;
                        picks.forEach((pick, idx) => {
                            if (pick.risultato) return; // Already has result

                            const input = document.getElementById(`manual-result-${idx}`);
                            if (input && input.value.trim()) {
                                const risultato = input.value.trim();

                                // Validate format (X-X)
                                if (!/^\d+-\d+$/.test(risultato)) {
                                    alert(`Formato non valido per ${pick.partita}: usa "X-X" es. "2-1"`);
                                    return;
                                }

                                // Calculate outcome
                                const parts = risultato.split('-').map(g => parseInt(g));
                                const [golCasa, golTrasferta] = parts;
                                const golTotali = golCasa + golTrasferta;
                                const isPareggio = golCasa === golTrasferta;

                                let outcome = null;
                                if (pick.strategy === 'BACK_OVER_25') {
                                    if (golTotali <= 1) outcome = { esito: 'Stop-loss', color: 'red' };
                                    else if (golTotali === 2) outcome = { esito: 'Cash-out', color: 'yellow' };
                                    else outcome = { esito: 'Vinta', color: 'green' };
                                } else if (pick.strategy === 'LAY_THE_DRAW') {
                                    if (risultato === '0-0') outcome = { esito: 'Stop-loss', color: 'red' };
                                    else if (isPareggio) outcome = { esito: 'Cash-out', color: 'yellow' };
                                    else outcome = { esito: 'Vinta', color: 'green' };
                                }

                                if (outcome) {
                                    pick.risultato = risultato;
                                    pick.esito = outcome.esito;
                                    pick.esitoColor = outcome.color;
                                    updated++;
                                }
                            }
                        });

                        if (updated > 0) {
                            // Save to Firebase
                            const docRef = doc(db, "daily_trading_picks", selectedDate);
                            const existingDoc = await getDoc(docRef);
                            if (existingDoc.exists()) {
                                await setDoc(docRef, {
                                    ...existingDoc.data(),
                                    picks: picks,
                                    lastManualUpdate: new Date().toISOString()
                                });
                                alert(`‚úÖ Salvati ${updated} risultati manuali!`);
                                renderTradingPicks(picks); // Re-render
                            }
                        } else {
                            alert('‚ö†Ô∏è Nessun risultato da salvare. Inserisci i risultati negli input arancioni.');
                        }
                    });
                }

                // Calculate actual stats
                const picksWithResult = picks.filter(p => p.esito);
                const wins = picks.filter(p => p.esito === 'Vinta').length;
                const cashOuts = picks.filter(p => p.esito === 'Cash-out').length;
                const losses = picks.filter(p => p.esito === 'Stop-loss').length;
                const winRate = picksWithResult.length > 0 ? Math.round(((wins + cashOuts * 0.5) / picksWithResult.length) * 100) : 0;

                const picksCountEl = document.getElementById('trading-stat-picks');
                if (picksCountEl) picksCountEl.textContent = picks.length;

                const winrateEl = document.getElementById('trading-stat-winrate');
                if (winrateEl) winrateEl.textContent = picksWithResult.length > 0 ? `${winRate}%` : '--%';

                const roiEl = document.getElementById('trading-stat-roi');
                if (roiEl) roiEl.textContent = picksWithResult.length > 0 ? `${wins}W ${cashOuts}C ${losses}L` : '--‚Ç¨';

                // Strategy breakdown
                const over25 = picks.filter(p => p.strategy === 'BACK_OVER_25');
                const ltd = picks.filter(p => p.strategy === 'LAY_THE_DRAW');

                const over25CountEl = document.getElementById('over25-count');
                if (over25CountEl) over25CountEl.textContent = over25.length;

                const ltdCountEl = document.getElementById('ltd-count');
                if (ltdCountEl) ltdCountEl.textContent = ltd.length;

                // Winrate per strategy
                const over25Wins = over25.filter(p => p.esito === 'Vinta' || p.esito === 'Cash-out').length;
                const ltdWins = ltd.filter(p => p.esito === 'Vinta' || p.esito === 'Cash-out').length;
                const over25WithResult = over25.filter(p => p.esito).length;
                const ltdWithResult = ltd.filter(p => p.esito).length;

                const over25WR = document.getElementById('over25-winrate');
                if (over25WR) over25WR.textContent = over25WithResult > 0 ? `${Math.round((over25Wins / over25WithResult) * 100)}%` : '--%';

                const ltdWR = document.getElementById('ltd-winrate');
                if (ltdWR) ltdWR.textContent = ltdWithResult > 0 ? `${Math.round((ltdWins / ltdWithResult) * 100)}%` : '--%';

                const over25ROI = document.getElementById('over25-roi');
                if (over25ROI) over25ROI.textContent = '--‚Ç¨';

                const ltdROI = document.getElementById('ltd-roi');
                if (ltdROI) ltdROI.textContent = '--‚Ç¨';
            }

            function renderStoricoStrategiesForDate(date, strategiesList) {
                // Update header
                document.getElementById('pronostici-storico-title').classList.add('flex', 'items-center', 'w-full');
                document.getElementById('pronostici-storico-title').innerHTML = `
                    <div class="flex items-center">
                        <button id="back-to-history-btn" class="mr-3 hover:text-purple-200 transition-colors">
                            <i class="fa-solid fa-arrow-left"></i>
                        </button>
                        <span>Strategie del ${date}</span>
                    </div>
                    <button id="close-history-overlay-btn" class="ml-auto bg-purple-500 hover:bg-purple-400 text-white w-8 h-8 rounded-full flex items-center justify-center transition-all shadow-sm" title="Chiudi e torna a oggi">
                        <i class="fa-solid fa-xmark"></i>
                    </button>
                `;
                document.getElementById('pronostici-storico-count').textContent = `${strategiesList.length} strategie salvate`;

                const container = document.getElementById('pronostici-storico-container');
                container.innerHTML = '';

                // Add Back Button Logic
                document.getElementById('back-to-history-btn').addEventListener('click', () => {
                    document.getElementById('pronostici-history-btn').click();
                });

                // Close Button Logic: Return to Today's Rankings
                document.getElementById('close-history-overlay-btn').addEventListener('click', () => {
                    hideAllPronosticiSections();
                    document.getElementById('pronostici-ranking-section').classList.remove('hidden');
                    // Ensure the header date is correct if needed, but usually it returns to today by default
                });

                // Ensure grid layout for strategies
                container.className = "bg-white rounded-b-xl shadow-md border border-gray-200 p-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4";

                // üî• HYDRATION MAP (for real-time stats)
                const globalMatchesMap = new Map((window.allMatches || []).map(m => {
                    const key = `${m.data}_${m.partita}`;
                    return [key, m];
                }));

                // Helper: Tip Normalization for comparison
                const isSameTip = (t1, t2) => {
                    if (!t1 || !t2) return t1 === t2;
                    const clean = t => t.toLowerCase().replace(/\s+/g, '').replace('over', '+').replace('under', '-');
                    return clean(t1) === clean(t2);
                };

                strategiesList.forEach((ranking, index) => {
                    const partiteByTip = ranking.partite_by_tip || ranking.matches || [];
                    const allPartite = Array.isArray(partiteByTip) ? partiteByTip : Object.values(partiteByTip).flat();
                    const isMagia = (ranking.name || '').toUpperCase().includes('MAGIA');

                    // Unified Stats (calculated for all strategies)
                    let vinte = 0, perse = 0, total = 0;

                    // Magia AI specific counts
                    let totalAI = 0, vinteAI = 0, perseAI = 0;
                    let totalCommon = 0, vinteAI_Common = 0, vinteBM_Common = 0;

                    allPartite.forEach(p => {
                        // Real-time Hydration
                        const matchKey = `${p.data}_${p.partita}`;
                        const latest = globalMatchesMap.get(matchKey);
                        if (latest) {
                            p.risultato = latest.risultato || p.risultato;
                            p.esito = latest.esito || p.esito;
                        }

                        // Determine Tip and Outcome for standard stats
                        const tip = (isMagia && p.magicStats?.tipMagiaAI) ? p.magicStats.tipMagiaAI : p.tip;
                        let outcome = p.esito;
                        if (p.risultato && tip) {
                            outcome = calculateOutcome({ tip: tip, risultato: p.risultato });
                        }

                        if (outcome === 'Vinto') vinte++;
                        else if (outcome === 'Perso') perse++;
                        if (outcome) total++;

                        // Magia Specific Branch
                        if (isMagia) {
                            const tipAI = p.magicStats?.tipMagiaAI || p.tip;
                            if (tipAI) {
                                totalAI++;
                                if (outcome === 'Vinto') vinteAI++;
                                else if (outcome === 'Perso') perseAI++;
                            }

                            const isCommon = p.risultato && !p.onlyMagia && p.originalDBTip;
                            if (isCommon) {
                                totalCommon++;
                                if (outcome === 'Vinto') vinteAI_Common++;

                                const tipBM = p.originalDBTip;
                                const outcomeBM = calculateOutcome({ tip: tipBM, risultato: p.risultato });
                                if (outcomeBM === 'Vinto') vinteBM_Common++;
                            }
                        }
                    });

                    const winRate = total > 0 ? ((vinte / total) * 100).toFixed(1) : 0;
                    const winRateAI_Total = totalAI > 0 ? ((vinteAI / totalAI) * 100).toFixed(1) : 0;
                    const winRateAI_Common = totalCommon > 0 ? ((vinteAI_Common / totalCommon) * 100).toFixed(1) : 0;
                    const winRateBM_Common = totalCommon > 0 ? ((vinteBM_Common / totalCommon) * 100).toFixed(1) : 0;

                    const card = document.createElement('div');
                    card.className = `p-4 rounded-xl border-2 cursor-pointer transition-all hover:shadow-xl hover:-translate-y-1 ${ranking.magic_type === 'gold' ? 'border-yellow-400 bg-yellow-50 shadow-sm' :
                        ranking.magic_type === 'silver' ? 'border-slate-300 bg-slate-50 shadow-sm' :
                            'border-indigo-100 bg-white hover:border-indigo-300 shadow-sm'
                        }`;

                    // RENDER CONTENT
                    // If Magia -> Triple Summary View
                    if (isMagia) {
                        card.innerHTML = `
                            <div class="flex justify-between items-start mb-4">
                                <div class="font-black text-slate-800 text-lg leading-tight truncate pr-2" title="${ranking.filtro_nome || ranking.name}">
                                    üîÆ ${ranking.filtro_nome || ranking.name || `Strategia ${index + 1}`}
                                </div>
                                <div class="text-[10px] px-2 py-1 rounded-full font-black uppercase tracking-widest ${ranking.magic_type === 'gold' ? 'bg-yellow-400 text-white' :
                                ranking.magic_type === 'silver' ? 'bg-slate-400 text-white' :
                                    'bg-indigo-600 text-white shadow-md shadow-indigo-100'}">
                                    ${ranking.magic_type || 'MAGIA'}
                                </div>
                            </div>
                            
                            <div class="grid grid-cols-1 gap-2 mb-4">
                                <!-- BOX VERDE: PARTITE COMUNI (AI + BM) -->
                                <div class="bg-gradient-to-br from-emerald-500 to-green-600 rounded-xl p-3 text-white shadow-lg border-b-4 border-green-700">
                                    <div class="text-[10px] font-black uppercase tracking-widest opacity-80 mb-2 flex items-center justify-between">
                                        <span>ü§ù PARTITE COMUNI</span>
                                        <span class="bg-white/20 px-2 py-0.5 rounded">${totalCommon}</span>
                                    </div>
                                    <div class="space-y-1">
                                        <div class="flex justify-between items-end border-b border-white/10 pb-1">
                                            <span class="text-[10px] font-bold uppercase">Vinte AI</span>
                                            <span class="font-black text-lg leading-none">${winRateAI_Common}% <span class="text-xs font-normal opacity-70">(${vinteAI_Common}/${totalCommon})</span></span>
                                        </div>
                                        <div class="flex justify-between items-end">
                                            <span class="text-[10px] font-bold uppercase">Vinte BM</span>
                                            <span class="font-black text-lg leading-none">${winRateBM_Common}% <span class="text-xs font-normal opacity-70">(${vinteBM_Common}/${totalCommon})</span></span>
                                        </div>
                                    </div>
                                </div>

                                <!-- BOX BLU: TOTALE AI -->
                                <div class="bg-gradient-to-br from-indigo-600 to-blue-700 rounded-xl p-3 text-white shadow-lg border-b-4 border-indigo-800">
                                    <div class="text-[10px] font-black uppercase tracking-widest opacity-80 mb-2 flex items-center justify-between">
                                        <span>ü§ñ TOTALE MAGIA AI</span>
                                        <span class="bg-white/20 px-2 py-0.5 rounded">${totalAI}</span>
                                    </div>
                                    <div class="flex justify-between items-end">
                                        <span class="text-[10px] font-bold uppercase">Vinte</span>
                                        <span class="font-black text-2xl leading-none">${winRateAI_Total}% <span class="text-sm font-normal opacity-70">(${vinteAI}/${totalAI})</span></span>
                                    </div>
                                </div>
                            </div>

                            <div class="flex items-center justify-between text-[11px] font-black text-indigo-600 pt-1">
                                <span class="text-slate-400 uppercase tracking-tighter">Ranking: #${index + 1}</span>
                                <span class="text-indigo-500">Dettagli Partite <i class="fa-solid fa-arrow-right-long ml-1"></i></span>
                            </div>
                        `;
                    } else {
                        // STANDARD VIEW
                        card.innerHTML = `
                            <div class="flex justify-between items-start mb-3">
                                <div class="font-bold text-gray-800 text-lg truncate pr-2" title="${ranking.filtro_nome || ranking.name}">${ranking.filtro_nome || ranking.name || `Strategia ${index + 1}`}</div>
                                <div class="text-xs px-2 py-1 rounded font-bold uppercase tracking-wider ${ranking.magic_type === 'gold' ? 'bg-yellow-200 text-yellow-800' :
                                ranking.magic_type === 'silver' ? 'bg-gray-200 text-gray-700' :
                                    'bg-purple-100 text-purple-700'
                            }">
                                    ${ranking.magic_type || 'STD'}
                                </div>
                            </div>
                            
                            <div class="grid grid-cols-3 gap-2 mb-3">
                                <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                    <div class="text-xs text-gray-500 uppercase">Partite</div>
                                    <div class="font-bold text-gray-800 text-lg">${allPartite.length}</div>
                                </div>
                                <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                    <div class="text-xs text-gray-500 uppercase">Win Rate</div>
                                    <div class="font-bold ${parseFloat(winRate) >= 70 ? 'text-green-600' : parseFloat(winRate) >= 50 ? 'text-blue-600' : 'text-orange-500'} text-lg">${winRate}%</div>
                                </div>
                                <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                    <div class="text-xs text-gray-500 uppercase">W / L</div>
                                    <div class="font-bold text-gray-800 text-lg">
                                        <span class="text-green-600">${vinte}</span> / <span class="text-red-500">${perse}</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="text-center text-xs text-purple-600 font-medium border-t border-purple-100 pt-2 mt-2">
                                Clicca per vedere le partite <i class="fa-solid fa-chevron-right ml-1"></i>
                            </div>
                        `;
                    }


                    // Add click listener to show matches
                    card.addEventListener('click', () => {
                        displayRankingMatches(ranking.name || `Strategia ${index}`, ranking, { strategies: { [index]: ranking } });
                        document.getElementById('pronostici-storico-list').classList.add('hidden');
                        const detailSection = document.getElementById('ranking-matches-detail');
                        detailSection.classList.remove('hidden');
                        document.getElementById('pronostici-ranking-section').classList.remove('hidden');
                        document.getElementById('ranking-strategies-list').classList.add('hidden');
                        document.getElementById('pronostici-storico-section').classList.add('hidden');

                        // Override back button behavior
                        const backBtn = document.getElementById('ranking-back-btn');
                        const newBackBtn = backBtn.cloneNode(true);
                        backBtn.parentNode.replaceChild(newBackBtn, backBtn);

                        newBackBtn.addEventListener('click', () => {
                            document.getElementById('ranking-matches-detail').classList.add('hidden');
                            document.getElementById('pronostici-ranking-section').classList.add('hidden');
                            document.getElementById('pronostici-storico-section').classList.remove('hidden');
                            document.getElementById('pronostici-storico-list').classList.remove('hidden');
                        });

                        // Add "Chiudi Storico" button to detail header
                        const stratHeader = document.getElementById('ranking-strategy-name');
                        stratHeader.classList.add('flex', 'items-center', 'justify-between', 'w-full');
                        stratHeader.innerHTML = `
                            <span>${ranking.name || ranking.filtro_nome}</span>
                            <button id="close-history-detail-btn" class="ml-auto bg-purple-500/50 hover:bg-purple-500 text-white w-8 h-8 rounded-full flex items-center justify-center transition-all" title="Chiudi e torna a oggi">
                                <i class="fa-solid fa-xmark"></i>
                            </button>
                        `;

                        document.getElementById('close-history-detail-btn').addEventListener('click', (e) => {
                            e.stopPropagation();
                            hideAllPronosticiSections();
                            document.getElementById('live-today-section').classList.remove('hidden'); // Show pool position
                            document.getElementById('pronostici-ranking-section').classList.remove('hidden');
                            document.getElementById('ranking-strategies-list').classList.remove('hidden');
                            document.getElementById('ranking-matches-detail').classList.add('hidden');
                        });
                    });

                    container.appendChild(card);
                });
            }

            // Helper function for displaying ranking matches
            function displayRankingMatches(stratId, strat, savedRankingData) {
                document.getElementById('ranking-strategy-name').textContent = strat.name;
                const container = document.getElementById('ranking-matches-container');
                container.innerHTML = '';

                const matches = strat.partite_by_tip || strat.matches || [];
                const allMatchesArray = Array.isArray(matches) ? matches : Object.values(matches).flat();

                // Hydration Map (using data+partita as key)
                const globalMatchesMap = new Map((window.allMatches || []).map(m => {
                    const key = `${m.data}_${m.partita}`;
                    return [key, m];
                }));

                if (allMatchesArray.length === 0) {
                    container.innerHTML = '<div class="text-gray-500 text-center py-8">Nessuna partita per questa strategia</div>';
                    document.getElementById('ranking-strategies-list').classList.add('hidden');
                    document.getElementById('ranking-matches-detail').classList.remove('hidden');
                    return;
                }

                // üî• SPECIAL HANDLING for MAGIA AI: Pre-calculate Stats for buttons
                const isMagiaPRO = (strat.name || '').toUpperCase().includes('MAGIA');
                let blockStats = null;
                let mergedList = [];

                if (isMagiaPRO) {
                    const targetDate = allMatchesArray[0]?.data;
                    const betminesMatches = (window.allMatches || []).filter(m => m.data === targetDate && m.tip);

                    const aiMatchesMap = new Map();
                    allMatchesArray.forEach(m => {
                        const key = m.fixtureId ? String(m.fixtureId) : `${m.data}_${m.partita}`;
                        aiMatchesMap.set(key, m);
                    });

                    const dbMatchesMap = new Map();
                    betminesMatches.forEach(m => {
                        const key = m.fixtureId ? String(m.fixtureId) : `${m.data}_${m.partita}`;
                        dbMatchesMap.set(key, m);
                    });

                    const allKeys = new Set([...aiMatchesMap.keys(), ...dbMatchesMap.keys()]);
                    blockStats = {
                        IT: { aiVinte: 0, aiTot: 0, bmVinte: 0, bmTot: 0 },
                        EU: { aiVinte: 0, aiTot: 0, bmVinte: 0, bmTot: 0 },
                        WORLD: { aiVinte: 0, aiTot: 0, bmVinte: 0, bmTot: 0 }
                    };

                    allKeys.forEach(key => {
                        const ai = aiMatchesMap.get(key);
                        const db = dbMatchesMap.get(key);
                        const m = ai || db;
                        const latest = globalMatchesMap.get(`${m.data}_${m.partita}`);
                        if (latest) {
                            m.risultato = latest.risultato || m.risultato;
                            m.esito = latest.esito || m.esito;
                            m.risultato_ht = latest.risultato_ht || m.risultato_ht;
                        }
                        if (db) {
                            m.originalDBTip = db.tip;
                            m.originalDBQuota = db.quota;
                            m.originalDBProb = db.probabilita;
                        }
                        if (m.risultato) {
                            const lega = (m.lega || '').toUpperCase();
                            const block = lega.includes('EU-ITA') ? 'IT' : (lega.includes('EU-') ? 'EU' : 'WORLD');
                            const tipAI = m.magicStats?.tipMagiaAI;
                            if (tipAI) {
                                blockStats[block].aiTot++;
                                if (calculateOutcome({ tip: tipAI, risultato: m.risultato }) === 'Vinto') blockStats[block].aiVinte++;
                            }
                            const tipBM = m.originalDBTip;
                            if (tipBM) {
                                blockStats[block].bmTot++;
                                if (calculateOutcome({ tip: tipBM, risultato: m.risultato }) === 'Vinto') blockStats[block].bmVinte++;
                            }
                        }
                        mergedList.push(m);
                    });

                    blockStats.TOTAL = {
                        aiVinte: blockStats.IT.aiVinte + blockStats.EU.aiVinte + blockStats.WORLD.aiVinte,
                        aiTot: blockStats.IT.aiTot + blockStats.EU.aiTot + blockStats.WORLD.aiTot,
                        bmVinte: blockStats.IT.bmVinte + blockStats.EU.bmVinte + blockStats.WORLD.bmVinte,
                        bmTot: blockStats.IT.bmTot + blockStats.EU.bmTot + blockStats.WORLD.bmTot
                    };

                    mergedList.sort((a, b) => {
                        const aShared = a.magicStats?.tipMagiaAI && a.originalDBTip;
                        const bShared = b.magicStats?.tipMagiaAI && b.originalDBTip;
                        if (aShared && !bShared) return -1;
                        if (!aShared && bShared) return 1;
                        return 0;
                    });
                }

                // üî• GEOGRAPHIC FILTER BAR (with Integrated Stats for Magia)
                const filterBar = document.createElement('div');
                filterBar.className = "bg-slate-50 border-b border-gray-200 p-3 flex flex-wrap items-center justify-center gap-2 sticky top-0 z-10 shadow-sm";

                const getBtnData = (blockKey) => {
                    if (!blockStats || !blockStats[blockKey]) return null;
                    const data = blockStats[blockKey];
                    const wrAI = data.aiTot > 0 ? (data.aiVinte / data.aiTot) : 0;
                    const wrBM = data.bmTot > 0 ? (data.bmVinte / data.bmTot) : 0;
                    return {
                        wrAI_perc: data.aiTot > 0 ? (wrAI * 100).toFixed(0) : '--',
                        wrBM_perc: data.bmTot > 0 ? (wrBM * 100).toFixed(0) : '--',
                        winning: wrAI >= wrBM && data.aiTot > 0
                    };
                };

                const getBtnInner = (label, blockKey) => {
                    const stats = getBtnData(blockKey);
                    if (!stats) return label;
                    return `
                        <div class="flex flex-col items-center">
                            <span class="mb-0.5 text-xs font-black uppercase">${label}</span>
                            <span class="text-[11px] font-black whitespace-nowrap">AI ${stats.wrAI_perc}% vs BM ${stats.wrBM_perc}%</span>
                        </div>
                    `;
                };

                const getBtnClass = (blockKey) => {
                    const base = "geo-filter-btn px-4 py-2 rounded-2xl text-xs font-black border transition-all flex items-center justify-center min-w-[120px]";
                    const stats = getBtnData(blockKey);
                    if (!stats) return `${base} bg-white text-slate-600 border-slate-200`;

                    if (stats.winning) {
                        return `${base} bg-gradient-to-br from-emerald-50 to-green-100 border-green-300 text-green-900 shadow-sm`;
                    } else {
                        return `${base} bg-gradient-to-br from-rose-50 to-red-100 border-red-300 text-red-900 shadow-sm`;
                    }
                };

                filterBar.innerHTML = `
                    <button onclick="window.filterGeografico('TUTTE')" id="filter-TUTTE" class="${getBtnClass('TOTAL')}">${getBtnInner('TUTTE', 'TOTAL')}</button>
                    <button onclick="window.filterGeografico('ITALIA')" id="filter-ITALIA" class="${getBtnClass('IT')}">${getBtnInner('ITALIA', 'IT')}</button>
                    <button onclick="window.filterGeografico('EUROPA')" id="filter-EUROPA" class="${getBtnClass('EU')}">${getBtnInner('EUROPA', 'EU')}</button>
                    <button onclick="window.filterGeografico('MONDO')" id="filter-MONDO" class="${getBtnClass('WORLD')}">${getBtnInner('MONDO', 'WORLD')}</button>
                `;
                container.appendChild(filterBar);


                const listContainer = document.createElement('div');
                listContainer.className = "divide-y divide-gray-100 bg-white";
                container.appendChild(listContainer);

                // Filter logic
                window.filterGeografico = (tag) => {
                    const cards = document.querySelectorAll('.geo-card');
                    const buttons = document.querySelectorAll('.geo-filter-btn');

                    buttons.forEach(btn => {
                        const isSelected = btn.id === `filter-${tag}`;
                        if (isSelected) {
                            btn.classList.add('ring-4', 'ring-indigo-400', 'ring-offset-2', 'scale-105');
                            btn.style.zIndex = "20";
                        } else {
                            btn.classList.remove('ring-4', 'ring-indigo-400', 'ring-offset-2', 'scale-105');
                            btn.style.zIndex = "10";
                        }
                    });

                    cards.forEach(card => {
                        const lega = card.dataset.lega || '';
                        if (tag === 'TUTTE') card.classList.remove('hidden');
                        else if (tag === 'ITALIA' && lega.includes('EU-ITA')) card.classList.remove('hidden');
                        else if (tag === 'EUROPA' && lega.includes('EU-') && !lega.includes('EU-ITA')) card.classList.remove('hidden');
                        else if (tag === 'MONDO' && !lega.includes('EU-')) card.classList.remove('hidden');
                        else card.classList.add('hidden');
                    });
                };

                if (isMagiaPRO) {
                    mergedList.forEach((m, idx) => {
                        const cardHtml = window.renderMagiaAICard(m, idx);
                        const temp = document.createElement('div');
                        temp.innerHTML = cardHtml.trim();
                        const card = temp.firstElementChild;
                        if (card) {
                            card.classList.add('geo-card');
                            card.dataset.lega = (m.lega || '').toUpperCase();
                            listContainer.appendChild(card);
                        }
                    });
                } else {

                    // Standard rendering for other strategies
                    allMatchesArray.forEach((m, idx) => {
                        // HYDRATE using data+partita key
                        const matchKey = `${m.data}_${m.partita}`;
                        const latest = globalMatchesMap.get(matchKey);
                        if (latest) {
                            m.risultato = latest.risultato || m.risultato;
                            m.esito = latest.esito || m.esito;
                            m.ora = latest.ora || m.ora;
                        }

                        const isMagiaStrategy = stratId === 'magia_ai' || (strat.name || '').toUpperCase().includes('MAGIA');
                        let cardHtml = '';
                        const SIMPLE_STRATEGIES = ['italia', 'all', 'top_eu', 'winrate_80'];

                        if (SIMPLE_STRATEGIES.includes(stratId)) {
                            cardHtml = window.renderSimpleStrategyCard(m, idx);
                        } else if (isMagiaStrategy) {
                            cardHtml = window.renderMagiaAICard(m, idx);
                        } else {
                            cardHtml = `
                                <div class="bg-white p-4 rounded-lg shadow border border-gray-200 mb-3">
                                    <div class="flex justify-between items-start">
                                        <div class="flex-1">
                                            <div class="font-bold text-gray-800 text-base mb-1">${m.partita}</div>
                                            <div class="text-[10px] text-gray-500 uppercase font-bold">${m.lega}</div>
                                        </div>
                                        <div class="text-right ml-4">
                                            <div class="text-xl font-black text-blue-600 leading-none">${m.tip}</div>
                                            <div class="text-xs text-gray-400 font-bold mt-1">@${m.quota}</div>
                                        </div>
                                    </div>
                                    ${m.risultato ? `
                                        <div class="mt-3 py-1.5 px-3 rounded-lg text-xs font-black text-center border-2 ${m.esito === 'Vinto' ? 'bg-green-50 border-green-200 text-green-700' : m.esito === 'Perso' ? 'bg-red-50 border-red-200 text-red-700' : 'bg-gray-50 border-gray-200 text-gray-600'}">
                                            RISULTATO: ${m.risultato} (${m.esito})
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        }

                        if (cardHtml) {
                            const temp = document.createElement('div');
                            temp.innerHTML = cardHtml.trim();
                            const newCard = temp.firstElementChild;
                            if (newCard) {
                                newCard.classList.add('geo-card');
                                newCard.dataset.lega = (m.lega || '').toUpperCase();
                                listContainer.appendChild(newCard);
                            }
                        }
                    });
                }

                document.getElementById('ranking-strategies-list').classList.add('hidden');
                document.getElementById('ranking-matches-detail').classList.remove('hidden');
            }

            // Back button for ranking
            const rankingBackBtn = document.getElementById('ranking-back-btn');
            if (rankingBackBtn) {
                rankingBackBtn.addEventListener('click', () => {
                    document.getElementById('ranking-strategies-list').classList.remove('hidden');
                    document.getElementById('ranking-matches-detail').classList.add('hidden');
                });
            }

            async function handleSaveClientFilter() {
                const selectedKey = document.getElementById('client-filters-select').value;
                if (!selectedKey) {
                    showModal("Errore", "Seleziona un filtro client da modificare.");
                    return;
                }

                const filter = allClientFilters[selectedKey];
                if (!filter) return;

                // Capture current state from UI
                const currentLeagues = Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value);
                const currentProb = probabilitySliderEl.noUiSlider.get().map(v => parseInt(v));
                const currentOdds = oddsSliderEl.noUiSlider.get().map(v => parseFloat(v));
                const currentTips = Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip);

                try {
                    if (filter.type === 'preset') {
                        // Save COMPLETE filter configuration (leagues, tips, odds, prob)
                        const presetsDocRef = doc(db, "system", "client_presets");

                        const completeFilter = {
                            leagues: currentLeagues,
                            tips: currentTips,
                            odds: currentOdds,
                            prob: currentProb
                        };

                        await updateDoc(presetsDocRef, {
                            [selectedKey]: completeFilter,
                            lastUpdated: Date.now()
                        });

                        // Show loading indicator
                        const saveBtn = document.querySelector('#save-btn-strategies');
                        if (saveBtn) {
                            saveBtn.disabled = true;
                            saveBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Ricalcolo in corso...';
                        }

                        // TRIGGER RECALCULATION: When preset is modified, recalculate rankings for today
                        console.log(`[Admin] Preset ${selectedKey} modified, triggering recalculation...`);
                        const today = new Date().toISOString().split('T')[0];
                        const todayMatches = allMatches.filter(m => m.data === today && !m.risultato);

                        if (todayMatches.length > 0) {
                            await loadAllMatches(); // Ensure we have latest data
                            if (typeof runStep1_MonteCarlo === 'function') {
                                await runStep1_MonteCarlo();
                                await runStep2_Distribution();
                                console.log(`[Admin] Rankings recalculated after preset modification`);
                            }
                        }

                        // Restore button
                        if (saveBtn) {
                            saveBtn.disabled = false;
                            saveBtn.innerHTML = '<i class="fa-solid fa-save mr-2"></i>Salva';
                        }

                    } else if (filter.type === 'strategy') {
                        // Update system/client_strategies
                        const strategiesDocRef = doc(db, "system", "client_strategies");

                        // Get the name from the EDIT field (allows renaming!)
                        const editNameInput = document.getElementById('edit-strategy-name');
                        const inputName = editNameInput ? editNameInput.value.trim() : '';
                        const finalName = inputName || filter.name || selectedKey.replace(/_/g, ' ').toUpperCase().trim();

                        const updatedStrategy = {
                            name: finalName,  // Uses input field name, allows renaming!
                            leagues: currentLeagues,
                            probRange: currentProb,
                            oddsRange: currentOdds,
                            tips: currentTips,
                            lastUpdated: Date.now()
                        };

                        await updateDoc(strategiesDocRef, {
                            [selectedKey]: updatedStrategy
                        });

                        // TRIGGER RECALCULATION: When custom strategy is modified, recalculate rankings
                        console.log(`[Admin] Custom strategy ${selectedKey} modified, triggering recalculation...`);
                        const today = new Date().toISOString().split('T')[0];
                        const todayMatches = allMatches.filter(m => m.data === today && !m.risultato);

                        if (todayMatches.length > 0) {
                            await loadAllMatches();
                            if (typeof runStep1_MonteCarlo === 'function') {
                                await runStep1_MonteCarlo();
                                await runStep2_Distribution();
                                console.log(`[Admin] Rankings recalculated after strategy modification`);
                            }
                        }
                    }

                    showModal("Successo", `Filtro < b > ${filter.name}</b > aggiornato e ranking ricalcolato!`);

                    // Reload to ensure local state is synced
                    await loadClientFiltersForAdmin();
                    document.getElementById('client-filters-select').value = selectedKey; // Restore selection

                } catch (e) {
                    console.error("Error saving client filter:", e);
                    showModal("Errore", `Impossibile salvare: ${e.message}`);
                }
            }

            async function handleDeleteClientFilter() {
                const selectedKey = document.getElementById('client-filters-select').value;
                if (!selectedKey) return;

                const filter = allClientFilters[selectedKey];
                if (!filter) return;

                if (!confirm(`Vuoi davvero cancellare "${filter.name}" ? `)) return;

                try {
                    let collectionName = "";

                    if (filter.type === 'preset') {
                        // Delete from client_presets
                        collectionName = "client_presets";
                        const presetsDocRef = doc(db, "system", "client_presets");
                        const presetsDoc = await getDoc(presetsDocRef);
                        const presets = presetsDoc.exists() ? presetsDoc.data() : {};
                        delete presets[selectedKey];
                        await setDoc(presetsDocRef, presets);
                    } else {
                        // Delete from client_strategies
                        collectionName = "client_strategies";
                        const strategiesDocRef = doc(db, "system", "client_strategies");
                        const strategiesDoc = await getDoc(strategiesDocRef);
                        const strategies = strategiesDoc.exists() ? strategiesDoc.data() : {};
                        delete strategies[selectedKey];
                        await setDoc(strategiesDocRef, strategies);
                    }

                    // ---------------------------------------------------------
                    // CLEANUP "GHOST" RESULTS (Cake Removal)
                    // Also remove this strategy's results from today's daily_strategies and rankings
                    // to prevent it from reappearing until next calculation (if ever).
                    try {
                        const today = new Date().toISOString().split('T')[0];

                        // 1. Clean daily_strategies
                        const dailyRef = doc(db, "daily_strategies", today);
                        const dailyDoc = await getDoc(dailyRef);
                        if (dailyDoc.exists()) {
                            const dailyData = dailyDoc.data();
                            if (dailyData.strategies && dailyData.strategies[selectedKey]) {
                                delete dailyData.strategies[selectedKey];
                                await setDoc(dailyRef, dailyData); // Overwrite update
                                console.log(`[Delete] Removed ${selectedKey} from daily_strategies / ${today}`);
                            }
                        }

                        // 2. Clean rankings (Optional, if structure allows)
                        // This is harder because rankings is an array. 
                        // But daily_strategies is the "Source of Truth" for the App.

                    } catch (cleanupErr) {
                        console.warn("Could not clean up daily results:", cleanupErr);
                    }
                    // ---------------------------------------------------------

                    showModal("Successo", `"${filter.name}" cancellato definitivamente!`);
                    await loadClientFiltersForAdmin();
                    document.getElementById('client-filters-select').value = '';
                } catch (e) {
                    console.error(e);
                    showModal("Errore", `Errore cancellazione: ${e.message}`);
                }
            }

            // Event Listeners for Client Filters
            document.getElementById('client-filters-select').addEventListener('change', handleClientFilterSelect);
            // document.getElementById('save-client-filter-btn').addEventListener('click', handleSaveClientFilter); // Removed in HTML
            document.getElementById('delete-client-filter-btn').addEventListener('click', handleDeleteClientFilter);


            // ==================== SAVED FILTERS (ADMIN) ====================
            async function loadSavedFilters() {
                const presetsCollection = collection(db, "presets");
                const snapshot = await getDocs(presetsCollection);
                savedFilters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data(), type: 'local' }));

                // Load Public Strategies for Ranking
                try {
                    const strategiesDoc = await getDoc(doc(db, "system", "client_strategies"));
                    if (strategiesDoc.exists()) {
                        const strategies = strategiesDoc.data();
                        Object.keys(strategies).forEach(key => {
                            savedFilters.push({
                                id: key,
                                name: strategies[key].name || key,
                                state: strategies[key], // Public strategy structure
                                type: 'public'
                            });
                        });
                    }
                } catch (e) {
                    console.error("Error loading public strategies for ranking:", e);
                }

                // Popola dropdown Dashboard (Local Only - kept as is for "Test Locale")
                const localFilters = savedFilters.filter(f => f.type === 'local');
                const select = document.getElementById('saved-strategies-select');
                if (select) {
                    select.innerHTML = '<option value="">Seleziona...</option>' + localFilters.map(f => `< option value = "${f.id}" > ${f.name}</option > `).join('');
                }

                // Popola dropdown Ranking con TUTTO (Local + Public + Special + Standard Presets)
                const rankingSelect = document.getElementById('ranking-filter-select');
                if (rankingSelect) {
                    // Fetch Standard Presets first
                    let standardPresets = [];
                    try {
                        const presetsDoc = await getDoc(doc(db, "system", "client_presets"));
                        if (presetsDoc.exists()) {
                            const data = presetsDoc.data();
                            standardPresets = Object.keys(data).map(key => ({
                                id: key,
                                name: data[key].name || key,
                                type: 'preset'
                            }));
                        }
                    } catch (e) {
                        console.error("Error loading standard presets:", e);
                    }

                    rankingSelect.innerHTML = '<option value="">Nessun filtro (tutte le partite)</option>' +
                        '<option value="BEST_05HT" style="background: linear-gradient(to right, #fef3c7, #fde68a); font-weight: bold;">‚ö° BEST 0.5 HT (Auto)</option>' +
                        standardPresets.map(f => `< option value = "${f.id}" >üîí ${f.name}</option > `).join('') +
                        savedFilters
                            .filter(f => !standardPresets.some(sp => sp.id === f.id)) // Deduplicate
                            .map(f => {
                                const icon = f.type === 'public' ? 'üåç' : 'üë§';
                                return `< option value = "${f.id}" > ${icon} ${f.name}</option > `;
                            }).join('');
                }
            }

            async function handlePublishStrategy() {
                const filterName = document.getElementById('new-strategy-name').value.trim();
                if (!filterName) {
                    showModal("Errore", "Inserisci nome strategia.", () => { });
                    return;
                }

                // Capture state
                const filterState = {
                    name: filterName,
                    leagues: Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value),
                    tips: Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip),
                    probRange: probabilitySliderEl.noUiSlider.get().map(v => parseInt(v)),
                    oddsRange: oddsSliderEl.noUiSlider.get().map(v => parseFloat(v)),
                    lastUpdated: Date.now()
                };

                try {
                    // Generate ID from name (sanitize)
                    const strategyId = filterName.toLowerCase().replace(/[^a-z0-9]/g, '_');

                    const strategiesDocRef = doc(db, "system", "client_strategies");
                    await setDoc(strategiesDocRef, {
                        [strategyId]: filterState
                    }, { merge: true });

                    // AUTO-RECALCOLA per le partite di oggi
                    const today = new Date().toISOString().split('T')[0];
                    const todayMatches = allMatches.filter(m => m.data === today && !m.risultato);

                    if (todayMatches.length > 0) {
                        console.log(`[handlePublishStrategy] Auto - recalc rankings for ${todayMatches.length} matches of today...`);
                        if (typeof runStep1_MonteCarlo === 'function') {
                            console.log(`[handlePublishStrategy] Auto-recalc via New Workflow...`);
                            await runStep1_MonteCarlo();
                            await runStep2_Distribution();
                            showModal("‚úÖ Strategia Pubblicata",
                                `Strategia "${filterName}" pubblicata e ranking aggiornato per ${todayMatches.length} partite di oggi!`);
                        }
                    } else {
                        showModal("Successo", `Strategia "${filterName}" pubblicata sul Client!`, () => { });
                    }

                    document.getElementById('new-strategy-name').value = '';
                    await loadClientFiltersForAdmin();
                    await loadSavedFilters(); // Reload to update savedFilters array
                } catch (e) {
                    console.error(e);
                    showModal("Errore", `Errore pubblicazione: ${e.message} `, () => { });
                }
            };

            async function handleSaveFilter() {
                const filterName = document.getElementById('local-strategy-name').value.trim();
                if (!filterName) {
                    showModal("Errore", "Inserisci un nome per la strategia.", () => { });
                    return;
                }

                // Capture current filter state
                const filterState = {
                    leagues: Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value),
                    tips: Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip),
                    prob: probabilitySliderEl.noUiSlider.get().map(v => parseInt(v)),
                    odds: oddsSliderEl.noUiSlider.get().map(v => parseFloat(v)),
                    startDate: filterDateStart.value,
                    endDate: filterDateEnd.value
                };

                try {
                    // Generate ID from name (sanitize)
                    const filterId = filterName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_' + Date.now();

                    // Save to presets collection (local, not public)
                    await setDoc(doc(db, "presets", filterId), {
                        name: filterName,
                        state: filterState,
                        createdAt: Date.now(),
                        published: false // NOT published to client
                    });

                    showModal("‚úÖ Strategia Salvata", `"${filterName}" salvata localmente! Puoi trovarla nel dropdown "Strategie Salvate".`, () => { });
                    document.getElementById('local-strategy-name').value = '';
                    await loadSavedFilters();
                } catch (e) {
                    console.error("Error saving local strategy:", e);
                    showModal("Errore", `Impossibile salvare: ${e.message} `, () => { });
                }
            }

            function handleLoadFilter() {
                const selectedId = document.getElementById('saved-strategies-select').value;
                if (!selectedId) return;
                const selectedFilter = savedFilters.find(f => f.id === selectedId);
                if (!selectedFilter) return;

                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));

                selectedFilter.state.leagues.forEach(league => {
                    const cb = leagueFiltersGrid.querySelector(`input.league-checkbox[value="${league}"]`);
                    if (cb) cb.checked = true;
                });
                selectedFilter.state.tips.forEach(tip => {
                    const btn = tipFiltersContainer.querySelector(`.tip-button[data-tip="${tip}"]`);
                    if (btn) btn.classList.add('active');
                });

                probabilitySliderEl.noUiSlider.set(selectedFilter.state.prob);
                oddsSliderEl.noUiSlider.set(selectedFilter.state.odds);
                filterDateStart.value = selectedFilter.state.startDate || '';
                filterDateEnd.value = selectedFilter.state.endDate || '';

                applyFiltersAndRender();
            }

            async function handleDeleteFilter() {
                const selectedId = document.getElementById('saved-strategies-select').value;
                if (!selectedId) {
                    showModal("Info", "Seleziona prima una strategia dal dropdown.");
                    return;
                }

                const selectedFilter = savedFilters.find(f => f.id === selectedId);
                if (!selectedFilter) return;

                if (!confirm(`Sei sicuro di voler eliminare la strategia "${selectedFilter.name}" ? `)) return;

                try {
                    await deleteDoc(doc(db, "presets", selectedId));
                    showModal("‚úÖ Eliminata", `Strategia "${selectedFilter.name}" eliminata con successo.`);
                    await loadSavedFilters();

                    // Reset dropdown
                    document.getElementById('saved-strategies-select').value = "";
                } catch (e) {
                    console.error("Error deleting filter:", e);
                    showModal("Errore", `Errore eliminazione: ${e.message} `);
                }
            }

            /* ==================== OLD TEST LABORATORY (REMOVED) ====================
             * The old test laboratory code has been completely replaced by the new
             * AI Strategy Laboratory. Old functions removed:
             * - initTestLaboratory, renderTestFilterOptions, renderTestStrategiesList
             * - loadTestStrategy, resetTestLaboratory, runTestSimulation
             * - renderTestResults, deleteTestStrategy, handleUpdateTestStrategy
             * - handlePublishTestToClient
             * All replaced by AI-powered strategy generation.
             ==================== END OLD LAB ==================== */


            // ==================== AI STRATEGY LABORATORY ====================

            let currentAIStrategy = null; // Stores AI-generated strategy data

            async function generateAIFilter() {
                const strategyName = document.getElementById('ai-strategy-name').value.trim();
                const aiPrompt = document.getElementById('ai-prompt').value.trim();

                if (!strategyName || !aiPrompt) {
                    showModal("Errore", "Inserisci nome strategia e prompt AI.");
                    return;
                }

                const btn = document.getElementById('generate-ai-filter-btn');
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>AI sta analizzando...';

                try {
                    // Prepara dati per l'AI
                    const leagueStats = calculateLeagueStats();

                    const systemPrompt = `Sei un esperto analista di betting calcistico e statistica sportiva.
Hai accesso a un database di ${allMatches.length} partite con risultati storici.

STATISTICHE LEGHE:
${JSON.stringify(leagueStats, null, 2)}

PROMPT UTENTE:
        "${aiPrompt}"

        TASK:
        1. Analizza le leghe secondo i criteri richiesti dall'utente
        2. Restituisci SOLO un array JSON con i nomi delle leghe selezionate
        3. Spiega brevemente il motivo della selezione

FORMATO RISPOSTA(OBBLIGATORIO):
        {
            "leagues": ["Premier League", "Bundesliga", ...],
                "explanation": "Breve spiegazione..."
        } `;

                    const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=AIzaSyD7aXUbEshUFsUnpIDR3ZO1tAIgMsb_zpc', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: systemPrompt }] }]
                        })
                    });

                    const data = await response.json();
                    const aiText = data.candidates[0].content.parts[0].text;

                    // Parse AI response
                    const jsonMatch = aiText.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) throw new Error("AI non ha restituito JSON valido");

                    const aiResult = JSON.parse(jsonMatch[0]);

                    currentAIStrategy = {
                        name: strategyName,
                        leagues: aiResult.leagues || [],
                        prompt: aiPrompt,
                        explanation: aiResult.explanation || "",
                        createdAt: Date.now()
                    };

                    // Mostra risultati
                    document.getElementById('ai-output').innerHTML = `
            < div class="mb-3" >
                            <div class="font-bold text-sm text-gray-700 mb-1">üßû Analisi AI:</div>
                            <div class="text-sm text-gray-600">${aiResult.explanation}</div>
                        </div >
            <div>
                <div class="font-bold text-sm text-gray-700 mb-2">‚úÖ Leghe Selezionate (${aiResult.leagues.length}):</div>
                <div class="flex flex-wrap gap-2">
                    ${aiResult.leagues.map(l => `<span class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full text-xs font-bold">${l}</span>`).join('')}
                </div>
            </div>
        `;

                    document.getElementById('ai-results-section').classList.remove('hidden');

                } catch (e) {
                    console.error('[AI Error]', e);
                    showModal("Errore AI", "Errore durante l'analisi: " + e.message);
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles mr-2"></i>GENERA FILTRO CON AI';
                }
            }

            function calculateLeagueStats() {
                const stats = {};
                allMatches.forEach(m => {
                    const league = m.lega;
                    if (!league) return;

                    if (!stats[league]) {
                        stats[league] = { total: 0, goals: [], wins: 0, losses: 0 };
                    }

                    stats[league].total++;

                    // Calcola gol (se disponibile risultato)
                    if (m.risultato) {
                        const [homeGoals, awayGoals] = m.risultato.split('-').map(g => parseInt(g) || 0);
                        stats[league].goals.push(homeGoals + awayGoals);
                    }

                    if (m.esito === 'Vinto') stats[league].wins++;
                    if (m.esito === 'Perso') stats[league].losses++;
                });

                // Calcola medie
                Object.keys(stats).forEach(league => {
                    const s = stats[league];
                    s.avgGoals = s.goals.length > 0 ? (s.goals.reduce((a, b) => a + b, 0) / s.goals.length).toFixed(2) : 0;
                    s.winRate = s.total > 0 ? ((s.wins / s.total) * 100).toFixed(1) : 0;
                });

                return stats;
            }

            async function runAIBacktest() {
                if (!currentAIStrategy) {
                    showModal("Errore", "Genera prima un filtro con l'AI");
                    return;
                }

                const tip = document.getElementById('ai-tip-select').value;
                const period = document.getElementById('ai-backtest-period').value;

                console.log('[AI Backtest] Running...', { tip, period, leagues: currentAIStrategy.leagues });

                // Filtra per periodo
                let matchesPool = allMatches;
                if (period !== 'all') {
                    const daysAgo = parseInt(period);
                    const cutoffDate = new Date();
                    cutoffDate.setDate(cutoffDate.getDate() - daysAgo);
                    const cutoffStr = cutoffDate.toISOString().split('T')[0];
                    matchesPool = allMatches.filter(m => m.data >= cutoffStr);
                }

                // Filtra per leghe AI + tip
                const filtered = matchesPool.filter(m => {
                    return currentAIStrategy.leagues.includes(m.lega) && m.tip === tip;
                });

                // Calcola statistiche
                const withResult = filtered.filter(m => m.esito && m.esito !== 'N/D' && m.esito !== 'N/A');
                const won = withResult.filter(m => m.esito === 'Vinto');
                const lost = withResult.filter(m => m.esito === 'Perso');
                const winRate = withResult.length > 0 ? ((won.length / withResult.length) * 100).toFixed(1) : 0;

                console.log('[AI Backtest] Results:', { total: withResult.length, won: won.length, lost: lost.length, winRate });

                // Salva risultati nel current strategy
                currentAIStrategy.tip = tip;
                currentAIStrategy.backtest = {
                    period,
                    matches: withResult.length,
                    won: won.length,
                    lost: lost.length,
                    winRate: parseFloat(winRate)
                };

                // Mostra risultati
                document.getElementById('backtest-matches').textContent = withResult.length;
                document.getElementById('backtest-won').textContent = won.length;
                document.getElementById('backtest-lost').textContent = lost.length;
                document.getElementById('backtest-winrate').textContent = winRate + '%';

                // Colora win rate
                const wrEl = document.getElementById('backtest-winrate');
                if (parseFloat(winRate) >= 60) {
                    wrEl.className = 'text-2xl font-black text-green-600';
                } else if (parseFloat(winRate) >= 50) {
                    wrEl.className = 'text-2xl font-black text-blue-600';
                } else {
                    wrEl.className = 'text-2xl font-black text-red-600';
                }

                document.getElementById('backtest-results-section').classList.remove('hidden');
            }

            async function saveAIStrategy() {
                if (!currentAIStrategy || !currentAIStrategy.backtest) {
                    showModal("Errore", "Esegui prima il backtest");
                    return;
                }

                try {
                    const strategyId = currentAIStrategy.name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_' + Date.now();

                    await setDoc(doc(db, "ai_strategies", strategyId), {
                        ...currentAIStrategy,
                        published: false,
                        aiGenerated: true
                    });

                    showModal("‚úÖ Salvata!", `Strategia "${currentAIStrategy.name}" salvata in staging.Win Rate: ${currentAIStrategy.backtest.winRate}% `);

                    loadAIStrategies();
                    resetAILab();

                } catch (e) {
                    console.error('[AI Save Error]', e);
                    showModal("Errore", "Impossibile salvare: " + e.message);
                }
            }

            function resetAILab() {
                currentAIStrategy = null;
                document.getElementById('ai-strategy-name').value = '';
                document.getElementById('ai-prompt').value = '';
                document.getElementById('ai-results-section').classList.add('hidden');
                document.getElementById('backtest-results-section').classList.add('hidden');
            }

            async function loadAIStrategies() {
                try {
                    const snapshot = await getDocs(collection(db, "ai_strategies"));
                    const strategies = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                    const listEl = document.getElementById('ai-strategies-list');
                    if (!listEl) {
                        // Element doesn't exist in new UI - skip silently
                        return;
                    }
                    if (strategies.length === 0) {
                        listEl.innerHTML = '<div class="text-center py-8 text-gray-400 text-sm">Nessuna strategia AI</div>';
                        return;
                    }

                    listEl.innerHTML = strategies.map(s => `
            < div class="p-3 bg-gradient-to-r from-purple-50 to-blue-50 rounded-xl border border-purple-200" >
                            <div class="flex items-center justify-between mb-2">
                                <div class="font-bold text-sm text-purple-700">${s.name}</div>
                                ${s.published ? '<span class="text-xs bg-green-500 text-white px-2 py-0.5 rounded">LIVE</span>' : '<span class="text-xs bg-gray-400 text-white px-2 py-0.5 rounded">STAGING</span>'}
                            </div>
                            <div class="text-xs text-gray-600 mb-1">${s.leagues?.length || 0} leghe</div>
                            ${s.backtest ? `<div class="text-xs font-bold ${s.backtest.winRate >= 60 ? 'text-green-600' : 'text-blue-600'}">WR: ${s.backtest.winRate}%</div>` : ''}
                        </div >
            `).join('');

                } catch (e) {
                    console.error('[AI Load Error]', e);
                }
            }

            // Event Listeners (with null checks for removed UI elements)
            document.getElementById('generate-ai-filter-btn')?.addEventListener('click', generateAIFilter);
            document.getElementById('run-ai-backtest-btn')?.addEventListener('click', runAIBacktest);
            document.getElementById('save-ai-strategy-btn')?.addEventListener('click', saveAIStrategy);
            document.getElementById('reset-ai-lab-btn')?.addEventListener('click', resetAILab);

            // Load AI strategies on page load
            if (db) loadAIStrategies();

            // Client Management Listeners
            document.getElementById('update-client-filter-btn').addEventListener('click', handleSaveClientFilter);

            // ==================== RESET FILTERS ====================
            resetLeaguesBtn.addEventListener('click', () => {
                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                applyFiltersAndRender();
            });

            resetTipsBtn.addEventListener('click', () => {
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));
                applyFiltersAndRender();
            });

            resetFiltersBtn.addEventListener('click', () => {
                filterDateStart.value = '';
                filterDateEnd.value = '';
                searchInput.value = '';
                resetLeaguesBtn.click();
                resetTipsBtn.click();
                probabilitySliderEl.noUiSlider.set([0, 100]);
                oddsSliderEl.noUiSlider.set([1.0, 10.0]);
                document.getElementById('saved-strategies-select').value = ""; // Reset Local Dropdown
                document.getElementById('client-filters-select').value = ""; // Reset Public Dropdown
                applyFiltersAndRender();
            });

            // ==================== EXPORT ====================
            exportFilteredBtn.addEventListener('click', () => {
                if (filteredMatches.length === 0) {
                    showModal("Errore", "Nessun dato da esportare.", () => { });
                    return;
                }
                const headers = ['id', 'data', 'lega', 'partita', 'risultato', 'probabilita', 'mercato', 'tip', 'quota', 'esito'];
                const csv = Papa.unparse(filteredMatches.map(d => ({ ...d, quota: String(d.quota).replace('.', ',') })), { columns: headers });
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = 'tipster_filtrati.csv';
                link.click();
            });

            // ==================== TARGET ODDS SYSTEM ====================

            // Estrai odds da info_ht
            function extractHtOdds(infoHt) {
                if (!infoHt || infoHt.trim() === '') return null;

                const oddsMatch = infoHt.match(/(\d+)%/);
                if (oddsMatch) {
                    return parseFloat(oddsMatch[1]);
                }
                return null;
            }

            // Stima range odds basato su correlazioni
            function estimateOddsRange(tipAttuale, oddsAttuale, tipTarget) {
                // Trova range nella lookup table
                const correlations = ODDS_CORRELATIONS[tipAttuale]?.[tipTarget];
                if (!correlations) {
                    // Fallback: calcolo matematico
                    const probAttuale = 1 / oddsAttuale;
                    const probTarget = probAttuale * 0.70; // Stima conservativa
                    const oddsTarget = 1 / probTarget;

                    return {
                        min: Math.round((oddsTarget * 0.90) * 100) / 100,
                        max: Math.round((oddsTarget * 1.10) * 100) / 100,
                        avg: oddsTarget
                    };
                }

                // Cerca range corretto
                for (let range in correlations) {
                    const [minRange, maxRange] = range.split('-').map(Number);
                    if (oddsAttuale >= minRange && oddsAttuale <= maxRange) {
                        const [minOdds, maxOdds] = correlations[range];
                        return {
                            min: minOdds,
                            max: maxOdds,
                            avg: (minOdds + maxOdds) / 2
                        };
                    }
                }

                // Fallback se non trovato range esatto
                const probAttuale = 1 / oddsAttuale;
                const probTarget = probAttuale * 0.70;
                const oddsTarget = 1 / probTarget;

                return {
                    min: Math.round((oddsTarget * 0.90) * 100) / 100,
                    max: Math.round((oddsTarget * 1.10) * 100) / 100,
                    avg: oddsTarget
                };
            }

            // Calcola green con odds precise
            function calculateGreen(backStake, backOdds, layOdds) {
                const liability = backStake * (layOdds - 1);
                const backProfit = backStake * (backOdds - 1);

                // Green se lay vince (back perde)
                const greenLay = liability;
                // Green se back vince (lay perde) 
                const greenBack = backProfit - liability;

                // Usa il minore per essere conservativi
                return Math.min(greenLay, greenBack);
            }

            // Calcola green range con odds stimate
            function calculateGreenRange(backStake, backOdds, layOddsMin, layOddsMax) {
                const greenMin = calculateGreen(backStake, backOdds, layOddsMin);
                const greenMax = calculateGreen(backStake, backOdds, layOddsMax);

                return {
                    min: greenMin,
                    max: greenMax,
                    avg: (greenMin + greenMax) / 2
                };
            }

            // ==================== MATCH TIMES SYSTEM ====================

            // Carica cache orari da Firebase
            // Ottieni orario da API Football
            async function getTimeFromAPIFootball(date, teamHome, teamAway) {
                if (apiCallsToday >= 90) {
                    console.warn("API call limit reached today");
                    return null;
                }

                try {
                    const response = await fetch(`${API_FOOTBALL_URL}/fixtures?date=${date}&team=${teamHome}`, {
                        headers: {
                            'x-rapidapi-key': API_FOOTBALL_KEY,
                            'x-rapidapi-host': 'v3.api-football.com'
                        }
                    });

                    if (!response.ok) {
                        console.error("API Football error:", response.status);
                        return null;
                    }

                    const data = await response.json();
                    apiCallsToday++;

                    if (data.response && data.response.length > 0) {
                        // Carica da DB locale (IndexedDB / JSON)
                        // Se USE_LOCAL_DB_ONLY = true, carichiamo solo da qui
                        if (window.USE_LOCAL_DB_ONLY) {
                            // ... existing loading code ...
                        }

                        // MOCK o REAL LOAD
                        // ... (Load logic stays same) ...

                        // AUTO-FIX DATES (Critical for Legacy Data)
                        // Se i dati hanno formato 16/12/2025, li convertiamo in 2025-12-16
                        let fixCount = 0;
                        window.allMatches.forEach(m => {
                            if (m.data && m.data.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
                                const [day, month, year] = m.data.split('/');
                                m.data = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                                fixCount++;
                            }
                        });

                        if (fixCount > 0) {
                            console.log(`[DataFix] Corrette ${fixCount} date dal formato IT al formato ISO.`);
                            // Salviamo la correzione per il futuro
                            if (window.USE_LOCAL_DB_ONLY) {
                                try {
                                    await LocalDB.saveMatches(window.allMatches);
                                    console.log("[DataFix] Date corrette salvate nel DB Locale.");
                                } catch (e) { console.warn("Auto-save failed", e); }
                            }
                        }
                        // Cerca match che contiene entrambe le squadre
                        const match = data.response.find(m => {
                            const home = normalizeKey(m.teams.home.name);
                            const away = normalizeKey(m.teams.away.name);
                            const searchHome = normalizeKey(teamHome);
                            const searchAway = normalizeKey(teamAway);

                            return (home.includes(searchHome) || searchHome.includes(home)) &&
                                (away.includes(searchAway) || searchAway.includes(away));
                        });

                        if (match && match.fixture && match.fixture.date) {
                            // Converti UTC a ora italiana (UTC+1 o UTC+2)
                            const utcDate = new Date(match.fixture.date);
                            const italianTime = new Date(utcDate.getTime() + (2 * 60 * 60 * 1000)); // UTC+2 per ora solare

                            const hours = String(italianTime.getHours()).padStart(2, '0');
                            const minutes = String(italianTime.getMinutes()).padStart(2, '0');

                            return `${hours}:${minutes}`;
                        }
                    }

                    return null;
                } catch (e) {
                    console.error("API Football fetch error:", e);
                    return null;
                }
            }

            // Ottieni orario match (usa cache -> API)
            async function getMatchTime(date, match) {
                // 1. Prova cache Firebase
                const cached = getTimeFromCache(date, match);
                if (cached) return cached;

                // 2. Prova bulk cache (localStorage)
                const bulkTime = getTimeFromBulkCache(date, match);
                if (bulkTime) {
                    // Salva in cache Firebase per prossime volte
                    await saveTimeToCache(date, match, bulkTime);
                    return bulkTime;
                }

                // 3. Fallback: chiamata API singola (non dovrebbe servire)
                const teams = match.split(' - ');
                if (teams.length !== 2) return null;

                const teamHome = teams[0].trim();
                const teamAway = teams[1].trim();

                const time = await getTimeFromAPIFootball(date, teamHome, teamAway);

                if (time) {
                    await saveTimeToCache(date, match, time);
                }

                return time;
            }

            // ==================== POISSON ODDS CALCULATOR ====================

            // Calcola probabilit√† Poisson
            window.poissonProbability = function (lambda, k) {
                let prob = Math.exp(-lambda);
                for (let i = 1; i <= k; i++) {
                    prob *= lambda / i;
                }
                return prob;
            }

            // Stima lambda da quota esistente
            window.estimateLambda = function (tip, quota, prob) {
                // Usa probabilit√† reale per calcolo accurato
                const impliedProb = prob / 100;

                // Calcolo matematico basato su distribuzione Poisson
                if (tip === '+0.5') {
                    // P(X >= 1) = impliedProb
                    // Lambda = -ln(1 - impliedProb)
                    return -Math.log(1 - impliedProb);
                } else if (tip === '+1.5') {
                    // P(X >= 2) = impliedProb
                    // Approssimazione: lambda ‚âà 1.5 + (impliedProb - 0.5) * 3
                    const baseLambda = 2.0;
                    const adjustment = (impliedProb - 0.75) * 2;
                    return Math.max(1.5, Math.min(4.0, baseLambda + adjustment));
                } else if (tip === '+2.5') {
                    const baseLambda = 3.0;
                    const adjustment = (impliedProb - 0.60) * 2;
                    return Math.max(2.5, Math.min(5.0, baseLambda + adjustment));
                } else if (tip === '+3.5') {
                    const baseLambda = 4.0;
                    const adjustment = (impliedProb - 0.45) * 2;
                    return Math.max(3.5, Math.min(6.0, baseLambda + adjustment));
                }

                // Default fallback
                return 2.5;
            }

            // Calcola quota target con Poisson
            window.calculatePoissonOdds = function (tipCurrent, quotaCurrent, probCurrent, tipTarget) {
                const lambda = window.estimateLambda(tipCurrent, quotaCurrent, probCurrent);

                let targetProb = 0;

                if (tipTarget === '+0.5') {
                    // P(X >= 1) = 1 - P(X = 0)
                    targetProb = 1 - window.poissonProbability(lambda, 0);
                } else if (tipTarget === '+1.5') {
                    // P(X >= 2) = 1 - P(X=0) - P(X=1)
                    targetProb = 1 - window.poissonProbability(lambda, 0) - window.poissonProbability(lambda, 1);
                } else if (tipTarget === '+2.5') {
                    // P(X >= 3)
                    targetProb = 1 - window.poissonProbability(lambda, 0) - window.poissonProbability(lambda, 1) - window.poissonProbability(lambda, 2);
                } else if (tipTarget === '+3.5') {
                    // P(X >= 4)
                    let sum = 0;
                    for (let k = 0; k <= 3; k++) {
                        sum += window.poissonProbability(lambda, k);
                    }
                    targetProb = 1 - sum;
                } else if (tipTarget === '-2.5') {
                    // P(X < 3) = P(X=0) + P(X=1) + P(X=2)
                    targetProb = window.poissonProbability(lambda, 0) + window.poissonProbability(lambda, 1) + window.poissonProbability(lambda, 2);
                }

                if (targetProb <= 0 || targetProb >= 1) return null;

                const targetOdds = 1 / targetProb;

                return {
                    odds: targetOdds,
                    prob: Math.round(targetProb * 100),
                    source: 'poisson'
                };
            }

            // ==================== AI TRADING ADVISOR ====================

            // V3.4.5.1 - BOLLINO TRADING SPORTIVO INTELLIGENTE
            // ==================== TRADING INDICATIONS ====================
            function getTradingIndication(score, quota) {
                if (score >= 85) return { text: "üíé DIAMOND", color: "text-blue-400", bg: "bg-blue-900/50" };
                if (score >= 75) return { text: "‚úÖ VALUE", color: "text-green-400", bg: "bg-green-900/50" };
                if (score >= 60) return { text: "‚öñÔ∏è BALANCED", color: "text-yellow-400", bg: "bg-yellow-900/50" };
                return { text: "‚ö†Ô∏è RISKY", color: "text-red-400", bg: "bg-red-900/50" };
            }

            // ==================== FILTER MATCHES HELPER ====================
            function filterMatchesByStrategy(matches, filter) {
                if (!filter) return matches;
                console.log(`[FilterDebug] Testing strategy: ${filter.name || 'unnamed'}`, {
                    targetLeaguesCount: filter.leagues?.length || 0,
                    targetTips: filter.tips
                });

                return matches.filter(m => {
                    // 1. Leagues
                    if (filter.leagues && filter.leagues.length > 0) {
                        const matchLega = normalizeLega(m.lega);
                        const isIncluded = filter.leagues.includes(matchLega);

                        // Debug specifico per winrate_80 o se sospettiamo infiltrazioni
                        if (filter.type === 'winrate_80' || !isIncluded) {
                            // console.log(`[FilterDebug] ${m.partita} | Lega: ${matchLega} | Included: ${isIncluded}`);
                        }

                        if (!isIncluded) return false;
                    }
                    // 2. Tips
                    if (filter.tips && filter.tips.length > 0) {
                        if (!filter.tips.includes(m.tip)) return false;
                    }
                    // 3. Odds
                    if (filter.odds && Array.isArray(filter.odds)) {
                        const q = parseFloat(m.quota);
                        if (q < filter.odds[0] || q > filter.odds[1]) return false;
                    }
                    // 4. Prob
                    if (filter.prob && Array.isArray(filter.prob)) {
                        const p = parseFloat(m.probabilita);
                        if (!isNaN(p)) {
                            if (p < filter.prob[0] || p > filter.prob[1]) return false;
                        }
                    }
                    return true;
                });
            }

            // MOVED TO js/engine.js: generateTradingBadge

            // ==================== TOOLTIP SYSTEM ====================

            function generateScoreTooltip(match, scoreDetails) {
                return `
                    <div class="text-left">
                        <div class="font-bold mb-2 text-center">SCORE BREAKDOWN</div>
                        <div class="text-sm space-y-1">
                            <div>Lega: <span class="font-semibold">+${scoreDetails.legaScore || 0}</span></div>
                            <div>Tip: <span class="font-semibold">+${scoreDetails.tipScore || 0}</span></div>
                            <div>Prob: <span class="font-semibold">+${scoreDetails.probScore || 0}</span> (${match.probabilita}%)</div>
                            ${scoreDetails.htBonus ? `<div>HT Boost: <span class="font-semibold text-green-600">+${scoreDetails.htBonus}</span></div>` : ''}
                            <div class="border-t pt-1 mt-1">Totale: <span class="font-bold text-lg">${scoreDetails.totalScore || 0}</span></div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t text-gray-600">
                            <div>80+ = ECCELLENTE üî•</div>
                            <div>60-79 = BUONO ‚ö°</div>
                            <div>40-59 = MEDIO üí°</div>
                            <div>&lt;40 = BASSO ‚ö†Ô∏è</div>
                        </div>
                    </div>
                `;
            }

            function generateStatsTooltip(homeWins, awayWins) {
                const homeColor = homeWins >= 7 ? 'üü¢' : homeWins >= 4 ? 'üü°' : 'üî¥';
                const awayColor = awayWins >= 7 ? 'üü¢' : awayWins >= 4 ? 'üü°' : 'üî¥';

                return `
                    <div class="text-left">
                        <div class="font-bold mb-2 text-center">FORM SQUADRE</div>
                        <div class="text-sm space-y-1">
                            <div>${homeColor} Casa: <span class="font-semibold">${homeWins} W</span> ultimi 10</div>
                            <div>${awayColor} Trasferta: <span class="font-semibold">${awayWins} W</span> ultimi 10</div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t text-gray-600">
                            <div>üü¢ 7+ = OTTIMA</div>
                            <div>üü° 4-6 = MEDIA</div>
                            <div>üî¥ 0-3 = SCARSA</div>
                        </div>
                    </div>
                `;
            }

            // ==================== HT MERGE FUNCTIONS ====================
            function normalizeKey(str) {
                // Normalizza stringa per matching squadre (rimuove accenti, lowercase, solo alfanumerici)
                return str.normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "")
                    .toLowerCase()
                    .replace(/[^a-z0-9]/g, "");
            }

            function mergeMainWithHT() {
                // Se non ho dati main, non posso fare merge
                if (rawMainData.length === 0) return rawMainData;

                // Se non ho dati HT, ritorno main senza modifiche
                if (rawHtData.length === 0) return rawMainData;

                // Creo mappa HT: chiave = squadre normalizzate
                const htMap = {};
                rawHtData.forEach(htRow => {
                    const partita = String(htRow.Partita || '').trim();
                    if (!partita) return;

                    // Normalizzo nome partita (Home + Away senza spazi/accenti)
                    const normalized = normalizeKey(partita);

                    // Salvo prob e quota HT
                    const probHT = parseInt(String(htRow['Probabilit√†'] || htRow.Probabilit√† || '0').replace('%', '').trim()) || 0;
                    const quotaHT = parseFloat(String(htRow.Quota || '0').replace(',', '.').trim()) || 0;

                    if (probHT > 0 && quotaHT > 0) {
                        htMap[normalized] = { prob: probHT, quota: quotaHT.toFixed(2) };
                    }
                });

                // Arricchisco Main con info HT
                return rawMainData.map(mainRow => {
                    const partita = String(mainRow.Partita || '').trim();
                    const normalized = normalizeKey(partita);

                    // Cerco match in HT map
                    if (htMap[normalized]) {
                        const htInfo = htMap[normalized];
                        mainRow.info_ht = `${htInfo.prob}% (@${htInfo.quota})`;
                    } else {
                        mainRow.info_ht = '';
                    }

                    return mainRow;
                });
            }

            // ==================== UPLOAD TIPS ====================
            document.getElementById('tips-csv-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;

                // Mostra feedback visivo
                const statusEl = document.getElementById('tips-file-status');
                const nameEl = document.getElementById('tips-file-name');
                statusEl.classList.remove('hidden');
                nameEl.textContent = file.name;

                const reader = new FileReader();
                reader.onload = async function (event) {
                    // Mostra clessidra
                    showCsvLoadingOverlay('Caricamento TIPS...');

                    const parsed = parseCSV(event.target.result);
                    tipsFileCount = parsed.length; // UPDATE GLOBAL COUNT
                    const matchDate = document.getElementById('tips-date').value;
                    if (!matchDate) {
                        hideCsvLoadingOverlay();
                        alert('Seleziona data!');
                        return;
                    }

                    // Salvo in rawMainData
                    rawMainData = parsed;

                    // Faccio merge con HT se disponibile
                    const mergedData = mergeMainWithHT();

                    // Conta quante partite hanno HT dopo merge
                    const htCount = mergedData.filter(m => m.info_ht && m.info_ht.trim() !== '').length;
                    if (htCount > 0) {
                        htFileCount = htCount; // Use matched count if available
                        const htStatusEl = document.getElementById('ht-file-status');
                        const htCountEl = document.getElementById('ht-match-count');
                        htStatusEl.classList.remove('hidden');
                        htCountEl.textContent = htCount;
                    }

                    // Processo i dati merged
                    await processAndPreviewCSV(mergedData, matchDate, 'tips');

                    // Nascondi clessidra
                    hideCsvLoadingOverlay();
                };
                reader.readAsText(file);
            });

            // ==================== UPLOAD HT ====================
            document.getElementById('tips-ht-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) {
                    // Se rimuovo file HT, resetto
                    rawHtData = [];
                    document.getElementById('ht-file-status').classList.add('hidden');
                    return;
                }

                // Mostra feedback visivo
                const statusEl = document.getElementById('ht-file-status');
                const nameEl = document.getElementById('ht-file-name');
                const countEl = document.getElementById('ht-match-count');
                statusEl.classList.remove('hidden');
                nameEl.textContent = file.name;

                const reader = new FileReader();
                reader.onload = async function (event) {
                    // Mostra clessidra
                    showCsvLoadingOverlay('Caricamento HT...');

                    const parsed = parseCSV(event.target.result);

                    // Salvo in rawHtData
                    rawHtData = parsed;
                    htFileCount = parsed.length; // UPDATE GLOBAL COUNT
                    countEl.textContent = parsed.length;

                    // Se ho gi√† caricato Main, rifaccio merge
                    if (rawMainData.length > 0) {
                        const matchDate = document.getElementById('tips-date').value;
                        if (matchDate) {
                            const mergedData = mergeMainWithHT();

                            // Conta quante partite hanno HT dopo merge
                            const htCount = mergedData.filter(m => m.info_ht && m.info_ht.trim() !== '').length;
                            htFileCount = htCount; // Use matched count
                            countEl.textContent = htCount;

                            await processAndPreviewCSV(mergedData, matchDate, 'tips');
                        }
                    }

                    // Nascondi clessidra
                    hideCsvLoadingOverlay();
                };
                reader.readAsText(file);
            });

            // ==================== UPLOAD RISULTATI ====================
            document.getElementById('results-csv-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async function (event) {
                    const parsed = parseCSV(event.target.result);
                    const matchDate = document.getElementById('results-date').value;
                    if (!matchDate) {
                        alert('Seleziona data!');
                        return;
                    }
                    await processAndPreviewCSV(parsed, matchDate, 'results');
                };
                reader.readAsText(file);
            });

            // üî• NEW v12.28: Auto-Sync Results API Listener
            document.getElementById('auto-sync-results-btn')?.addEventListener('click', autoSyncResultsFromAPI);

            // üî• NEW v13.0: Magia AI World Domination Button
            document.getElementById('load-magia-ai-btn')?.addEventListener('click', loadMagiaAIWorkflow);
            document.getElementById('view-magia-ai-btn')?.addEventListener('click', viewMagiaAIResults);
            document.getElementById('download-magia-ai-btn')?.addEventListener('click', downloadMagiaAICSV);

            // ==================== UPLOAD BACKUP / TOTALE ====================
            document.getElementById('backup-csv-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;

                const statusEl = document.getElementById('backup-file-status');
                const nameEl = document.getElementById('backup-file-name');
                const previewEl = document.getElementById('backup-upload-preview');

                statusEl.classList.remove('hidden');
                nameEl.textContent = file.name;
                previewEl.classList.remove('hidden');
                previewEl.innerHTML = '<div class="text-center text-gray-500"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Analisi file in corso...</div>';

                const reader = new FileReader();
                reader.onload = async function (event) {
                    const parsed = parseCSV(event.target.result);
                    await processBackupData(parsed);
                };
                reader.readAsText(file);
            });

            async function processBackupData(parsedData) {
                const previewEl = document.getElementById('backup-upload-preview');

                // MODALIT√Ä LOCALE: Carica in memoria e basta
                if (window.USE_LOCAL_DB_ONLY) {
                    console.log("[Local Mode] Loading matches into memory...");

                    let loadedCount = 0;
                    const newMatches = [];
                    // Usiamo window.normalizeLega definito globalmente da engine.js o fallback
                    const normalizeLega = window.normalizeLega || ((str) => String(str || '').trim().toLowerCase());

                    // DEBUG: Check first row keys
                    if (parsedData.length > 0) {
                        console.log("[Local Mode] First row keys:", Object.keys(parsedData[0]));
                        console.log("[Local Mode] First row content:", parsedData[0]);
                    }

                    for (const row of parsedData) {
                        // Relaxed check: case-insensitive keys
                        // CSV headers found: id,data,lega,partita,risultato,probabilita,mercato,tip,quota,esito,info_ht

                        // Clean keys (remove BOM or whitespace)
                        const cleanRow = {};
                        Object.keys(row).forEach(k => {
                            // Remove BOM, quotes, whitespace, convert to lowercase
                            let cleanKey = k.trim().replace(/^[\uFEFF\s]+/, '').replace(/['"]/g, '').toLowerCase();
                            cleanRow[cleanKey] = row[k];
                        });

                        // Log rare keys for debug
                        if (loadedCount === 0) console.log("[Local Mode] Cleaned keys:", Object.keys(cleanRow));

                        const lega = cleanRow.lega || cleanRow.league;
                        const partita = cleanRow.partita || cleanRow.match;

                        if (!lega && !partita) {
                            // Only log first 5 skipped to avoid spam
                            if (parsedData.indexOf(row) < 5) console.warn("[Local Mode] Skipped row (missing Lega/Partita):", cleanRow);
                            continue;
                        }

                        const fixtureId = String(cleanRow.fixtureid || cleanRow.fixture_id || cleanRow.fixtureId || cleanRow.id || '').trim();

                        const matchData = {
                            id: fixtureId,
                            data: cleanRow.data || cleanRow.date || '',
                            leagueId: parseInt(cleanRow.leagueid || cleanRow.leagueId || cleanRow.league_id || '') || undefined, // üî• NEW: Import leagueId
                            lega: normalizeLega(lega),
                            partita: String(partita).trim(),
                            risultato: String(cleanRow.risultato || cleanRow.result || parseInt(cleanRow.risultato) || '').trim(), // Handle weird result formats
                            risultato_ht: String(cleanRow.risultato_ht || '').trim(), // NEW: Actual HT Score (separatato da info_ht)
                            probabilita: parseInt(String(cleanRow.probabilita || cleanRow.probability || '0').replace('%', '').trim()) || 0,
                            mercato: String(cleanRow.mercato || cleanRow.market || '').trim(),
                            tip: String(cleanRow.tip || '').trim(),
                            quota: parseFloat(String(cleanRow.quota || cleanRow.odds || '0').replace(',', '.').trim()) || 0,
                            esito: String(cleanRow.esito || cleanRow.status || cleanRow['esito'] || '').trim(), // Explicit check
                            info_ht: String(cleanRow.info_ht || '').trim(),
                            fixtureId: fixtureId,
                            magia: String(cleanRow.magia || '').trim() || undefined // üî• NEW: Persist Magia status (AI/OK)
                        };
                        newMatches.push(matchData);
                        loadedCount++;
                    }

                    // Save to global memory
                    allMatches = newMatches;
                    window.allMatches = newMatches; // Explicit sync for other functions

                    // PERSIST: Save to IndexedDB using manager
                    try {
                        await window.LocalDB.saveMatches(newMatches);
                        console.log("[Local Mode] Matches persisted to IndexedDB (v2)");
                    } catch (e) {
                        console.error("[Local Mode] Persistence failed", e);
                        alert("‚ö†Ô∏è Attenzione: I dati sono in memoria ma il salvataggio locale √® fallito. Se ricarichi, li perderai.");
                    }

                    // Update UI
                    document.getElementById('matches-count').textContent = `Locale (${loadedCount})`;
                    updateStatsDisplay(newMatches);
                    // renderDistributionChart(); // Function not implemented

                    previewEl.innerHTML = `
                        <div class="bg-green-100 p-4 rounded-lg text-center">
                            <i class="fa-solid fa-check-circle text-green-600 text-3xl mb-2"></i>
                            <h3 class="text-xl font-bold text-green-800">Database Locale Caricato!</h3>
                            <p class="text-green-700">${loadedCount} partite pronte in memoria.</p>
                            <p class="text-sm text-gray-500 mt-2">Nessun dato inviato a Firebase.</p>
                        </div>
                    `;

                    alert(`Caricate ${loadedCount} partite in modalit√† locale! Puoi procedere col calcolo strategie.`);
                    return;
                }

                // MODALIT√Ä ONLINE (Vecchio codice)
                let updates = 0;
                let creates = 0;
                let errors = 0;
                const batchOps = [];

                // Normalizza chiavi per confronto
                const normalizeKey = (str) => String(str || '').trim().toLowerCase().replace(/\s+/g, ' ');

                // Normalizza una data in formato YYYY-MM-DD
                const normalizeDate = (d) => {
                    const str = String(d || '').trim();
                    // Gestisci DD/MM/YYYY
                    if (str.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
                        const [day, month, year] = str.split('/');
                        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                    }
                    // Gestisci YYYY-MM-DD
                    if (str.match(/^\d{4}-\d{2}-\d{2}$/)) {
                        return str;
                    }
                    return str; // Fallback
                };

                for (const row of parsedData) {
                    // Skip empty rows
                    if (!row.Lega || !row.Partita) continue;

                    const normalizedLega = normalizeLega(row.lega || row.Lega);

                    // üî• ID ONLY RULE: Resolve leagueId from Registry
                    let leagueId = null;
                    if (window.leaguesRegistry) {
                        const registryEntry = window.leaguesRegistry.get(normalizedLega.toLowerCase().trim());
                        if (registryEntry && registryEntry.leagueId) {
                            leagueId = registryEntry.leagueId;
                        }
                    }

                    const matchData = {
                        data: normalizeDate(row.data || row.Data), // Normalize Date!
                        leagueId: leagueId,                // üî• ID ONLY: Numeric league ID
                        lega: normalizedLega,              // Nome lega (per display)
                        partita: String(row.partita || row.Partita).trim(),
                        risultato: String(row.risultato || row.Risultato || '').trim(),
                        probabilita: parseInt(String(row.probabilita || row.Probabilit√† || row.Probabilita).replace('%', '').trim()) || 0,
                        mercato: String(row.mercato || row.Mercato).trim(),
                        tip: String(row.tip || row.Tip).trim(),
                        quota: parseFloat(String(row.quota || row.Quota).replace(',', '.').trim()) || 0,
                        esito: String(row.esito || row.Esito || '').trim(),
                        info_ht: String(row.info_ht || '').trim()
                    };

                    // Skip invalid
                    if (!matchData.data || !matchData.lega || !matchData.partita) {
                        errors++;
                        continue;
                    }

                    // Calcola esito se mancante ma c'√® risultato
                    if (!matchData.esito && matchData.risultato) {
                        matchData.esito = calculateOutcome(matchData);
                    }

                    // Cerca match esistente con strategia "Smart Matching"
                    let existingMatch = null;

                    // 1. Cerca per ID (se presente nel CSV - Future Proof)
                    if (row.id || row.ID || row.Id) {
                        const searchId = String(row.id || row.ID || row.Id).trim();
                        existingMatch = allMatches.find(m => m.id === searchId);
                    }

                    // 2. Cerca per Chiave Esatta (Data + Lega + Partita + Tip)
                    if (!existingMatch) {
                        existingMatch = allMatches.find(m =>
                            m.data === matchData.data &&
                            normalizeKey(m.lega) === normalizeKey(matchData.lega) &&
                            normalizeKey(m.partita) === normalizeKey(matchData.partita) &&
                            normalizeKey(m.tip) === normalizeKey(matchData.tip)
                        );
                    }

                    // 3. Cerca ignorando la LEGA (Data + Partita + Tip)
                    // Risolve il caso: correzione "EU-KOR" -> "AS-KOR"
                    if (!existingMatch) {
                        existingMatch = allMatches.find(m =>
                            m.data === matchData.data &&
                            normalizeKey(m.partita) === normalizeKey(matchData.partita) &&
                            normalizeKey(m.tip) === normalizeKey(matchData.tip)
                        );
                    }

                    if (existingMatch) {
                        // UPDATE
                        updates++;
                        // Mantieni ID originale
                        batchOps.push({ type: 'update', id: existingMatch.id, data: matchData });
                    } else {
                        // CREATE
                        creates++;
                        batchOps.push({ type: 'create', data: matchData });
                    }
                }

                // Preview UI
                previewEl.innerHTML = `
                    <div class="space-y-4">
                        <div class="grid grid-cols-3 gap-4 text-center">
                            <div class="bg-blue-100 p-3 rounded-lg">
                                <div class="text-2xl font-bold text-blue-700">${updates}</div>
                                <div class="text-xs text-blue-600">Da Aggiornare</div>
                            </div>
                            <div class="bg-green-100 p-3 rounded-lg">
                                <div class="text-2xl font-bold text-green-700">${creates}</div>
                                <div class="text-xs text-green-600">Da Creare</div>
                            </div>
                            <div class="bg-red-100 p-3 rounded-lg">
                                <div class="text-2xl font-bold text-red-700">${errors}</div>
                                <div class="text-xs text-red-600">Errori/Ignorati</div>
                            </div>
                        </div>
                        <button id="confirm-backup-upload-btn" class="w-full bg-orange-600 text-white py-3 rounded-lg font-bold hover:bg-orange-700 transition-colors">
                            <i class="fa-solid fa-cloud-upload-alt mr-2"></i>Conferma Caricamento Massivo
                        </button>
                    </div>
                `;

                // Attach event listener to the new button
                document.getElementById('confirm-backup-upload-btn').onclick = () => executeBatchOps(batchOps);
            }

            async function executeBatchOps(ops) {
                const btn = document.getElementById('confirm-backup-upload-btn');
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Elaborazione in corso...';

                try {
                    const batchSize = 400; // Safe limit
                    const chunks = [];
                    for (let i = 0; i < ops.length; i += batchSize) {
                        chunks.push(ops.slice(i, i + batchSize));
                    }

                    let processed = 0;
                    for (const chunk of chunks) {
                        const batch = writeBatch(db);

                        chunk.forEach(op => {
                            if (op.type === 'update') {
                                const ref = doc(db, "matches", op.id);
                                batch.update(ref, op.data);
                            } else {
                                const ref = doc(collection(db, "matches"));
                                batch.set(ref, op.data);
                            }
                        });

                        await batch.commit();
                        processed += chunk.length;
                        btn.innerHTML = `<i class="fa-solid fa-spinner fa-spin mr-2"></i>Elaborati ${processed} di ${ops.length}...`;
                    }


                    // Update Metadata Timestamp
                    try {
                        await setDoc(doc(db, "system", "metadata"), { lastUpdated: Date.now() }, { merge: true });
                    } catch (metaErr) {
                        console.warn("Could not update metadata timestamp (permissions?):", metaErr);
                    }

                    btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Caricamento Completato!';
                    btn.classList.remove('bg-orange-600', 'hover:bg-orange-700');
                    btn.classList.add('bg-gray-500', 'cursor-not-allowed');

                    alert(`Operazione completata! ${processed} record elaborati.`);
                    location.reload();

                } catch (error) {
                    console.error("Batch error:", error);
                    alert("Errore durante il caricamento: " + error.message);
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-exclamation-triangle mr-2"></i>Riprova';
                }
            }


            // ==================== GENERATE DAILY PARLAYS v2.0 ====================
            // Genera multiple intelligenti per "I CONSIGLI DI OGGI"
            // v2.0: Pool esteso da tutte le strategie, filtro orario 12:00-24:00, bundle MAGICA prioritario
            window.generateDailyParlays = async function (targetDate, strategies) {
                console.log(`[Parlays v2.0] üé∞ Generating daily parlays for ${targetDate}...`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // HELPER: Filtro Orario (solo partite 12:00-24:00)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const isDaytimeMatch = (m) => {
                    const ora = (m.api_time || m.ora || '').trim();
                    if (!ora) return true; // Se manca orario, include (meglio che escludere)
                    const hour = parseInt(ora.split(':')[0]);
                    if (isNaN(hour)) return true;
                    return hour >= 12 && hour <= 23; // 12:00 - 23:59
                };

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // POOL 1: Magia AI (per bundle MAGICA)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const magiaMatches = (strategies['magia_ai']?.matches || [])
                    .filter(isDaytimeMatch)
                    .sort((a, b) => (b.score || b.magicStats?.smartScore || 0) - (a.score || a.magicStats?.smartScore || 0));

                console.log(`[Parlays v2.0] üìä Magia AI pool (dopo filtro orario 12-24): ${magiaMatches.length} partite`);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // POOL 2: Esteso (tutte le strategie, senza Magia AI per evitare duplicati)
                // Filtri: orario 12-24 + odds >= 1.16
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const MIN_ODDS_EXTENDED = 1.16;
                const seenMatches = new Set();

                const extendedPool = Object.entries(strategies)
                    .filter(([key]) => key !== 'magia_ai') // Esclude Magia AI (gestita separatamente)
                    .flatMap(([_, strat]) => strat.matches || [])
                    .filter(m => {
                        // De-duplicazione per partita
                        if (seenMatches.has(m.partita)) return false;
                        seenMatches.add(m.partita);

                        // Filtro orario
                        if (!isDaytimeMatch(m)) return false;

                        // Filtro odds minimo
                        const quota = parseFloat(m.magicStats?.oddMagiaAI || m.quota || 1.0);
                        return quota >= MIN_ODDS_EXTENDED;
                    })
                    .sort((a, b) => (b.score || b.magicStats?.smartScore || 0) - (a.score || a.magicStats?.smartScore || 0));

                console.log(`[Parlays v2.0] üìä Extended pool (altre strategie, odds >= ${MIN_ODDS_EXTENDED}): ${extendedPool.length} partite`);

                // Verifica minimo partite
                if (magiaMatches.length < 2 && extendedPool.length < 2) {
                    console.log('[Parlays v2.0] ‚ö†Ô∏è Non abbastanza partite per generare multiple');
                    return { parlays: {}, generated: false };
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PREPARAZIONE PICK
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const preparePick = (m) => {
                    // La quota corretta √® in m.quota (dal CSV originale)
                    // oddMagiaAI=1.5 √® un fallback/default, NON usarlo se √® esattamente 1.5!
                    const rawQuota = parseFloat(m.quota);
                    const rawOdd = parseFloat(m.magicStats?.oddMagiaAI);

                    // Usa oddMagiaAI SOLO se √® diverso dal default 1.5, altrimenti usa m.quota
                    const finalQuota = (rawOdd && rawOdd !== 1.5) ? rawOdd : (rawQuota || 1.50);

                    return {
                        id: m.id || `${m.data}_${m.partita}`,
                        fixtureId: m.fixtureId || null,
                        data: m.data || targetDate,
                        ora: m.api_time || m.ora || '',
                        lega: m.lega || '',
                        partita: m.partita,
                        tip: m.magicStats?.tipMagiaAI || m.tip,
                        quota: finalQuota,
                        score: m.score || m.magicStats?.smartScore || 70,
                        motivationBadges: m.magicStats?.motivationBadges || [],
                        risultato: m.risultato || null,
                        esito: m.esito || null
                    };
                };

                // Helper: Find best combination to reach target quota
                const findBestCombo = (availablePicks, maxPicks, targetQuota) => {
                    if (availablePicks.length === 0) return null;

                    let combo = [];
                    let currentOdds = 1.0;

                    // Prendi i migliori pick (ordinati per score) uno alla volta finch√© non raggiungiamo il target o il limite di picks
                    for (let i = 0; i < Math.min(availablePicks.length, maxPicks); i++) {
                        const pick = availablePicks[i];
                        combo.push(pick);
                        currentOdds *= pick.quota;

                        // Se abbiamo raggiunto la quota target, fermiamoci
                        if (currentOdds >= targetQuota) {
                            return combo;
                        }
                    }

                    // Se abbiamo usato tutti i pick disponibili o raggiunto il limite senza toccare il target,
                    // restituiamo comunque la combo se ha almeno 2 partite
                    return combo.length >= 2 ? combo : null;
                };

                const parlays = {};
                const usedMatchNames = new Set();

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // GENERATORE BUNDLE (con supporto pool custom, skipUsedCheck e customSort)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const generateBundle = (bundleKey, config) => {
                    const { label, color, maxPicks, targetOdds, filter, customPool, skipUsedCheck, customSort } = config;

                    // Usa pool custom se specificato, altrimenti pool esteso
                    const basePool = customPool || extendedPool;

                    // Se skipUsedCheck=true, non filtra le partite gi√† usate (usato per TRICOLORE)
                    let pool = skipUsedCheck ? [...basePool] : basePool.filter(m => !usedMatchNames.has(m.partita));
                    if (filter) pool = pool.filter(filter);

                    // Applica ordinamento personalizzato se presente
                    if (customSort) {
                        pool.sort(customSort);
                    }

                    const combo = findBestCombo(pool.map(preparePick), maxPicks, targetOdds);
                    if (combo && combo.length >= 2) {
                        const odds = combo.reduce((acc, p) => acc * p.quota, 1);
                        const minThreshold = config.minOdds || 1.80;

                        if (odds >= minThreshold) {
                            // Se non skipUsedCheck, aggiungi alle partite usate
                            if (!skipUsedCheck) {
                                combo.forEach(p => usedMatchNames.add(p.partita));
                            }
                            parlays[bundleKey] = {
                                label, color,
                                picks: combo,
                                totalOdds: Math.round(odds * 100) / 100,
                                avgConfidence: Math.round(combo.reduce((acc, p) => acc + p.score, 0) / combo.length),
                                roi: Math.round((odds - 1) * 100)
                            };
                            console.log(`[Parlays v2.3] ‚úÖ ${label}: ${combo.length} picks @ ${parlays[bundleKey].totalOdds}`);
                            return true;
                        }
                    }
                    console.warn(`[Parlays v2.3] ‚ö†Ô∏è ${label}: non generato (quota finale insufficiente o pool vuoto)`);
                    return false;
                };

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // ESECUZIONE BUNDLE (Ordine di priorit√†)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                // 1. MAGICA (Fissa 3 picks, target basso)
                if (magiaMatches.length >= 2) {
                    generateBundle('magica', {
                        label: 'üîÆ MAGICA',
                        color: 'purple',
                        maxPicks: 3,
                        targetOdds: 1.70,
                        minOdds: 1.50,
                        customPool: magiaMatches
                    });
                }

                // 2. RADDOPPIO SAFE (fino a 4 picks per arrivare a quota 2.05)
                generateBundle('safe', {
                    label: 'üí∞ RADDOPPIO SAFE',
                    color: 'emerald',
                    maxPicks: 4,
                    targetOdds: 2.05,
                    minOdds: 1.90
                });

                // 3. TRICOLORE (fino a 4 picks per arrivare a quota 2.00)
                const italiaMatches = [...magiaMatches, ...extendedPool]
                    .filter(m => m.lega && m.lega.includes('ITA'))
                    .sort((a, b) => (b.magicStats?.smartScore || b.score || 0) - (a.magicStats?.smartScore || a.score || 0));

                if (italiaMatches.length >= 2) {
                    generateBundle('italia', {
                        label: 'üáÆüáπ TRICOLORE',
                        color: 'green',
                        maxPicks: 4,
                        targetOdds: 2.00,
                        minOdds: 1.85,
                        customPool: italiaMatches,
                        skipUsedCheck: true
                    });
                }

                // 4. RISCHIO DEL GIORNO (fino a 4 picks per arrivare a quota 3.00+)
                // Invece di aggiungere la 5a partita, cerchiamo partite con quote leggermente pi√π alte
                generateBundle('risky', {
                    label: '‚ö° RISCHIO DEL GIORNO',
                    color: 'orange',
                    maxPicks: 4,
                    targetOdds: 3.10,
                    minOdds: 2.60,
                    // Sort order: prioritizza un mix di quota e probabilit√†
                    customSort: (a, b) => {
                        const qA = parseFloat(a.magicStats?.oddMagiaAI || a.quota || 1.25);
                        const qB = parseFloat(b.magicStats?.oddMagiaAI || b.quota || 1.25);
                        const scoreA = a.magicStats?.smartScore || a.score || 70;
                        const scoreB = b.magicStats?.smartScore || b.score || 70;
                        // Score pesato: cerchiamo quote pi√π alte ma con score ancora sopra 75
                        return (qB * scoreB) - (qA * scoreA);
                    }
                });

                // üî• NEW: 5. SNIPER 1¬∞ TEMPO (0.5 HT) - Specialit√† euGENIO
                const htMatches = [...magiaMatches, ...extendedPool]
                    .filter(m => m.magicStats?.tipMagiaAI === '0.5 HT' || (m.magicStats?.ht05 >= 80))
                    .sort((a, b) => (b.magicStats?.ht05 || 0) - (a.magicStats?.ht05 || 0));

                if (htMatches.length >= 2) {
                    generateBundle('ht_sniper', {
                        label: '‚è±Ô∏è SNIPER 1¬∞ TEMPO',
                        color: 'blue',
                        maxPicks: 3,
                        targetOdds: 1.80,
                        minOdds: 1.40,
                        customPool: htMatches,
                        skipUsedCheck: true
                    });
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SALVATAGGIO FIRESTORE
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const parlayData = {
                    parlays,
                    generatedAt: new Date().toISOString(),
                    sourceStrategy: 'magia_ai + extended',
                    totalParlays: Object.keys(parlays).length,
                    uniqueMatches: usedMatchNames.size,
                    version: '2.0'
                };

                try {
                    await setDoc(doc(db, "daily_parlays", targetDate), parlayData);
                    console.log(`[Parlays v2.0] ‚úÖ Salvati ${Object.keys(parlays).length} parlays in daily_parlays/${targetDate}`);
                } catch (e) {
                    console.error('[Parlays v2.0] ‚ùå Errore salvataggio:', e);
                }

                return parlayData;
            }

            // GLOBAL HELPER: Log progress
            const logUploadProgress = (msg) => {
                console.log(msg);
                const btn = document.getElementById('confirm-tips-upload-btn') || document.getElementById('confirm-results-upload-btn');
                if (btn) btn.innerHTML = `<i class="fa-solid fa-spinner fa-spin mr-2"></i>${msg}`;
            };

            async function handleUploadConfirmed(type) {
                const currentDataToUpload = window.dataToUpload || dataToUpload;
                if (!currentDataToUpload || currentDataToUpload.length === 0) return;

                // Show fullscreen loading overlay
                const overlay = document.createElement('div');
                overlay.id = 'upload-loading-overlay';
                overlay.innerHTML = `
                    <div style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:9999;display:flex;flex-direction:column;align-items:center;justify-content:center;">
                        <div style="font-size:48px;animation:spin 1s linear infinite;">‚è≥</div>
                        <div style="color:white;font-size:18px;margin-top:16px;font-weight:bold;">Caricamento in corso...</div>
                        <div style="color:#aaa;font-size:14px;margin-top:8px;">Attendere, non chiudere la pagina</div>
                    </div>
                    <style>@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style>
                `;
                document.body.appendChild(overlay);

                // üî• FIX: Il pulsante nel modal ha un ID diverso o non esiste in questo contesto
                const btnId = (type === 'results' && !document.getElementById(`confirm-${type}-upload-btn`))
                    ? 'save-sync-modal'
                    : `confirm-${type}-upload-btn`;

                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento...';
                }

                console.log(`[DEBUG-Handle] Avvio handleUploadConfirmed per: ${type} | Totale partite: ${currentDataToUpload.size || currentDataToUpload.length}`);
                console.log(`[DEBUG-DATE] Prima partita nel batch ha data: ${currentDataToUpload[0]?.data}`);

                try {
                    console.log(`[DEBUG-Handle] 1. Aggiornamento orari dalla cache...`);
                    for (const m of currentDataToUpload) {
                        try {
                            const cachedTime = await getTimeFromCache(m.data, m.partita);
                            if (cachedTime) m.ora = cachedTime;
                        } catch (e) { }
                    }

                    console.log(`[DEBUG-Handle] 2. Merge dati in memoria (fixtureId-first)...`);
                    const updatedMatches = [...window.allMatches];
                    let mergedCount = 0;
                    let newCount = 0;

                    // üî• Helper: Estrai squadra1 dal nome partita "Team1 - Team2"
                    const getTeam1 = (partita) => (partita || '').split(' - ')[0].trim().toLowerCase();

                    for (const match of currentDataToUpload) {
                        // console.log(`[DEBUG-Item] Analisi: ${match.partita} | Data: ${match.data} | ID: ${match.fixtureId || 'MISSING'}`);

                        // üî• MATCHING A 3 LIVELLI (priorit√† decrescente)
                        let existingIndex = -1;

                        // 1Ô∏è‚É£ PRIORIT√Ä ASSOLUTA: fixtureId
                        if (match.fixtureId) {
                            existingIndex = updatedMatches.findIndex(m =>
                                m.fixtureId && String(m.fixtureId) === String(match.fixtureId)
                            );
                            if (existingIndex >= 0) console.log(`[DEBUG-Item] üîë Match per fixtureId: ${match.fixtureId}`);
                        }

                        // 2Ô∏è‚É£ FALLBACK: data + lega + squadra1
                        if (existingIndex < 0 && match.data && match.lega) {
                            const team1 = getTeam1(match.partita);
                            existingIndex = updatedMatches.findIndex(m =>
                                m.data === match.data &&
                                m.lega === match.lega &&
                                getTeam1(m.partita) === team1
                            );
                            if (existingIndex >= 0) console.log(`[DEBUG-Item] üèüÔ∏è Match per data+lega+squadra1`);
                        }

                        // 3Ô∏è‚É£ FALLBACK LEGACY: id o data+partita (esatto)
                        if (existingIndex < 0) {
                            existingIndex = updatedMatches.findIndex(m => {
                                const dateMatch = m.data === match.data;
                                const nameMatch = m.partita === match.partita;
                                if (nameMatch && !dateMatch) {
                                    console.log(`[DEBUG-DATE-MISMATCH] Trovata partita "${match.partita}" ma data non coincide: DB=${m.data} vs CSV=${match.data}`);
                                }
                                return (match.id && m.id === match.id) || (dateMatch && nameMatch);
                            });
                            if (existingIndex >= 0) console.log(`[DEBUG-Item] üìã Match per id/partita esatta`);
                        }

                        if (existingIndex >= 0) {
                            console.log(`[DEBUG-Item] ‚úÖ Trovato match esistente. Merging...`);
                            const existing = updatedMatches[existingIndex];

                            // üî• MANTENIMENTO FIXTURE ID: Se il record DB non lo aveva, lo prende dal caricamento corrente
                            if (match.fixtureId && !existing.fixtureId) {
                                console.log(`[DEBUG-Item] üÜï Aggancio fixtureId ${match.fixtureId} al record esistente`);
                            }

                            // üî• FIX: Proteggi i campi "identitari" del DB Oro - NON sovrascrivere se gi√† esistono
                            const protectedFields = ['magia', 'tip', 'quota', 'probabilita'];
                            const safeMatch = { ...match };
                            protectedFields.forEach(field => {
                                if (existing[field] !== undefined && existing[field] !== null && existing[field] !== '') {
                                    // Mantieni il valore originale del DB Oro
                                    safeMatch[field] = existing[field];
                                }
                            });

                            // MERGE DEI DATI: safeMatch (con campi protetti) si aggiunge a existing
                            updatedMatches[existingIndex] = { ...existing, ...safeMatch };
                            mergedCount++;
                        } else {
                            console.log(`[DEBUG-Item] üÜï Nuovo match da CSV. Aggiunta al DB Oro...`);
                            if (!match.id) match.id = 'pick_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                            updatedMatches.push({ ...match });
                            newCount++;
                        }
                    }

                    window.allMatches = updatedMatches;
                    console.log(`[DEBUG-Handle] Memoria aggiornata. Merged: ${mergedCount} | Nuovi: ${newCount} | Totale: ${window.allMatches.length}`);

                    // 2. PERSISTENCE (Local Only)
                    console.log(`[DEBUG-Save] 3. Salvataggio locale su IndexedDB...`);
                    logUploadProgress(`Salvataggio locale di ${currentDataToUpload.length} partite...`);
                    await LocalDB.saveMatches(window.allMatches);
                    console.log(`[DEBUG-Save] ‚úÖ Salvataggio locale COMPLETATO.`);

                    // 3. UI UPDATE & FIREBASE SYNC (Hybrid Mode)
                    updateStatsDisplay(window.allMatches);
                    console.log(`[DEBUG-Save] 4. Sincronizzazione App (Firebase)...`);
                    logUploadProgress(`Sincronizzazione Cloud in corso...`);

                    try {
                        const uploadedCount = await uploadMatchesToFirebase(type, currentDataToUpload, window.allMatches, db);
                        console.log(`[DEBUG-Save] ‚úÖ Sincronizzazione Cloud completata: ${uploadedCount} partite.`);
                    } catch (fbErr) {
                        console.error("[DEBUG-Save] ‚ùå Errore sincronizzazione Cloud:", fbErr);
                        logUploadProgress(`‚ö†Ô∏è Errore Cloud: ${fbErr.message}. Dati salvati solo in locale.`);
                    }

                    // üî• NEW: POST-PROCESSING (Local Only)
                    try {
                        const uploadDate = currentDataToUpload[0]?.data;

                        if (type === 'results' && uploadDate) {
                            // üî• SYNC MAGIA AI RESULTS (SANDBOX)
                            try {
                                console.log(`[Magia AI] Sincronizzazione risultati in parallelo...`);
                                const magiaMatches = await window.LocalDB.loadMagiaMatches();
                                const getTeam1 = (partita) => (partita || '').split(' - ')[0].trim().toLowerCase();

                                if (magiaMatches.length > 0) {
                                    const resultsMapById = new Map();
                                    const resultsMapByLegaTeam = new Map();
                                    const resultsMapByName = new Map();

                                    currentDataToUpload.forEach(m => {
                                        if (m.fixtureId && m.risultato) resultsMapById.set(String(m.fixtureId), m);
                                        if (m.lega && m.data && m.partita) resultsMapByLegaTeam.set(`${m.data}_${m.lega}_${getTeam1(m.partita)}`, m);
                                        if (m.partita && m.data) resultsMapByName.set(`${m.partita}_${m.data}`, m);
                                    });

                                    let magiaUpdated = 0;
                                    magiaMatches.forEach(m => {
                                        let res = null;
                                        if (m.fixtureId) res = resultsMapById.get(String(m.fixtureId));
                                        if (!res && m.lega && m.data) res = resultsMapByLegaTeam.get(`${m.data}_${m.lega}_${getTeam1(m.partita)}`);
                                        if (!res) res = resultsMapByName.get(`${m.partita}_${m.data}`);

                                        if (res && res.risultato) {
                                            m.risultato = res.risultato;
                                            m.risultato_ht = res.risultato_ht || '';
                                            m.esito = window.calculateOutcome ? (window.calculateOutcome(m) || '') : '';
                                            magiaUpdated++;
                                        }
                                    });

                                    if (magiaUpdated > 0) {
                                        await window.LocalDB.updateMagiaMatches(magiaMatches);
                                        console.log(`[Magia AI] ‚úÖ Sandbox aggiornata: ${magiaUpdated} esiti.`);
                                    }
                                }
                            } catch (magiaErr) { console.error("[Magia AI Sync Fail]", magiaErr); }

                            console.log(`[DEBUG-Post] Aggiornamento Ranking...`);
                            await updateRankingResults(uploadDate, currentDataToUpload).catch(e => console.warn("Ranking Update Fail", e));

                            // üî• NEW: SYNC ALL STRATEGY SNAPSHOTS (Storico Strategie Locale)
                            try {
                                console.log(`[Storico Strategie] Sincronizzazione risultati per tutte le strategie...`);
                                const historyData = await window.LocalDB.loadStrategyHistory(uploadDate);
                                if (historyData) {
                                    const getTeam1 = (partita) => (partita || '').split(' - ')[0].trim().toLowerCase();
                                    const resultsMapById = new Map();
                                    const resultsMapByLegaTeam = new Map();
                                    const resultsMapByName = new Map();

                                    currentDataToUpload.forEach(m => {
                                        if (m.fixtureId && m.risultato) resultsMapById.set(String(m.fixtureId), m);
                                        if (m.lega && m.data && m.partita) resultsMapByLegaTeam.set(`${m.data}_${m.lega}_${getTeam1(m.partita)}`, m);
                                        if (m.partita && m.data) resultsMapByName.set(`${m.partita}_${m.data}`, m);
                                    });

                                    let totalSnapshotsUpdated = 0;

                                    // Cicla su TUTTE le strategie salvate per quel giorno (es: all, winrate_80, magia_ai_raw, etc.)
                                    Object.keys(historyData).forEach(stratId => {
                                        const strategy = historyData[stratId];
                                        if (!strategy || !Array.isArray(strategy.matches)) return;

                                        let updatedCount = 0;
                                        strategy.matches.forEach(m => {
                                            let res = null;
                                            if (m.fixtureId) res = resultsMapById.get(String(m.fixtureId));
                                            if (!res && m.lega && m.data) res = resultsMapByLegaTeam.get(`${m.data}_${m.lega}_${getTeam1(m.partita)}`);
                                            if (!res) res = resultsMapByName.get(`${m.partita}_${m.data}`);

                                            if (res && res.risultato) {
                                                m.risultato = res.risultato;
                                                m.risultato_ht = res.risultato_ht || '';

                                                // Ricalcola esito specifico per questa strategia
                                                // Se √® Magia AI PRO, usa il tip AI, altrimenti usa il tip della strategia
                                                const targetTip = (stratId === 'magia_ai_raw' && m.magicStats?.tipMagiaAI) ?
                                                    m.magicStats.tipMagiaAI : m.tip;

                                                if (targetTip && window.calculateOutcome) {
                                                    m.esito = window.calculateOutcome({ tip: targetTip, risultato: m.risultato });
                                                } else if (res.esito) {
                                                    m.esito = res.esito;
                                                }
                                                updatedCount++;
                                            }
                                        });

                                        if (updatedCount > 0) {
                                            strategy.lastResultsSync = new Date().toISOString();
                                            totalSnapshotsUpdated += updatedCount;
                                        }
                                    });

                                    if (totalSnapshotsUpdated > 0) {
                                        await window.LocalDB.saveStrategyHistory(uploadDate, historyData);
                                        console.log(`[Storico Strategie] ‚úÖ Aggiornati ${totalSnapshotsUpdated} match in tutte le strategie locali.`);
                                    }
                                }
                            } catch (snapErr) { console.error("[Strategie Sync Fail]", snapErr); }

                            // üî• AUTO-UPDATE TRADING 3.0
                            console.log(`[DEBUG-Post] üöÄ Avvio aggiornamento automatico Trading 3.0...`);
                            await autoUpdateTrading30(uploadDate, currentDataToUpload).catch(e => console.warn("Trading Update Fail", e));

                            // üî• FIREBASE 7-DAY CLEANUP: Rimuovi strategie pi√π vecchie di 7 giorni
                            try {
                                console.log(`[7-Day Cleanup] Avvio pulizia automatica Firebase...`);
                                await window.databaseManager.cleanupOldStrategies(db);
                                console.log(`[7-Day Cleanup] ‚úÖ Pulizia completata.`);
                            } catch (cleanupErr) { console.warn("[7-Day Cleanup] Fail", cleanupErr); }
                        }
                    } catch (metaErr) {
                        console.warn("[DEBUG-Post] ‚ö†Ô∏è Errore durante i task post-salvataggio:", metaErr);
                    }

                    overlay.remove();
                    if (btn) {
                        btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Completato!';
                        btn.classList.replace('bg-blue-600', 'bg-gray-500');
                    }

                    // üî• v12.1: UNKNOWN LEAGUES RESOLUTION POPUP
                    if (window._unknownLeaguesQueue && window._unknownLeaguesQueue.size > 0) {
                        const unknownList = Array.from(window._unknownLeaguesQueue);
                        console.log(`[Alias] Found ${unknownList.length} unknown leagues to resolve`);
                        await showUnknownLeaguesPopup(unknownList);
                        window._unknownLeaguesQueue.clear();
                    }

                    alert(`Salvato con successo! ${currentDataToUpload.length} partite processate.`);

                    // üî• REFRESH UI
                    if (typeof loadMatchesFromDB === 'function') {
                        console.log("[DEBUG-Save] üîÑ Triggering UI Refresh...");
                        await loadMatchesFromDB();
                    }

                } catch (error) {
                    console.error("[DEBUG-CRITICAL] ‚ùå Errore durante handleUploadConfirmed:", error);
                    overlay.remove();
                    if (btn) {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fa-solid fa-exclamation-triangle mr-2"></i>Riprova';
                    }
                    alert("Errore durante il salvataggio: " + error.message);
                }
            }

            // üî• v12.1: UNKNOWN LEAGUES RESOLUTION POPUP
            async function showUnknownLeaguesPopup(unknownLeagues) {
                if (!unknownLeagues || unknownLeagues.length === 0) return;

                const allLeagues = await window.LocalDB.getAllLeagues();

                return new Promise((resolve) => {
                    const overlay = document.createElement('div');
                    overlay.className = 'fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4';
                    overlay.innerHTML = `
                        <div class="bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-hidden flex flex-col">
                            <div class="bg-amber-500 text-white p-4">
                                <h2 class="text-xl font-bold">‚ö†Ô∏è Leghe Sconosciute Rilevate</h2>
                                <p class="text-sm opacity-90">Associa queste leghe al Registry per evitare doppioni futuri</p>
                            </div>
                            <div id="unknown-leagues-list" class="flex-1 overflow-y-auto p-4 space-y-4"></div>
                            <div class="p-4 bg-gray-50 border-t flex justify-between">
                                <button id="skip-all-btn" class="px-4 py-2 text-gray-600 hover:text-gray-800">Salta Tutto</button>
                                <button id="done-btn" class="px-6 py-2 bg-amber-500 text-white rounded-lg font-bold hover:bg-amber-600">Fatto</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(overlay);

                    const listContainer = overlay.querySelector('#unknown-leagues-list');

                    unknownLeagues.forEach((unknownName, idx) => {
                        const similar = window.LocalDB.findSimilarLeagues(unknownName, allLeagues);

                        const card = document.createElement('div');
                        card.className = 'bg-gray-50 rounded-lg p-4 border';
                        card.innerHTML = `
                            <div class="font-bold text-gray-800 mb-2">‚ùì "${unknownName}"</div>
                            ${similar.length > 0 ? `
                                <div class="text-sm text-gray-600 mb-2">Possibili corrispondenze:</div>
                                <div class="space-y-1 mb-3">
                                    ${similar.map((s, sidx) => `
                                        <label class="flex items-center gap-2 p-2 rounded hover:bg-amber-50 cursor-pointer">
                                            <input type="radio" name="resolve-${idx}" value="${s.leagueId}" class="resolve-radio" data-unknown="${unknownName}" data-canonical="${s.name}">
                                            <span class="text-sm">${s.name} <span class="text-gray-400">(ID: ${s.leagueId}, ${Math.round(s.similarity * 100)}%)</span></span>
                                        </label>
                                    `).join('')}
                                </div>
                            ` : '<div class="text-sm text-gray-500 mb-2">Nessuna corrispondenza trovata</div>'}
                            <div class="flex items-center gap-2">
                                <span class="text-sm text-gray-600">Oppure inserisci ID:</span>
                                <input type="number" class="manual-id-input w-24 p-1 border rounded text-sm" data-unknown="${unknownName}" placeholder="ID">
                                <button class="apply-manual-btn text-xs px-2 py-1 bg-blue-500 text-white rounded" data-unknown="${unknownName}">Applica</button>
                            </div>
                        `;
                        listContainer.appendChild(card);
                    });

                    // Event handlers
                    overlay.querySelectorAll('.resolve-radio').forEach(radio => {
                        radio.addEventListener('change', async (e) => {
                            const unknownName = e.target.dataset.unknown;
                            const leagueId = parseInt(e.target.value);
                            await window.LocalDB.addLeagueAlias(leagueId, unknownName);
                            e.target.closest('.bg-gray-50').classList.add('bg-green-50', 'border-green-300');
                            console.log(`[Alias] Added "${unknownName}" as alias for ID ${leagueId}`);
                        });
                    });

                    overlay.querySelectorAll('.apply-manual-btn').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            const unknownName = e.target.dataset.unknown;
                            const input = overlay.querySelector(`.manual-id-input[data-unknown="${unknownName}"]`);
                            const leagueId = parseInt(input.value);
                            if (leagueId && leagueId > 0) {
                                const success = await window.LocalDB.addLeagueAlias(leagueId, unknownName);
                                if (success) {
                                    input.closest('.bg-gray-50').classList.add('bg-green-50', 'border-green-300');
                                    console.log(`[Alias] Added "${unknownName}" as alias for ID ${leagueId}`);
                                } else {
                                    alert(`ID ${leagueId} non trovato nel Registry!`);
                                }
                            }
                        });
                    });

                    overlay.querySelector('#skip-all-btn').addEventListener('click', () => {
                        overlay.remove();
                        resolve();
                    });

                    overlay.querySelector('#done-btn').addEventListener('click', () => {
                        overlay.remove();
                        resolve();
                    });
                });
            }

            function parseCSV(text) {
                // Use PapaParse for robust CSV parsing (handles quotes, commas within values, etc.)
                const result = Papa.parse(text, {
                    header: true,
                    skipEmptyLines: true,
                    transformHeader: (h) => h.trim().replace(/['"]/g, '') // Clean headers
                });

                console.log('[parseCSV] Headers found:', result.meta.fields);
                if (result.data.length > 0) console.log('[parseCSV] First row sample:', result.data[0]);

                return result.data;
            }

            async function processAndPreviewCSV(parsedData, matchDate, type) {
                console.log(`[DEBUG-CSV-START] processAndPreviewCSV: type=${type}, matchDate=${matchDate}, righe=${parsedData.length}`);
                const requiredFields = ['Lega', 'Partita', 'Probabilit√†', 'Mercato', 'Tip', 'Quota'];
                let potentialMatches = [];
                let incomplete = 0;
                let duplicates = 0;
                let updates = 0;
                let tipConflicts = 0;
                let debugLogCount = 0;

                for (const row of parsedData) {
                    // VALIDAZIONE MIGLIORATA: scarta se campo mancante o "-"
                    if (!requiredFields.every(f => {
                        const value = String(row[f] || '').trim();
                        return value !== '' && value !== '-';
                    })) {
                        incomplete++;
                        continue;
                    }

                    // Parse dati
                    if (type === 'tips') tipsFileCount = parsedData.length;
                    if (type === 'ht') htFileCount = parsedData.length;

                    const probabilita = parseInt(String(row['Probabilit√†']).replace('%', '').trim()) || 0;
                    const quota = parseFloat(String(row.Quota).replace(',', '.').trim()) || 0;

                    // VALIDAZIONE NUMERICA: scarta se prob o quota = 0
                    if (probabilita === 0 || quota === 0) {
                        incomplete++;
                        continue;
                    }

                    // Parse ora dal CSV
                    const ora = String(row.Ora || row.Time || '').trim();

                    // üî• PROTOCOLLO SOCIO: FixtureID √® la LEGGE üá®üá≠
                    // Dalla colonna fixtureId del CSV (fondamentale per monitoraggio live)
                    const fixtureId = String(row.fixtureId || row.fixture_id || row.id || row.ID || '').trim();

                    // üî• v12.1: Resolve league via alias system
                    const rawLega = String(row.Lega).trim();
                    const normLega = normalizeLega(rawLega);
                    let resolvedLega = normLega;

                    // Check Registry first
                    if (window.leaguesRegistry) {
                        const regEntry = window.leaguesRegistry.get(normLega);
                        if (regEntry) {
                            resolvedLega = regEntry.name.toLowerCase().trim();
                        } else {
                            // Check alias system
                            const aliasResult = await window.LocalDB.resolveLeagueAlias(normLega);
                            if (aliasResult) {
                                resolvedLega = aliasResult.canonical;
                                console.log(`[Alias] Resolved "${normLega}" ‚Üí "${resolvedLega}" (via ${aliasResult.source})`);
                            } else {
                                // Track unknown league for later resolution
                                if (!window._unknownLeaguesQueue) window._unknownLeaguesQueue = new Set();
                                window._unknownLeaguesQueue.add(normLega);
                            }
                        }
                    }

                    // üî• ID ONLY RULE: Resolve leagueId from Registry
                    let leagueId = null;
                    if (window.leaguesRegistry) {
                        const registryEntry = window.leaguesRegistry.get(resolvedLega.toLowerCase().trim());
                        if (registryEntry && registryEntry.leagueId) {
                            leagueId = registryEntry.leagueId;
                        }
                    }

                    const matchData = {
                        id: fixtureId, // ID-Pure: l'ID coincide col FixtureID per coerenza assoluta
                        fixtureId: fixtureId,
                        data: matchDate,
                        leagueId: leagueId,                // üî• ID ONLY: Numeric league ID
                        lega: resolvedLega,                // Nome lega (per display)
                        partita: String(row.Partita).trim(),
                        risultato: type === 'results' ? (String(row.Risultato || row.Ris || row.Result || row.Score || '').trim()) : '',
                        probabilita: probabilita,
                        mercato: String(row.Mercato).trim(),
                        tip: String(row.Tip).trim(),
                        quota: quota,
                        info_ht: String(row.info_ht || '').trim()
                    };

                    if (type === 'results' && debugLogCount < 5) {
                        console.log(`[CSV DEBUG] Row:`, row);
                        console.log(`[CSV DEBUG] Extracted Result: '${matchData.risultato}'`);
                        debugLogCount++;
                    }

                    // Se c'√® ora nel CSV ‚Üí salva in cache Firebase temporanea
                    if (ora && ora !== '' && type === 'tips') {
                        // Salva in cache (non nel DB principale!)
                        await saveTimeToCache(matchData.data, matchData.partita, ora);
                    }

                    // Check duplicates in current batch
                    const existingIndex = potentialMatches.findIndex(m =>
                        m.data === matchData.data &&
                        m.lega === matchData.lega &&
                        m.partita === matchData.partita &&
                        m.tip === matchData.tip
                    );

                    if (existingIndex >= 0) {
                        // Update existing match in batch - SMART MERGE
                        const existing = potentialMatches[existingIndex];
                        const smartUpdate = { ...existing };

                        // Update fields ONLY if present in new data
                        if (matchData.ora) smartUpdate.ora = matchData.ora;
                        if (matchData.quota) smartUpdate.quota = matchData.quota;
                        if (matchData.probabilita) smartUpdate.probabilita = matchData.probabilita;
                        if (matchData.info_ht) smartUpdate.info_ht = matchData.info_ht;
                        if (matchData.risultato) smartUpdate.risultato = matchData.risultato;
                        if (matchData.esito) smartUpdate.esito = matchData.esito;

                        potentialMatches[existingIndex] = smartUpdate;
                        updates++;
                    } else {
                        // Check against already loaded matches (global)

                        // üîç DEBUG LOG per ogni partita durante upload RISULTATI
                        if (type === 'results') {
                            console.log(`\n[RISULTATI] üîç Cercando partita:`);
                            console.log(`  üìÖ Data: ${matchData.data}`);
                            console.log(`  ‚öΩ Partita: ${matchData.partita}`);
                            console.log(`  üìã Matching SOLO per data+partita (ignoro lega/tip)`);
                        }

                        // DIFFERENZIA matching per TIPS vs RESULTS
                        let globalDuplicate;

                        if (type === 'results') {
                            // ========================================
                            // UPLOAD RISULTATI - LOGICA SEMPLIFICATA
                            // ========================================

                            // STEP 1: Cerca partita con PARTIAL MATCH (basta UNA squadra)
                            const teams = matchData.partita.split(' - ').map(t => normalizeTeamName(t.trim()));

                            console.log(`  üîé Team normalizzati CSV: ["${teams[0]}", "${teams[1]}"]`);

                            let foundMatch = null;

                            if (teams.length === 2) {
                                // LOG ALL MATCHES FOR THIS DATE
                                const sameDate = window.allMatches.filter(m => m.data === matchData.data);
                                console.log(`  üìä Partite in DB per ${matchData.data}: ${sameDate.length}`);
                                if (sameDate.length > 0 && sameDate.length <= 5) {
                                    console.log(`     Esempi:`, sameDate.slice(0, 5).map(m => m.partita));
                                }

                                // STEP 1: Try matching BOTH teams (exact match)
                                console.log(`  üîç STEP 1: Cerco match con ENTRAMBE le squadre...`);
                                let candidates = window.allMatches.filter(m => {
                                    if (m.data !== matchData.data) return false;
                                    const mTeams = m.partita.split(' - ').map(t => normalizeTeamName(t.trim()));

                                    // Both teams must match (in any order)
                                    if (mTeams.length !== 2) return false;
                                    const hasTeam0 = mTeams.includes(teams[0]);
                                    const hasTeam1 = mTeams.includes(teams[1]);

                                    if (hasTeam0 && hasTeam1) {
                                        console.log(`     üéØ Candidato ESATTO: "${m.partita}" ‚Üí team norm: ["${mTeams[0]}", "${mTeams[1]}"]`);
                                    }
                                    return hasTeam0 && hasTeam1;
                                });

                                console.log(`  üî¢ Candidati con ENTRAMBE squadre: ${candidates.length}`);

                                // STEP 2: If no match, try with ONE team (fallback for special characters)
                                if (candidates.length === 0) {
                                    console.log(`  üîç STEP 2: Nessun match esatto, provo con UNA squadra (fallback caratteri speciali)...`);
                                    candidates = window.allMatches.filter(m => {
                                        if (m.data !== matchData.data) return false;
                                        const mTeams = m.partita.split(' - ').map(t => normalizeTeamName(t.trim()));
                                        const hasMatch = mTeams.some(mt => mt === teams[0] || mt === teams[1]);
                                        if (hasMatch) {
                                            console.log(`     ‚ö†Ô∏è Candidato PARZIALE: "${m.partita}" ‚Üí team norm: ["${mTeams[0]}", "${mTeams[1]}"]`);
                                        }
                                        return hasMatch;
                                    });
                                    console.log(`  üî¢ Candidati con UNA squadra: ${candidates.length}`);
                                }

                                console.log(`  üìä Totale candidati finali: ${candidates.length}`);

                                if (candidates.length === 1) {
                                    foundMatch = candidates[0];
                                    console.log(`  ‚úÖ Match trovato! "${matchData.partita}" ‚Üí "${foundMatch.partita}"`);
                                } else if (candidates.length > 1) {
                                    console.warn(`  ‚ö†Ô∏è ${candidates.length} candidati per "${matchData.partita}" - skip ambiguo`);
                                    console.warn(`     Candidati:`, candidates.map(c => c.partita));
                                } else {
                                    console.warn(`  ‚ùå NESSUN candidato trovato per "${matchData.partita}"`);
                                }
                            }

                            // STEP 2: Aggiorna o Crea
                            if (foundMatch) {
                                // ‚úÖ TROVATA - Aggiorna SOLO risultato (ignora tip/odd/prob CSV)
                                const smartUpdate = { ...foundMatch };
                                smartUpdate.risultato = matchData.risultato;

                                // Calcola esito con TIP ORIGINALE del DB
                                if (matchData.risultato && matchData.risultato.trim() !== '') {
                                    const calculatedEsito = calculateOutcome({
                                        tip: foundMatch.tip,
                                        risultato: matchData.risultato
                                    });
                                    smartUpdate.esito = calculatedEsito || '';
                                }

                                // Log se tip era diversa
                                if (foundMatch.tip !== matchData.tip) {
                                    tipConflicts++;
                                    console.log(`  ‚ö†Ô∏è Tip ignorata (CSV="${matchData.tip}" vs DB="${foundMatch.tip}")`);
                                }

                                potentialMatches.push(smartUpdate);
                                updates++;

                            } else {
                                // ‚ùå NON TROVATA - Crea nuova partita (per statistiche)
                                console.log(`  ‚ÑπÔ∏è Partita non in DB, creo nuova: "${matchData.partita}"`);

                                const calculatedEsito = calculateOutcome({
                                    tip: matchData.tip,
                                    risultato: matchData.risultato
                                });

                                const newMatch = {
                                    data: matchData.data,
                                    lega: matchData.lega,
                                    partita: matchData.partita,
                                    risultato: matchData.risultato,
                                    probabilita: matchData.probabilita || 0,
                                    mercato: matchData.mercato || '',
                                    tip: matchData.tip || '',
                                    quota: matchData.quota || 0,
                                    esito: calculatedEsito || '',
                                    info_ht: ''
                                };

                                potentialMatches.push(newMatch);
                                console.log(`  ‚úÖ Nuova partita creata`);
                            }

                        } else {              // TIPS UPLOAD LOGIC (Invariata)
                            globalDuplicate = window.allMatches.find(m =>
                                m.data === matchData.data &&
                                m.lega === matchData.lega &&
                                m.partita === matchData.partita &&
                                m.tip === matchData.tip
                            );

                            if (globalDuplicate) {
                                const smartUpdate = { ...globalDuplicate };
                                if (matchData.ora) smartUpdate.ora = matchData.ora;
                                if (matchData.quota) smartUpdate.quota = matchData.quota;
                                if (matchData.probabilita) smartUpdate.probabilita = matchData.probabilita;
                                if (matchData.info_ht) smartUpdate.info_ht = matchData.info_ht;
                                potentialMatches.push(smartUpdate);
                                updates++;
                            } else {
                                potentialMatches.push(matchData);
                            }
                        }
                    }
                }

                dataToUpload = potentialMatches;
                // FIX: HT file should update the TIPS preview box
                const previewId = (type === 'tips' || type === 'ht') ? 'tips-upload-preview' : 'results-upload-preview';
                const uploadPreview = document.getElementById(previewId);

                uploadPreview.classList.remove('hidden');
                uploadPreview.innerHTML = `
                    <ul class="list-disc list-inside text-sm mt-2 space-y-1">
                        <li><strong>Partite totali file:</strong> ${parsedData.length}</li>
                        ${incomplete > 0 ? `<li class="text-red-600"><strong>Scartate (incomplete):</strong> ${incomplete}</li>` : ''}
                        ${type === 'results' ? `<li class="text-green-600 font-bold">‚úÖ Aggiornate (da DB): ${updates}</li>` : ''}
                        ${type === 'results' && tipConflicts > 0 ? `<li class="text-orange-600 font-bold">‚ö†Ô∏è Tip Diversi (Scartati dal CSV): ${tipConflicts}</li>` : ''}
                        ${(dataToUpload.length - updates) > 0 ? `<li class="text-blue-600 font-bold">‚ûï Nuove (Inserite): ${dataToUpload.length - updates}</li>` : ''}
                        ${(type === 'tips' && htFileCount > 0 && (tipsFileCount - htFileCount) > 0) ? `<li class="text-orange-600">‚ö†Ô∏è Senza dati HT: ${tipsFileCount - htFileCount}</li>` : ''}
                        <li class="pt-2 border-t border-gray-300 mt-2 font-bold text-purple-700">üìä Totale operazioni: ${dataToUpload.length}</li>
                    </ul>
                    
                    ${type === 'tips' ? `
                    <!-- FASE 1: RICERCA LEGHE -->
                    <div id="league-search-area" class="mt-4 p-4 bg-purple-50 border border-purple-200 rounded-lg">
                        <div class="flex items-center justify-between">
                            <div>
                                <h4 class="font-bold text-purple-800">üîç Fase 1: Ricerca Leghe</h4>
                                <p class="text-sm text-purple-600">Verifica e risolvi le leghe prima di associare le partite</p>
                            </div>
                            <button id="search-leagues-btn" class="bg-purple-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-purple-700 transition-colors">
                                üîç Ricerca Leghe
                            </button>
                        </div>
                        <div id="league-search-status" class="mt-3 hidden"></div>
                        
                        <!-- Report Leghe -->
                        <div id="league-report-container" class="mt-4 hidden space-y-3">
                            <!-- Leghe Confermate -->
                            <div id="leagues-confirmed" class="hidden">
                                <h5 class="font-bold text-green-700 mb-2">‚úÖ Leghe nel Database:</h5>
                                <ul id="leagues-confirmed-list" class="text-sm text-green-600 list-disc list-inside max-h-32 overflow-y-auto"></ul>
                            </div>
                            <!-- Leghe Nuove -->
                            <div id="leagues-new" class="hidden">
                                <h5 class="font-bold text-blue-700 mb-2">üÜï Nuove Leghe Trovate:</h5>
                                <ul id="leagues-new-list" class="text-sm text-blue-600 list-disc list-inside max-h-32 overflow-y-auto"></ul>
                            </div>
                            <!-- Leghe Ambigue -->
                            <div id="leagues-ambiguous" class="hidden">
                                <h5 class="font-bold text-orange-700 mb-2">‚ö†Ô∏è Leghe Ambigue (scegli):</h5>
                                <div id="leagues-ambiguous-list" class="space-y-2 max-h-48 overflow-y-auto"></div>
                            </div>
                            <!-- Leghe Non Trovate -->
                            <div id="leagues-notfound" class="hidden">
                                <h5 class="font-bold text-red-700 mb-2">‚ùå Leghe Non Trovate:</h5>
                                <div id="leagues-notfound-list" class="space-y-2 max-h-48 overflow-y-auto"></div>
                            </div>
                            <!-- Bottone Conferma -->
                            <button id="confirm-leagues-btn" class="hidden w-full bg-purple-600 text-white font-semibold py-2 rounded-lg hover:bg-purple-700 mt-3">
                                ‚úÖ Conferma Leghe e Procedi
                            </button>
                        </div>
                    </div>
                    
                    <!-- FASE 2: COLLEGAMENTO API-FOOTBALL -->
                    <div id="api-reconciliation-area" class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg opacity-50" style="pointer-events: none;">
                        <div class="flex items-center justify-between">
                            <div>
                                <h4 class="font-bold text-blue-800">üîó Fase 2: Collegamento Fixture ID</h4>
                                <p class="text-sm text-blue-600">Associa le partite agli ID API (prima completa Fase 1)</p>
                            </div>
                            <button id="sync-api-ids-btn" class="bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-blue-700 transition-colors" disabled>
                                üîó Associa Fixture ID
                            </button>
                        </div>
                        <div id="api-sync-status" class="mt-3 hidden"></div>
                        
                        <!-- Lista Partite Non Accoppiate -->
                        <div id="unmatched-matches-container" class="mt-4 hidden">
                            <h5 class="font-bold text-orange-700 mb-2">‚ö†Ô∏è Partite senza ID API:</h5>
                            <div id="unmatched-matches-list" class="space-y-2 max-h-60 overflow-y-auto">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                    </div>
                    ` : ''}
                    
                    <!--STRATEGY REPORT CONTAINER (Initially Hidden)-->
                    <div id="strategy-report-container" class="mt-4 hidden bg-blue-50 p-4 rounded-lg border border-blue-200">
                        <h4 class="font-bold text-blue-800 mb-2">üìä Report Strategie Client (${matchDate}):</h4>
                        <ul id="strategy-report-list" class="text-sm space-y-1 text-blue-700">
                            <!-- Populated by JS after upload -->
                        </ul>
                    </div>

                    <button id="confirm-${type}-upload-btn" class="mt-4 w-full bg-green-600 text-white font-semibold py-2 rounded-lg hover:bg-green-700">
                        Conferma e Carica
                    </button>
            `;

                document.getElementById(`confirm-${type}-upload-btn`).addEventListener('click', () => {
                    console.log(`Button confirm - ${type} -upload - btn clicked!`);
                    handleUploadConfirmed(type);
                });

                // Event listener per bottone "Carica ID API" (solo per tips)
                if (type === 'tips') {
                    // Inizializza stato catalogo
                    initCatalogStatus();

                    // Download Catalogo
                    const downloadCatalogBtn = document.getElementById('download-catalog-btn');
                    if (downloadCatalogBtn) {
                        downloadCatalogBtn.addEventListener('click', downloadLeagueCatalog);
                    }

                    // FASE 1: Ricerca Leghe
                    const searchLeaguesBtn = document.getElementById('search-leagues-btn');
                    if (searchLeaguesBtn) {
                        searchLeaguesBtn.addEventListener('click', () => {
                            const currentMatchDate = document.getElementById('tips-date').value;
                            if (!currentMatchDate) return alert("Seleziona una data valida!");

                            // Aggiorna data nei record prima di procedere
                            dataToUpload.forEach(m => m.data = currentMatchDate);

                            searchLeagues(currentMatchDate);
                        });
                    }

                    // FASE 2: Associa Fixture ID
                    const syncBtn = document.getElementById('sync-api-ids-btn');
                    if (syncBtn) {
                        syncBtn.addEventListener('click', () => {
                            const currentMatchDate = document.getElementById('tips-date').value;
                            if (!currentMatchDate) return alert("Seleziona una data valida!");

                            // Aggiorna data nei record prima di procedere
                            dataToUpload.forEach(m => m.data = currentMatchDate);

                            reconcileMatchesWithAPI(currentMatchDate);
                        });
                    }
                }
            }

            // ==================== CATALOGO LEGHE ====================

            async function initCatalogStatus() {
                const countSpan = document.getElementById('catalog-count');
                if (!countSpan) return;

                try {
                    const catalog = await window.LocalDB.getCatalog();
                    if (catalog && catalog.length > 0) {
                        countSpan.textContent = `${catalog.length} leghe caricate`;
                        countSpan.classList.add('text-green-600', 'font-bold');
                    } else {
                        countSpan.textContent = 'vuoto - clicca per scaricare';
                        countSpan.classList.add('text-orange-600');
                    }
                } catch (e) {
                    countSpan.textContent = 'errore';
                    countSpan.classList.add('text-red-600');
                }
            }

            async function downloadLeagueCatalog() {
                const btn = document.getElementById('download-catalog-btn');
                const countSpan = document.getElementById('catalog-count');

                if (!btn || !countSpan) return;

                btn.disabled = true;
                btn.textContent = '‚è≥ Scaricando...';
                countSpan.textContent = 'download in corso...';

                try {
                    if (typeof window.getFootballData !== 'function') {
                        throw new Error('Bridge API non disponibile');
                    }

                    // Chiamata API per tutte le leghe
                    const result = await window.getFootballData({
                        endpoint: 'leagues',
                        params: {} // Nessun parametro = tutte le leghe
                    });

                    if (!result || !result.data || !result.data.response) {
                        throw new Error('Risposta API vuota');
                    }

                    // Trasforma in formato semplificato
                    const leagues = result.data.response.map(l => ({
                        id: l.league.id,
                        name: l.league.name,
                        type: l.league.type,
                        logo: l.league.logo,
                        country: l.country.name,
                        countryCode: l.country.code,
                        countryFlag: l.country.flag
                    }));

                    // Salva nel catalogo locale
                    await window.LocalDB.saveCatalog(leagues);

                    countSpan.textContent = `${leagues.length} leghe caricate ‚úÖ`;
                    countSpan.classList.remove('text-orange-600');
                    countSpan.classList.add('text-green-600', 'font-bold');

                    console.log(`[Catalog] Downloaded and saved ${leagues.length} leagues`);

                } catch (err) {
                    console.error('[Catalog] Download error:', err);
                    countSpan.textContent = `Errore: ${err.message} `;
                    countSpan.classList.add('text-red-600');
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'üì• Scarica Catalogo';
                }
            }


            // ==================== FASE 1: SEARCH LEAGUES ====================
            let resolvedLeaguesMap = {}; // Mappa label -> leagueId (popolata da searchLeagues)

            async function searchLeagues(matchDate) {
                const statusDiv = document.getElementById('league-search-status');
                const reportContainer = document.getElementById('league-report-container');
                const searchBtn = document.getElementById('search-leagues-btn');

                if (!dataToUpload || dataToUpload.length === 0) {
                    console.warn('[League Search] No data to process');
                    return;
                }

                // Reset
                resolvedLeaguesMap = {};
                searchBtn.disabled = true;
                searchBtn.innerHTML = '‚è≥ Ricerca...';
                statusDiv.classList.remove('hidden');
                statusDiv.innerHTML = `<div class="text-purple-700"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Estrazione leghe uniche...</div>`;

                // Categorie
                const confirmed = []; // Gi√† nel DB
                const newFound = [];  // Trovate nuove con certezza
                const ambiguous = []; // Multiple opzioni
                const notFound = [];  // Non trovate

                try {
                    // 1. Estrai leghe uniche
                    const uniqueLeagues = [...new Set(dataToUpload.map(m => m.lega))];
                    statusDiv.innerHTML = `<div class="text-purple-700"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Analisi di ${uniqueLeagues.length} leghe...</div>`;

                    for (let i = 0; i < uniqueLeagues.length; i++) {
                        const label = uniqueLeagues[i];
                        statusDiv.innerHTML = `<div class="text-purple-700"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Analisi ${i + 1}/${uniqueLeagues.length}: ${label}</div>`;

                        // Check DB locale
                        const existing = await window.LocalDB.getLeagueMapping(label);
                        if (existing && existing.leagueId) {
                            confirmed.push({ label, id: existing.leagueId, meta: existing });
                            resolvedLeaguesMap[label] = existing.leagueId;
                            continue;
                        }

                        // Tenta Auto-Discovery
                        const discovery = await window.autoDiscoverLeague(label);

                        if (discovery) {
                            if (discovery.status === 'found') {
                                newFound.push({ label, id: discovery.id });
                                resolvedLeaguesMap[label] = discovery.id;
                            } else if (discovery.status === 'ambiguous') {
                                ambiguous.push({ label, options: discovery.options });
                            } else {
                                notFound.push({ label });
                            }
                        } else {
                            notFound.push({ label });
                        }
                    }

                    // 2. Mostra Report
                    statusDiv.classList.add('hidden');
                    reportContainer.classList.remove('hidden');

                    // Confermate (üî• NEW: Con editor ID)
                    if (confirmed.length > 0) {
                        document.getElementById('leagues-confirmed').classList.remove('hidden');
                        document.getElementById('leagues-confirmed-list').innerHTML = confirmed.map((l, idx) => `
                            <div class="flex items-center gap-2 mb-2 bg-green-50 p-2 rounded border border-green-200">
                                <span class="flex-1 text-sm font-medium text-green-800">${l.label}</span>
                                <input type="number" id="edit-confirmed-${idx}" value="${l.id}" 
                                       class="w-20 p-1 text-xs border border-green-300 rounded" 
                                       data-label="${l.label}" data-original="${l.id}">
                                <button onclick="updateLeagueId('${l.label.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', document.getElementById('edit-confirmed-${idx}').value, ${l.id})" 
                                        class="bg-green-600 text-white px-2 py-1 text-[10px] rounded hover:bg-green-700 font-bold">
                                    üíæ Salva
                                </button>
                            </div>
                        `).join('');
                    }

                    // Nuove (üî• NEW: Con editor ID)
                    if (newFound.length > 0) {
                        document.getElementById('leagues-new').classList.remove('hidden');
                        document.getElementById('leagues-new-list').innerHTML = newFound.map((l, idx) => `
                            <div class="flex items-center gap-2 mb-2 bg-blue-50 p-2 rounded border border-blue-200">
                                <span class="flex-1 text-sm font-medium text-blue-800">${l.label}</span>
                                <input type="number" id="edit-new-${idx}" value="${l.id}" 
                                       class="w-20 p-1 text-xs border border-blue-300 rounded" 
                                       data-label="${l.label}" data-original="${l.id}">
                                <button onclick="updateLeagueId('${l.label.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', document.getElementById('edit-new-${idx}').value, ${l.id})" 
                                        class="bg-blue-600 text-white px-2 py-1 text-[10px] rounded hover:bg-blue-700 font-bold">
                                    üíæ Salva
                                </button>
                            </div>
                        `).join('');
                    }

                    // Ambigue
                    if (ambiguous.length > 0) {
                        document.getElementById('leagues-ambiguous').classList.remove('hidden');
                        document.getElementById('leagues-ambiguous-list').innerHTML = ambiguous.map((l, idx) => `
                            <div class="bg-orange-100 p-2 rounded border border-orange-200">
                                <div class="font-medium text-orange-800 mb-1">${l.label}</div>
                                <select id="ambiguous-select-${idx}" class="w-full p-1 rounded border text-sm" data-label="${l.label}">
                                    <option value="">-- Scegli --</option>
                                    ${l.options.map(o => `<option value="${o.id}">${o.name} (${o.country}) - ID ${o.id}</option>`).join('')}
                                </select>
                            </div>
            `).join('');
                    }

                    // Non trovate
                    if (notFound.length > 0) {
                        document.getElementById('leagues-notfound').classList.remove('hidden');
                        document.getElementById('leagues-notfound-list').innerHTML = notFound.map((l, idx) => `
                            <div class="bg-red-100 p-2 rounded border border-red-200">
                                <div class="font-medium text-red-800 mb-1">${l.label}</div>
                                <div class="flex gap-2">
                                    <input type="number" id="manual-id-${idx}" placeholder="ID manuale" class="flex-1 p-1 rounded border text-sm" data-label="${l.label}">
                                    <button class="text-xs bg-gray-200 px-2 rounded hover:bg-gray-300" onclick="this.parentElement.parentElement.remove()">Ignora</button>
                                </div>
                            </div>
            `).join('');
                    }

                    // Bottone conferma
                    const confirmBtn = document.getElementById('confirm-leagues-btn');
                    confirmBtn.classList.remove('hidden');
                    confirmBtn.onclick = () => confirmLeagueSelections(ambiguous.length, notFound.length);

                    searchBtn.disabled = false;
                    searchBtn.innerHTML = 'üîç Ricerca Leghe';

                } catch (err) {
                    console.error('[League Search] Error:', err);
                    statusDiv.innerHTML = `<div class="text-red-600">‚ùå Errore: ${err.message}</div>`;
                    searchBtn.disabled = false;
                    searchBtn.innerHTML = 'üîç Ricerca Leghe';
                }
            }

            // Conferma selezioni ambigue/manuali e sblocca Fase 2
            async function confirmLeagueSelections(ambiguousCount, notFoundCount) {
                // Raccogli selezioni da dropdown ambigue
                for (let i = 0; i < ambiguousCount; i++) {
                    const select = document.getElementById(`ambiguous-select-${i}`);
                    if (select && select.value) {
                        const label = select.dataset.label;
                        const id = parseInt(select.value);
                        resolvedLeaguesMap[label] = id;
                        // Salva nel DB
                        await window.LocalDB.saveLeagueMapping(label, id, { source: 'user_selection' });
                    }
                }

                // Raccogli ID manuali
                for (let i = 0; i < notFoundCount; i++) {
                    const input = document.getElementById(`manual-id-${i}`);
                    if (input && input.value) {
                        const label = input.dataset.label;
                        const id = parseInt(input.value);
                        if (!isNaN(id)) {
                            resolvedLeaguesMap[label] = id;
                            await window.LocalDB.saveLeagueMapping(label, id, { source: 'manual_input' });
                        }
                    }
                }

                // Sblocca Fase 2
                const phase2Area = document.getElementById('api-reconciliation-area');
                const syncBtn = document.getElementById('sync-api-ids-btn');
                phase2Area.style.opacity = '1';
                phase2Area.style.pointerEvents = 'auto';
                syncBtn.disabled = false;

                // Nascondi report leghe
                document.getElementById('league-report-container').classList.add('hidden');
                document.getElementById('league-search-status').classList.remove('hidden');
                document.getElementById('league-search-status').innerHTML = `<div class="text-green-600 font-bold">‚úÖ ${Object.keys(resolvedLeaguesMap).length} leghe risolte. Procedi con Fase 2!</div>`;
            }

            // üî• NEW: Funzione per modificare e salvare league ID da UI
            window.updateLeagueId = async function (leagueLabel, newId, originalId) {
                const id = parseInt(newId);
                if (isNaN(id) || id <= 0) {
                    alert('‚ùå ID non valido! Inserisci un numero positivo.');
                    return;
                }

                try {
                    // Aggiorna mapping in RAM
                    resolvedLeaguesMap[leagueLabel] = id;

                    // Salva nel Database locale
                    await window.LocalDB.saveLeagueMapping(leagueLabel, id, {
                        source: 'user_edit',
                        editedAt: Date.now(),
                        previousId: originalId
                    });

                    console.log(`[League ID Update] "${leagueLabel}": ${originalId} ‚Üí ${id}`);
                    alert(`‚úÖ ID aggiornato!\n\n"${leagueLabel}"\n\nNuovo ID: ${id}\n\nSalvato nel database locale.`);

                } catch (error) {
                    console.error('[League ID Update] Error:', error);
                    alert(`‚ùå Errore nel salvataggio: ${error.message}`);
                }
            };


            // ==================== API ID RECONCILIATION ====================
            async function reconcileMatchesWithAPI(matchDate) {
                const statusDiv = document.getElementById('api-sync-status');
                const unmatchedContainer = document.getElementById('unmatched-matches-container');
                const unmatchedList = document.getElementById('unmatched-matches-list');
                const syncBtn = document.getElementById('sync-api-ids-btn');

                if (!statusDiv || !dataToUpload || dataToUpload.length === 0) {
                    console.warn('[API Reconcile] No data to reconcile');
                    return;
                }

                // Disabilita bottone e mostra progress
                syncBtn.disabled = true;
                syncBtn.innerHTML = '‚è≥ Caricamento...';
                statusDiv.classList.remove('hidden');
                statusDiv.innerHTML = `<div class="text-blue-700"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento fixtures per ${matchDate}...</div>`;

                try {
                    // USA LEGHE GI√Ä RISOLTE DA FASE 1
                    const labelsToId = { ...resolvedLeaguesMap };
                    const teamsList = [...new Set(dataToUpload.flatMap(m => [m.casa, m.trasferta]).filter(Boolean))];

                    // 1. Estrai leghe uniche da caricare e cerca nel DB quelle mancanti
                    const uniqueLeagues = [...new Set(dataToUpload.map(m => m.lega))];
                    for (const label of uniqueLeagues) {
                        if (!labelsToId[label]) {
                            const existing = await window.LocalDB.getLeagueMapping(label);
                            if (existing && existing.leagueId) {
                                labelsToId[label] = existing.leagueId;
                                console.log(`[Phase 2] Recuperato ID ${existing.leagueId} per "${label}" dal database locale.`);
                            }
                        }
                    }

                    // STEP 1: Load fixtures for TODAY and YESTERDAY (covers timezone shifts)
                    const dateObj = new Date(matchDate);
                    dateObj.setDate(dateObj.getDate() - 1);
                    const yesterdayStr = dateObj.toISOString().split('T')[0];

                    statusDiv.innerHTML = `<div class="text-blue-700"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento fixtures (Oggi + Ieri)...</div>`;

                    const [fixturesToday, fixturesYesterday] = await Promise.all([
                        loadDailyFixtures(matchDate),
                        loadDailyFixtures(yesterdayStr)
                    ]);

                    let fixturesPool = [...fixturesToday, ...fixturesYesterday];
                    console.log(`[Phase 2] Loaded ${fixturesPool.length} fixtures from 48h generic query`);

                    // STEP 2: Identify leagues with NO fixtures in either day
                    const uniqueLeagueIds = [...new Set(Object.values(labelsToId))].filter(id => id && !isNaN(id));
                    const leaguesInPool = new Set(fixturesPool.map(f => f.league.id));
                    const missingLeagueIds = uniqueLeagueIds.filter(id => !leaguesInPool.has(id));


                    // STEP 3: Fetch missing leagues in PARALLEL (only 3-4 calls typically)
                    if (missingLeagueIds.length > 0) {
                        console.log(`[Phase 2] üîÑ Fetching ${missingLeagueIds.length} missing leagues in parallel:`, missingLeagueIds);
                        statusDiv.innerHTML = `<div class="text-blue-700"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricando ${missingLeagueIds.length} leghe mancanti...</div>`;

                        const fetchPromises = missingLeagueIds.map(async (leagueId) => {
                            try {
                                const dateParts = matchDate.split('-');
                                let season = dateParts[0];
                                if (parseInt(dateParts[1]) < 7) season = (parseInt(season) - 1).toString();

                                if (typeof window.getFootballData !== 'function') return [];
                                const result = await window.getFootballData({
                                    endpoint: 'fixtures',
                                    params: { league: leagueId, date: matchDate, season: season }
                                });
                                const data = result.data;
                                apiCallsToday++;
                                if (data.response && data.response.length > 0) {
                                    console.log(`[Phase 2] ‚úÖ League ${leagueId}: Found ${data.response.length} fixtures on ${matchDate}`);
                                    return data.response.map(f => ({
                                        fixture: { id: f.fixture.id, date: f.fixture.date, status: f.fixture.status },
                                        teams: {
                                            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
                                            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo }
                                        },
                                        league: { id: f.league.id, name: f.league.name, country: f.league.country, logo: f.league.logo },
                                        score: f.score,
                                        goals: f.goals
                                    }));
                                } else {
                                    // FALLBACK: Try yesterday's date (for 00:30 matches etc)
                                    console.log(`[Phase 2] ‚ö†Ô∏è League ${leagueId}: No fixtures for ${matchDate}. Trying yesterday...`);

                                    // Calculate yesterday correctly handling string dates
                                    const dateObj = new Date(matchDate);
                                    dateObj.setDate(dateObj.getDate() - 1);
                                    const yesterdayStr = dateObj.toISOString().split('T')[0];

                                    if (typeof window.getFootballData !== 'function') return [];
                                    const resultYesterday = await window.getFootballData({
                                        endpoint: 'fixtures',
                                        params: { league: leagueId, date: yesterdayStr, season: season }
                                    });
                                    const dataYesterday = resultYesterday.data;
                                    apiCallsToday++; // Count extra call

                                    if (dataYesterday.response && dataYesterday.response.length > 0) {
                                        console.log(`[Phase 2] ‚úÖ League ${leagueId}: Found ${dataYesterday.response.length} fixtures on FALLBACK ${yesterdayStr}`);
                                        return dataYesterday.response.map(f => ({
                                            fixture: { id: f.fixture.id, date: f.fixture.date, status: f.fixture.status },
                                            teams: {
                                                home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
                                                away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo }
                                            },
                                            league: { id: f.league.id, name: f.league.name, country: f.league.country, logo: f.league.logo },
                                            score: f.score,
                                            goals: f.goals
                                        }));
                                    }

                                    console.log(`[Phase 2] ‚ùå League ${leagueId}: No fixtures found on ${matchDate} or ${yesterdayStr}`);
                                    return [];
                                }
                            } catch (err) {
                                console.error(`[Phase 2] Error fetching league ${leagueId}:`, err);
                                return [];
                            }
                        });

                        const additionalFixtures = await Promise.all(fetchPromises);
                        const flatAdditional = additionalFixtures.flat();
                        fixturesPool = [...fixturesPool, ...flatAdditional];
                        console.log(`[Phase 2] ‚úÖ Total fixtures after hybrid fetch: ${fixturesPool.length}`);
                    }

                    if (!fixturesPool || fixturesPool.length === 0) {
                        statusDiv.innerHTML = `<div class="text-orange-600">‚ö†Ô∏è Nessuna fixture trovata per ${matchDate}.</div>`;
                        syncBtn.disabled = false;
                        syncBtn.innerHTML = 'üîó Associa Fixture ID';
                        return;
                    }

                    console.log(`[Phase 2] Ready to match with ${fixturesPool.length} total fixtures`);



                    statusDiv.innerHTML = `<div class="text-blue-700"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Matching a 4 Step (Casa -> Trasferta -> Manuale)...</div>`;

                    let matchedCount = 0;
                    let unmatchedCount = 0;
                    let postponedCount = 0;
                    const pendingManual = [];

                    // Tracking delle fixture API gi√† usate per evitare doppioni
                    const usedFixtureIds = new Set();

                    // Pre-fill used IDs from already matched ones
                    dataToUpload.forEach(m => { if (m.fixtureId) usedFixtureIds.add(m.fixtureId); });

                    // LOGICA A 4 STEP
                    for (const match of dataToUpload) {
                        // SKIP se gi√† associato manuale
                        if (match.fixtureId) {
                            matchedCount++;
                            continue;
                        }

                        const leagueId = labelsToId[match.lega];
                        if (!leagueId) {
                            pendingManual.push(match);
                            unmatchedCount++;
                            continue;
                        }

                        // Filtra pool per lega (Recinto Sicuro) - Ora include anche "ieri"
                        const leaguePool = fixturesPool.filter(f => f.league.id === leagueId && !usedFixtureIds.has(f.fixture.id));

                        // üîç DIAGNOSTIC: Log when league has no fixtures in API response
                        if (leaguePool.length === 0) {
                            console.warn(`[Phase 2 DIAGNOSTIC] ‚ö†Ô∏è League ID ${leagueId} ("${match.lega}"): 0 fixtures in generic API response`);
                        } else {
                            console.log(`[Phase 2 DIAGNOSTIC] ‚úÖ League ID ${leagueId} ("${match.lega}"): ${leaguePool.length} fixtures available`);
                        }


                        // STEP 1: Match per Casa
                        let fixture = findMatchingFixture(match.partita, leaguePool, 'home');

                        // STEP 2: Match per Trasferta (se fallisce step 1)
                        if (!fixture) {
                            fixture = findMatchingFixture(match.partita, leaguePool, 'away');
                        }

                        if (fixture) {
                            // Associa dati
                            applyFixtureToMatch(match, fixture);
                            usedFixtureIds.add(fixture.fixture.id);
                            matchedCount++;
                        } else {
                            // STEP 3: Messa da parte
                            pendingManual.push(match);
                            unmatchedCount++;
                        }
                    }

                    // üõ†Ô∏è DEBUG POST-MATCHING
                    const withId = dataToUpload.filter(m => m.fixtureId).length;
                    console.log(`[Phase 2 DEBUG] Matching completato. Partite con ID: ${withId} su ${dataToUpload.length}`);
                    if (withId > 0) {
                        console.log(`[Phase 2 DEBUG] Esempio Match 1 con ID:`, dataToUpload.find(m => m.fixtureId));
                    }

                    // Helper interno per applicare i dati
                    function applyFixtureToMatch(m, f) {
                        m.fixtureId = f.fixture.id;
                        m.homeLogo = f.teams.home.logo;
                        m.awayLogo = f.teams.away.logo;
                        m.homeId = f.teams.home.id;   // üî• FIX: Per Monte Carlo stats
                        m.awayId = f.teams.away.id;   // üî• FIX: Per Monte Carlo stats
                        m.leagueLogo = f.league.logo;
                        m.apiStatus = f.fixture.status?.short || 'NS';

                        if (['PST', 'CANC', 'ABD', 'TBD'].includes(m.apiStatus)) {
                            postponedCount++;
                        }

                        if (f.fixture.date) {
                            // Protocollo Timezone üáÆüáπ: Convert UTC to Italy Time correctly (DST-aware)
                            const date = new Date(f.fixture.date);
                            const options = { timeZone: 'Europe/Rome', hour: '2-digit', minute: '2-digit', hour12: false };
                            const formatter = new Intl.DateTimeFormat('it-IT', options);
                            m.api_time = formatter.format(date).replace('.', ':');

                            // Protocollo ID-Pure: Store original UTC timestamp for calculations
                            m.kickoffTimestamp = f.fixture.timestamp * 1000;
                        }
                    }

                    // Rendi globale per la UI manuale
                    window.manualAssociateFixture = function (matchPartita, fixtureId) {
                        const match = dataToUpload.find(m => m.partita === matchPartita);
                        const fixture = fixturesPool.find(f => f.fixture.id === parseInt(fixtureId));

                        if (match && fixture) {
                            applyFixtureToMatch(match, fixture);
                            console.log(`[Manual association] Coupled "${match.partita}" with fixture ${fixtureId}`);
                            reconcileMatchesWithAPI(matchDate); // Refresh UI
                        }
                    };



                    // 3. Mostra risultato arricchito
                    const successRate = Math.round((matchedCount / dataToUpload.length) * 100);
                    statusDiv.innerHTML = `
                        <div class="space-y-2">
                            <div class="flex items-center justify-between">
                                <div>
                                    <span class="text-green-600 font-bold">‚úÖ ${matchedCount} partite collegate</span>
                                    ${unmatchedCount > 0 ? `<span class="text-orange-600 ml-3">‚ö†Ô∏è ${unmatchedCount} da verificare</span>` : ''}
                                </div>
                                <span class="text-sm text-gray-500">${successRate}% match rate</span>
                            </div>
                            ${postponedCount > 0 ? `
                                <div class="flex items-center justify-between bg-red-50 p-2 rounded border border-red-100">
                                    <span class="text-red-600 text-sm font-medium">üö® Rilevate ${postponedCount} partite rinvitate/annullate</span>
                                    <button onclick="removePostponedMatches()" class="text-xs bg-red-600 text-white px-2 py-1 rounded hover:bg-red-700">
                                        Rimuovi ora
                                    </button>
                                </div>
                            ` : ''}
                        </div>
                    `;

                    // Funzione globale per pulire rinviate
                    window.removePostponedMatches = function () {
                        const before = dataToUpload.length;
                        dataToUpload = dataToUpload.filter(m => !['PST', 'CANC', 'ABD', 'TBD'].includes(m.apiStatus));
                        const removed = before - dataToUpload.length;
                        alert(`Rimosse ${removed} partite non attive.`);
                        reconcileMatchesWithAPI(matchDate); // Refresh UI
                    };

                    // üî• NEW: Funzione per rimuovere singola partita non trovata
                    window.removeUnmatchedFromUpload = function (matchPartita) {
                        const before = dataToUpload.length;
                        dataToUpload = dataToUpload.filter(m => m.partita !== matchPartita);
                        const removed = before - dataToUpload.length;
                        if (removed > 0) {
                            console.log(`[Remove Match] Rimossa 1 partita: ${matchPartita}`);
                            reconcileMatchesWithAPI(matchDate); // Refresh UI
                        }
                    };

                    // üî• NEW: Funzione per rimuovere TUTTE le partite senza fixture ID
                    window.removeAllUnmatchedMatches = function () {
                        const before = dataToUpload.length;
                        dataToUpload = dataToUpload.filter(m => m.fixtureId); // Mantiene solo partite con fixture ID
                        const removed = before - dataToUpload.length;
                        if (removed > 0) {
                            alert(`üóëÔ∏è Rimosse ${removed} partite senza ID API.`);
                            reconcileMatchesWithAPI(matchDate); // Refresh UI
                        } else {
                            alert('Nessuna partita da rimuovere.');
                        }
                    };

                    // 4. STEP 4: UI Risoluzione Manuale
                    if (pendingManual.length > 0) {
                        unmatchedContainer.classList.remove('hidden');
                        unmatchedList.innerHTML = `
                            <div class="bg-orange-100 p-2 rounded text-orange-800 text-xs font-bold mb-3 border border-orange-200 uppercase tracking-tight flex items-center justify-between">
                                <span>üõ†Ô∏è Risoluzione Manuale (Associa le pick rimaste alle partite API)</span>
                                <button onclick="removeAllUnmatchedMatches()" class="bg-red-600 text-white px-3 py-1 rounded text-[10px] font-bold hover:bg-red-700 transition-colors">
                                    üóëÔ∏è Cancella Tutte (${pendingManual.length})
                                </button>
                            </div>
                        ` + pendingManual.map((m, idx) => {
                            const leagueId = labelsToId[m.lega];
                            // Trova fixture della stessa lega non ancora usate (Oggi + Ieri)
                            const availableFixtures = fixturesPool.filter(f => f.league.id === leagueId && !usedFixtureIds.has(f.fixture.id));

                            const selectOptions = availableFixtures.map(f => `
                                <option value="${f.fixture.id}">${f.teams.home.name} - ${f.teams.away.name}</option>
                            `).join('');

                            return `
                                <div class="flex flex-col gap-2 bg-white p-3 rounded-lg border border-orange-200 mb-2 shadow-sm">
                                    <div class="flex items-center justify-between">
                                        <div class="flex-1">
                                            <div class="font-bold text-gray-800 text-sm">${m.partita}</div>
                                            <div class="text-[10px] text-gray-500">${m.lega} | ${m.tip} @${m.quota}</div>
                                        </div>
                                        <button onclick="removeUnmatchedFromUpload('${m.partita.replace(/'/g, "\\'")}')" 
                                                class="text-red-400 hover:text-red-600 p-1" title="Ignora partita">
                                            <i class="fa-solid fa-xmark"></i>
                                        </button>
                                    </div>
                                    <div class="flex items-center gap-2 mt-1">
                                        <select id="select-manual-${idx}" class="flex-1 bg-gray-50 border border-gray-300 text-gray-900 text-[11px] rounded-lg focus:ring-blue-500 focus:border-blue-500 p-1.5 font-medium">
                                            <option value="">-- Seleziona Partita API (${availableFixtures.length}) --</option>
                                            ${selectOptions}
                                        </select>
                                        <button onclick="window.manualAssociateFixture('${m.partita.replace(/'/g, "\\'")}', document.getElementById('select-manual-${idx}').value)" 
                                                class="bg-blue-600 text-white px-3 py-1.5 rounded-lg text-xs font-bold hover:bg-blue-700 transition-colors shadow-sm">
                                            Collega
                                        </button>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        unmatchedContainer.classList.add('hidden');
                    }

                    // üî• NEW: Salva fixtureId nel Database Oro
                    console.log('[Phase 2 DEBUG] üîç Starting save to Oro Database...');
                    console.log('[Phase 2 DEBUG] dataToUpload count:', dataToUpload.length);
                    console.log('[Phase 2 DEBUG] window.allMatches count:', window.allMatches.length);
                    console.log('[Phase 2 DEBUG] matchedCount:', matchedCount);

                    try {
                        let updateCount = 0;
                        for (const match of dataToUpload) {
                            if (match.fixtureId) {
                                console.log(`[Phase 2 DEBUG] Processing: ${match.partita} | fixtureId: ${match.fixtureId}`);

                                // Cerca match nel DB Oro per data+partita
                                const existing = window.allMatches.find(m =>
                                    m.data === match.data && m.partita === match.partita
                                );

                                if (existing) {
                                    console.log(`[Phase 2 DEBUG] ‚úÖ FOUND in Oro: ${existing.partita} | OLD fixtureId: ${existing.fixtureId || 'NONE'}`);
                                    // Aggiorna record esistente con dati API
                                    existing.fixtureId = match.fixtureId;
                                    existing.homeId = match.homeId;         // IDs per Stats
                                    existing.awayId = match.awayId;         // IDs per Stats
                                    existing.teamIdHome = match.homeId;     // IDs per Standings
                                    existing.teamIdAway = match.awayId;     // IDs per Standings
                                    existing.homeLogo = match.homeLogo;
                                    existing.awayLogo = match.awayLogo;
                                    existing.leagueLogo = match.leagueLogo;
                                    existing.apiStatus = match.apiStatus;
                                    existing.api_time = match.api_time;
                                    updateCount++;
                                    console.log(`[Phase 2 DEBUG] ‚úÖ Updated: ${match.partita} ‚Üí NEW fixtureId: ${match.fixtureId}`);
                                } else {
                                    console.log(`[Phase 2 DEBUG] ‚ùå NOT FOUND in Oro: ${match.partita}`);
                                }
                            }
                        }

                        console.log(`[Phase 2 DEBUG] üíæ Saving ${updateCount} updated matches to Oro...`);
                        // Salva DB Oro aggiornato
                        await window.LocalDB.saveMatches(window.allMatches);
                        console.log(`[Phase 2 DEBUG] ‚úÖ Oro Database saved! Total: ${window.allMatches.length}`);

                        // üî• NEW: Sincronizzazione Sandbox per lo Step 1
                        try {
                            const magiaMatches = await window.LocalDB.loadMagiaMatches();
                            let sandboxUpdated = 0;
                            dataToUpload.forEach(m => {
                                if (m.fixtureId) {
                                    const sandboxMatch = magiaMatches.find(sm => sm.data === m.data && sm.partita === m.partita);
                                    if (sandboxMatch) {
                                        sandboxMatch.fixtureId = m.fixtureId;
                                        sandboxMatch.homeId = m.homeId;
                                        sandboxMatch.awayId = m.awayId;
                                        sandboxMatch.teamIdHome = m.homeId;
                                        sandboxMatch.teamIdAway = m.awayId;
                                        sandboxUpdated++;
                                    }
                                }
                            });
                            if (sandboxUpdated > 0) {
                                await window.LocalDB.saveMagiaMatches(magiaMatches);
                                console.log(`[Phase 2] ‚úÖ Sandbox sincronizzata: ${sandboxUpdated} partite.`);
                            }
                        } catch (magiaErr) { console.warn("[Phase 2] Sandbox Sync Error", magiaErr); }

                    } catch (saveErr) {
                        console.error('[Phase 2 DEBUG] ‚ùå Error saving to Oro:', saveErr);
                        statusDiv.innerHTML += `<div class="text-orange-600 mt-2">‚ö†Ô∏è Salvataggio parziale. Riprova.</div>`;
                    }

                    // 5. Riabilita bottone
                    syncBtn.disabled = false;
                    syncBtn.innerHTML = '‚úÖ ID Caricati';
                    syncBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    syncBtn.classList.add('bg-green-600', 'hover:bg-green-700');

                } catch (error) {
                    console.error('[API Reconcile] Error:', error);
                    statusDiv.innerHTML = `<div class="text-red-600">‚ùå Errore: ${error.message}</div>`;
                    syncBtn.disabled = false;
                    syncBtn.innerHTML = 'üîÑ Carica ID API';
                }
            }

            // Funzione per rimuovere partita non-matched dal caricamento
            window.removeUnmatchedFromUpload = function (partitaName) {
                dataToUpload = dataToUpload.filter(m => m.partita !== partitaName);

                // Rimuovi dalla UI
                const listItem = document.querySelector(`[data-match-idx].font-medium`);
                if (listItem && listItem.textContent === partitaName) {
                    listItem.closest('[data-match-idx]').remove();
                }

                // Refresh lista unmatched
                const unmatchedList = document.getElementById('unmatched-matches-list');
                const unmatchedContainer = document.getElementById('unmatched-matches-container');
                if (unmatchedList && unmatchedList.children.length === 0) {
                    unmatchedContainer.classList.add('hidden');
                }

                // Aggiorna conteggio totale
                const totalLi = document.querySelector('.text-purple-700');
                if (totalLi) {
                    totalLi.textContent = `üìä Totale operazioni: ${dataToUpload.length} `;
                }

                console.log(`[Remove Unmatched]Rimossa: ${partitaName}.Restanti: ${dataToUpload.length} `);
            };

            // ==================== BULK FIND & REPLACE LOGIC (WITH PREVIEW + CHECKBOXES) ====================
            let bulkMatchesCache = []; // Store matches for the replace step

            const bulkPreviewBtn = document.getElementById('bulk-preview-btn');
            const bulkReplaceBtn = document.getElementById('bulk-replace-btn');
            const bulkPreviewArea = document.getElementById('bulk-preview-area');
            const bulkPreviewList = document.getElementById('bulk-preview-list');
            const bulkPreviewCount = document.getElementById('bulk-preview-count');
            const bulkStatusEl = document.getElementById('bulk-replace-status');
            const bulkSelectAllBtn = document.getElementById('bulk-select-all');
            const bulkDeselectAllBtn = document.getElementById('bulk-deselect-all');
            const bulkClearDatesBtn = document.getElementById('bulk-clear-dates');

            // Clear dates button
            if (bulkClearDatesBtn) {
                bulkClearDatesBtn.addEventListener('click', () => {
                    document.getElementById('bulk-date-from').value = '';
                    document.getElementById('bulk-date-to').value = '';
                });
            }

            // Select All / Deselect All buttons
            if (bulkSelectAllBtn) {
                bulkSelectAllBtn.addEventListener('click', () => {
                    document.querySelectorAll('.bulk-item-checkbox').forEach(cb => cb.checked = true);
                    updateSelectedCount();
                });
            }
            if (bulkDeselectAllBtn) {
                bulkDeselectAllBtn.addEventListener('click', () => {
                    document.querySelectorAll('.bulk-item-checkbox').forEach(cb => cb.checked = false);
                    updateSelectedCount();
                });
            }

            function updateSelectedCount() {
                const checked = document.querySelectorAll('.bulk-item-checkbox:checked').length;
                const total = document.querySelectorAll('.bulk-item-checkbox').length;
                if (bulkPreviewCount) {
                    bulkPreviewCount.innerHTML = `<i class="fa-solid fa-list mr-1"></i> Selezionati <strong>${checked}</strong> di ${total} record`;
                }
                if (bulkReplaceBtn) {
                    bulkReplaceBtn.disabled = checked === 0;
                }
            }

            // PREVIEW BUTTON - Shows matches before replacing
            if (bulkPreviewBtn) {
                bulkPreviewBtn.addEventListener('click', () => {
                    const findVal = document.getElementById('bulk-find-input')?.value.trim();
                    const replaceVal = document.getElementById('bulk-replace-input')?.value.trim() || '';
                    const column = document.getElementById('bulk-column-select')?.value || 'lega';
                    const exactMatch = document.getElementById('bulk-exact-match')?.checked || false;
                    const dateFrom = document.getElementById('bulk-date-from')?.value || '';
                    const dateTo = document.getElementById('bulk-date-to')?.value || '';

                    if (!findVal) {
                        alert("Inserisci il valore da trovare!");
                        return;
                    }

                    // Search logic with date filter
                    bulkMatchesCache = allMatches.filter(m => {
                        const val = String(m[column] || '').trim();
                        const matchesText = exactMatch ? val === findVal : val.includes(findVal);

                        // Date filter
                        if (!matchesText) return false;
                        if (dateFrom && m.data < dateFrom) return false;
                        if (dateTo && m.data > dateTo) return false;

                        return true;
                    });

                    if (bulkMatchesCache.length === 0) {
                        bulkPreviewArea.classList.add('hidden');
                        if (bulkStatusEl) {
                            bulkStatusEl.classList.remove('hidden');
                            bulkStatusEl.className = 'mt-4 p-3 rounded-lg text-sm bg-yellow-100 text-yellow-700';
                            bulkStatusEl.textContent = `‚ö†Ô∏è Nessuna corrispondenza trovata per "${findVal}" nel campo ${column}${dateFrom || dateTo ? ' (con filtro date)' : ''}.`;
                        }
                        if (bulkReplaceBtn) bulkReplaceBtn.disabled = true;
                        return;
                    }

                    // Show preview
                    if (bulkStatusEl) bulkStatusEl.classList.add('hidden');
                    bulkPreviewArea.classList.remove('hidden');

                    // Generate preview list with checkboxes (show all, max 200 for performance)
                    const maxShow = 200;
                    const itemsToShow = bulkMatchesCache.slice(0, maxShow);
                    const previewItems = itemsToShow.map((m, idx) => {
                        const oldVal = m[column] || '';
                        const newVal = exactMatch ? replaceVal : oldVal.replace(new RegExp(findVal, 'g'), replaceVal);
                        return `
            <div class="flex items-center gap-2 p-2 border-b border-gray-200 last:border-0 hover:bg-gray-100">
                <input type="checkbox" class="bulk-item-checkbox rounded text-purple-600" data-idx="${idx}" checked>
                    <span class="text-gray-500 text-xs w-20">${m.data || '-'}</span>
                    <span class="text-gray-400 text-xs truncate max-w-32" title="${m.partita || ''}">${(m.partita || '').substring(0, 25)}${(m.partita || '').length > 25 ? '...' : ''}</span>
                    <span class="bg-red-100 text-red-700 px-2 py-1 rounded font-mono text-xs line-through">${oldVal}</span>
                    <i class="fa-solid fa-arrow-right text-gray-400 text-xs"></i>
                    <span class="bg-green-100 text-green-700 px-2 py-1 rounded font-mono text-xs">${newVal}</span>
                </div>
        `;
                    }).join('');

                    const moreCount = bulkMatchesCache.length > maxShow ? `<div class="text-center text-yellow-600 text-xs p-2 bg-yellow-50 rounded">‚ö†Ô∏è Mostrati solo primi ${maxShow} di ${bulkMatchesCache.length} record. I restanti ${bulkMatchesCache.length - maxShow} saranno comunque inclusi se selezioni tutto.</div>` : '';
                    bulkPreviewList.innerHTML = previewItems + moreCount;

                    // Add change listeners to checkboxes
                    document.querySelectorAll('.bulk-item-checkbox').forEach(cb => {
                        cb.addEventListener('change', updateSelectedCount);
                    });

                    // Store search params
                    if (bulkReplaceBtn) {
                        bulkReplaceBtn.dataset.findVal = findVal;
                        bulkReplaceBtn.dataset.replaceVal = replaceVal;
                        bulkReplaceBtn.dataset.column = column;
                        bulkReplaceBtn.dataset.exactMatch = exactMatch;
                    }

                    updateSelectedCount();
                });
            }

            // REPLACE SELECTED BUTTON - Executes the replacement
            if (bulkReplaceBtn) {
                bulkReplaceBtn.addEventListener('click', async () => {
                    const findVal = bulkReplaceBtn.dataset.findVal;
                    const replaceVal = bulkReplaceBtn.dataset.replaceVal;
                    const column = bulkReplaceBtn.dataset.column;
                    const exactMatch = bulkReplaceBtn.dataset.exactMatch === 'true';

                    // Get selected indices
                    const selectedCheckboxes = document.querySelectorAll('.bulk-item-checkbox:checked');
                    const selectedIndices = new Set(Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.idx)));

                    // For items beyond the visible 200, include all if "select all" was used
                    const allChecked = document.querySelectorAll('.bulk-item-checkbox').length === selectedCheckboxes.length;

                    // Build list of matches to update
                    let matchesToUpdate = [];
                    if (allChecked && bulkMatchesCache.length > 200) {
                        // All visible are checked, so include ALL matches
                        matchesToUpdate = [...bulkMatchesCache];
                    } else {
                        // Only include checked ones
                        matchesToUpdate = bulkMatchesCache.filter((m, idx) => selectedIndices.has(idx));
                    }

                    if (matchesToUpdate.length === 0) {
                        alert("Seleziona almeno un record da modificare.");
                        return;
                    }

                    if (!confirm(`Confermi la sostituzione di ${matchesToUpdate.length} record selezionati ?\n\n"${findVal}" ‚Üí "${replaceVal}"\n\nQuesta operazione √® IRREVERSIBILE!`)) return;

                    bulkReplaceBtn.disabled = true;
                    bulkReplaceBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Elaborazione...';

                    try {
                        // Apply replacements
                        matchesToUpdate.forEach(m => {
                            if (exactMatch) {
                                m[column] = replaceVal;
                            } else {
                                m[column] = String(m[column] || '').replace(new RegExp(findVal, 'g'), replaceVal);
                            }
                        });

                        // Persist to IndexedDB
                        await LocalDB.saveMatches(allMatches);

                        bulkPreviewArea.classList.add('hidden');
                        if (bulkStatusEl) {
                            bulkStatusEl.classList.remove('hidden');
                            bulkStatusEl.className = 'mt-4 p-3 rounded-lg text-sm bg-green-100 text-green-700';
                            bulkStatusEl.innerHTML = `<i class="fa-solid fa-check-circle mr-2"></i>‚úÖ Aggiornati ${matchesToUpdate.length} record! Puoi continuare con altre modifiche.`;
                        }

                        bulkMatchesCache = []; // Clear cache
                        bulkReplaceBtn.disabled = true;
                        bulkReplaceBtn.innerHTML = '<i class="fa-solid fa-retweet mr-2"></i>Sostituisci Selezionati';
                    } catch (e) {
                        console.error(e);
                        alert("Errore: " + e.message);
                        bulkReplaceBtn.disabled = false;
                        bulkReplaceBtn.innerHTML = '<i class="fa-solid fa-retweet mr-2"></i>Sostituisci Selezionati';
                    }
                });
            }




            // ==================== QUICK SEARCH LOGIC ====================
            document.getElementById('quick-db-search').addEventListener('input', (e) => {
                const term = e.target.value.toLowerCase().trim();
                const tbody = document.getElementById('quick-db-results');

                if (term.length < 2) {
                    tbody.innerHTML = '<tr><td colspan="6" class="p-4 text-center text-gray-500">Digita almeno 2 caratteri...</td></tr>';
                    return;
                }

                const results = allMatches.filter(m =>
                    (m.lega && m.lega.toLowerCase().includes(term)) ||
                    (m.partita && m.partita.toLowerCase().includes(term)) ||
                    (m.tip && m.tip.toLowerCase().includes(term))
                ).slice(0, 50); // Limit to 50 for perf

                if (results.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="6" class="p-4 text-center text-gray-500">Nessun risultato.</td></tr>';
                    return;
                }

                tbody.innerHTML = results.map(m => `
            < tr class="hover:bg-gray-50 border-b" >
                        <td class="p-2">${m.data}</td>
                        <td class="p-2 font-medium text-blue-600">${m.lega}</td>
                        <td class="p-2">${m.partita}</td>
                        <td class="p-2 font-bold">${m.tip}</td>
                        <td class="p-2 text-center font-mono">${m.risultato || '-'}</td>
                        <td class="p-2 text-center">
                            <button onclick="enableEditMode('${m.id}')" class="text-blue-600 hover:text-blue-800 px-2"><i class="fa-solid fa-pencil"></i></button>
                        </td>
                    </tr >
            `).join('');
            });

            // ==================== FULL EXPORT LOGIC ====================
            document.getElementById('export-full-db-btn').addEventListener('click', () => {
                const matchesToExport = window.allMatches || allMatches;

                if (!matchesToExport || matchesToExport.length === 0) {
                    alert("Nessun dato da esportare. Carica prima un database.");
                    return;
                }

                console.log(`[Backup] Exporting ${matchesToExport.length} matches...`);

                const headers = ['id', 'data', 'leagueId', 'lega', 'partita', 'risultato', 'risultato_ht', 'probabilita', 'mercato', 'tip', 'quota', 'esito', 'info_ht', 'fixtureId', 'magia'];
                const csv = Papa.unparse(matchesToExport.map(d => ({
                    ...d,
                    quota: String(d.quota).replace('.', ',')
                })), { columns: headers });

                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `backup_completo_${new Date().toISOString().slice(0, 10)}.csv`;
                link.click();

                console.log(`[Backup] Download started: backup_completo_${new Date().toISOString().slice(0, 10)}.csv`);
            });

            // Export Storico Partite (CSV)
            document.getElementById('export-storico-btn').addEventListener('click', () => {
                const startDate = document.getElementById('export-start-date').value;
                const endDate = document.getElementById('export-end-date').value;
                const onlyResults = document.getElementById('export-only-results').checked;

                let filteredMatches = allMatches.filter(m => {
                    // Filter by date range
                    if (startDate && m.data < startDate) return false;
                    if (endDate && m.data > endDate) return false;
                    // Filter by results (if checkbox is checked)
                    if (onlyResults && !m.risultato) return false;
                    return true;
                });

                if (filteredMatches.length === 0) {
                    alert('Nessuna partita trovata con i filtri selezionati.');
                    return;
                }

                // Prepare CSV data with Italian date format
                const csvData = filteredMatches.map(m => ({
                    Data: formatDateIT(m.data),
                    Lega: m.lega,
                    Partita: m.partita,
                    Tip: m.tip,
                    Quota: String(m.quota).replace('.', ','),
                    Probabilit√†: m.probabilita ? m.probabilita + '%' : '',
                    Mercato: m.mercato,
                    Risultato: m.risultato || '',
                    Esito_Tip: m.esito || '',
                    Info_HT: m.info_ht || '',
                    Ora: m.ora || ''
                }));

                // Generate CSV
                const csv = Papa.unparse(csvData);
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const startLabel = startDate ? formatDateIT(startDate) : 'inizio';
                const endLabel = endDate ? formatDateIT(endDate) : 'oggi';
                a.download = `storico_${startLabel}_${endLabel}.csv`.replace(/\//g, '-');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            // Bulk Recalculate Esito
            const bulkRecalcBtn = document.getElementById('bulk-recalculate-esito-btn');
            if (bulkRecalcBtn) {
                bulkRecalcBtn.addEventListener('click', async () => {
                    const btn = bulkRecalcBtn;
                    const statusDiv = document.getElementById('recalc-status');

                    if (!confirm('‚ö†Ô∏è Ricalcolare gli esiti per TUTTE le partite con risultato?\n\nQuesta operazione potrebbe richiedere alcuni secondi.')) {
                        return;
                    }

                    btn.disabled = true;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Ricalcolo in corso...';
                    if (statusDiv) {
                        statusDiv.classList.remove('hidden');
                        statusDiv.innerHTML = '<i class="fa-solid fa-clock mr-2"></i>Analisi partite...';
                    }


                    try {
                        // Find matches with result but no esito OR esito = "N/D"
                        const matchesToFix = allMatches.filter(m =>
                            m.risultato && m.risultato.trim() !== '' &&
                            (!m.esito || m.esito.trim() === '' || m.esito === 'N/D')
                        );

                        if (matchesToFix.length === 0) {
                            statusDiv.innerHTML = '<div class="text-green-600"><i class="fa-solid fa-check mr-2"></i>Nessuna partita da correggere! Tutti gli esiti sono gi√† presenti.</div>';
                            btn.disabled = false;
                            btn.innerHTML = '<i class="fa-solid fa-rotate mr-2"></i>Ricalcola Tutti gli Esiti';
                            return;
                        }

                        statusDiv.innerHTML = `<i class="fa-solid fa-spinner fa-spin mr-2"></i> Ricalcolo ${matchesToFix.length} partite...`;

                        // Recalculate esito for each match
                        const batch = writeBatch(db);
                        let fixed = 0;
                        let failed = 0;

                        for (const match of matchesToFix) {
                            const newEsito = calculateOutcome(match);
                            if (newEsito && newEsito !== '') {
                                batch.update(doc(db, "matches", match.id), { esito: newEsito });
                                // Update local copy
                                const idx = allMatches.findIndex(m => m.id === match.id);
                                if (idx >= 0) allMatches[idx].esito = newEsito;
                                fixed++;
                            } else {
                                failed++;
                                console.warn('[Bulk Recalc] Could not calculate esito for:', match);
                            }
                        }

                        await batch.commit();
                        await loadAllMatches(); // Reload to refresh
                        applyFiltersAndRender(); // Refresh display

                        statusDiv.innerHTML = `
            <div class="bg-green-50 p-3 rounded border border-green-200">
                            <div class="text-green-800 font-bold"><i class="fa-solid fa-check-circle mr-2"></i>Ricalcolo completato!</div>
                            <div class="text-sm text-green-700 mt-1">‚úÖ ${fixed} partite corrette</div>
                            ${failed > 0 ? `<div class="text-sm text-yellow-700">‚ö†Ô∏è ${failed} partite non calcolabili (mercato non riconosciuto)</div>` : ''}
                        </div >
            `;

                        btn.disabled = false;
                        btn.innerHTML = '<i class="fa-solid fa-rotate mr-2"></i>Ricalcola Tutti gli Esiti';
                    } catch (e) {
                        console.error('[Bulk Recalc] Error:', e);
                        statusDiv.innerHTML = `<div class="text-red-600"><i class="fa-solid fa-exclamation-triangle mr-2"></i>Errore: ${e.message}</div>`;
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fa-solid fa-rotate mr-2"></i>Ricalcola Tutti gli Esiti';
                    }
                });
            }

            // ==================== DELETE FULL DATE ====================
            document.getElementById('delete-full-date-btn').addEventListener('click', async () => {
                const btn = document.getElementById('delete-full-date-btn');
                const statusDiv = document.getElementById('delete-date-status');
                const dateInput = document.getElementById('delete-full-date');
                const targetDate = dateInput.value;

                if (!targetDate) {
                    alert('‚ö†Ô∏è Seleziona una data da cancellare.');
                    return;
                }

                // Count matches for that date
                let matchCount = 0;
                let snapshot = null;

                if (window.USE_LOCAL_DB_ONLY) {
                    // LOCAL MODE COUNT
                    matchCount = window.allMatches.filter(m => m.data === targetDate).length;
                } else {
                    // REMOTE MODE COUNT
                    const matchesRef = collection(db, "matches");
                    const q = query(matchesRef, where("data", "==", targetDate));
                    snapshot = await getDocs(q);
                    matchCount = snapshot.size;
                }

                if (matchCount === 0) {
                    alert(`‚ö†Ô∏è Nessuna partita trovata per la data ${targetDate}.`);
                    return;
                }

                // DOUBLE CONFIRMATION
                if (!confirm(`‚ö†Ô∏è ATTENZIONE: Questa operazione eliminer√† ${matchCount} partite dalla data ${targetDate}.\n\nL'operazione √® IRREVERSIBILE.\n\nSei sicuro di voler continuare?`)) {
                    return;
                }

                if (!confirm(`‚ö†Ô∏è‚ö†Ô∏è ULTIMA CONFERMA:\n\nStai per eliminare ${matchCount} partite del ${targetDate}.\n\nConfermi definitivamente?`)) {
                    return;
                }

                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Cancellazione in corso...';
                statusDiv.classList.remove('hidden');
                statusDiv.innerHTML = '<i class="fa-solid fa-clock mr-2"></i>Cancellazione di ' + matchCount + ' partite...';

                try {
                    if (window.USE_LOCAL_DB_ONLY) {
                        // 1. Filter out matches for this date in memory
                        window.allMatches = window.allMatches.filter(m => m.data !== targetDate);

                        // 2. Persist updated array to IndexedDB
                        await LocalDB.saveMatches(window.allMatches);
                        console.log(`[Local Delete] Deleted matches for ${targetDate}`);
                    } else {
                        // Batch delete all matches for this date in Firestore
                        const batch = writeBatch(db);
                        snapshot.forEach(doc => {
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                        console.log(`[Remote Delete] Deleted matches for ${targetDate}`);
                    }

                    // ADDED: Also delete associated strategies and history for a clean slate
                    console.log(`[Delete] Cleaning strategies and history items for ${targetDate}...`);
                    const strategyBatch = [];
                    strategyBatch.push(deleteDoc(doc(db, "ranking_history", targetDate)));
                    strategyBatch.push(deleteDoc(doc(db, "rankings", targetDate)));
                    strategyBatch.push(deleteDoc(doc(db, "daily_strategies", targetDate)));
                    strategyBatch.push(deleteDoc(doc(db, "daily_trading_picks", targetDate)));

                    const todayStr = new Date().toISOString().split('T')[0];
                    if (targetDate === todayStr) {
                        strategyBatch.push(deleteDoc(doc(db, "system", "strategy_results")));
                        strategyBatch.push(deleteDoc(doc(db, "system", "client_presets")));
                    }
                    await Promise.all(strategyBatch);
                    console.log(`[Delete] Strategies and history items for ${targetDate} cleaned.`);

                    // Reload local data
                    await loadAllMatches();
                    applyFiltersAndRender();

                    statusDiv.innerHTML = `
                        <div class="bg-green-50 p-3 rounded border border-green-200">
                            <div class="text-green-800 font-bold"><i class="fa-solid fa-check-circle mr-2"></i>Cancellazione completata!</div>
                            <div class="text-sm text-green-700 mt-1">‚úÖ ${matchCount} partite eliminate per la data ${targetDate}</div>
                        </div>
                    `;

                    // Clear date input
                    dateInput.value = '';

                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-trash mr-2"></i>Cancella Tutte le Partite del Giorno';
                } catch (e) {
                    console.error('[Delete Full Date] Error:', e);
                    statusDiv.innerHTML = `<div class="text-red-600"><i class="fa-solid fa-exclamation-triangle mr-2"></i>Errore: ${e.message}</div>`;
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-trash mr-2"></i>Cancella Tutte le Partite del Giorno';
                }
            });


            // ==================== EUGENIO PROMPT MANAGEMENT ====================
            document.getElementById('load-eugenio-prompt-btn').addEventListener('click', async () => {
                const btn = document.getElementById('load-eugenio-prompt-btn');
                const statusDiv = document.getElementById('eugenio-status');

                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento...';

                try {
                    const promptDoc = await getDoc(doc(db, "system_prompts", "eugenio"));

                    if (promptDoc.exists()) {
                        const data = promptDoc.data();
                        document.getElementById('eugenio-trading-knowledge').value = data.tradingKnowledge || '';
                        document.getElementById('eugenio-custom-instructions').value = data.customInstructions || '';
                        document.getElementById('eugenio-additional-context').value = data.additionalContext || '';
                        document.getElementById('eugenio-telegram-knowledge').value = data.telegramBotKnowledge || data.telegramKnowledge || '';


                        statusDiv.classList.remove('hidden');
                        statusDiv.innerHTML = '<div class="text-green-600"><i class="fa-solid fa-check-circle mr-2"></i>Prompt caricato da Firebase! Ultimo aggiornamento: ' + (data.lastUpdate || 'N/D') + '</div>';
                    } else {
                        statusDiv.classList.remove('hidden');
                        statusDiv.innerHTML = '<div class="text-yellow-600"><i class="fa-solid fa-exclamation-triangle mr-2"></i>Nessun prompt salvato su Firebase. Inizia da zero!</div>';
                    }
                } catch (e) {
                    console.error('[Eugenio] Load error:', e);
                    statusDiv.classList.remove('hidden');
                    statusDiv.innerHTML = '<div class="text-red-600"><i class="fa-solid fa-times-circle mr-2"></i>Errore: ' + e.message + '</div>';
                }

                btn.disabled = false;
                btn.innerHTML = '<i class="fa-solid fa-download mr-2"></i>Carica da Firebase';
            });

            document.getElementById('save-eugenio-prompt-btn').addEventListener('click', async () => {
                const btn = document.getElementById('save-eugenio-prompt-btn');
                const statusDiv = document.getElementById('eugenio-status');

                const tradingKnowledge = document.getElementById('eugenio-trading-knowledge').value.trim();
                const customInstructions = document.getElementById('eugenio-custom-instructions').value.trim();
                const additionalContext = document.getElementById('eugenio-additional-context').value.trim();
                const telegramBotKnowledge = document.getElementById('eugenio-telegram-knowledge').value.trim();

                if (!tradingKnowledge && !customInstructions && !additionalContext && !telegramBotKnowledge) {
                    if (!confirm('‚ö†Ô∏è Tutti i campi sono vuoti. Vuoi salvare comunque (questo resetter√† le conoscenze di euGENIO)?')) {
                        return;
                    }
                }

                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Salvataggio...';

                try {
                    await setDoc(doc(db, "system_prompts", "eugenio"), {
                        tradingKnowledge: tradingKnowledge,
                        customInstructions: customInstructions,
                        additionalContext: additionalContext,
                        telegramBotKnowledge: telegramBotKnowledge,
                        lastUpdate: new Date().toISOString()
                    });

                    statusDiv.classList.remove('hidden');
                    statusDiv.innerHTML = '<div class="text-green-600"><i class="fa-solid fa-check-circle mr-2"></i>‚úÖ Prompt salvato su Firebase! Le modifiche sono attive per tutti gli utenti.</div>';

                    console.log('[Eugenio] ‚úÖ Prompt saved to Firebase');
                } catch (e) {
                    console.error('[Eugenio] Save error:', e);
                    statusDiv.classList.remove('hidden');
                    statusDiv.innerHTML = '<div class="text-red-600"><i class="fa-solid fa-times-circle mr-2"></i>Errore: ' + e.message + '</div>';
                }

                btn.disabled = false;
                btn.innerHTML = '<i class="fa-solid fa-save mr-2"></i>Salva su Firebase';
            });

            // Auto-load Eugenio prompt when page loads
            (async function () {
                try {
                    const promptDoc = await getDoc(doc(db, "system_prompts", "eugenio"));
                    if (promptDoc.exists()) {
                        const data = promptDoc.data();
                        document.getElementById('eugenio-trading-knowledge').value = data.tradingKnowledge || '';
                        document.getElementById('eugenio-custom-instructions').value = data.customInstructions || '';
                        document.getElementById('eugenio-additional-context').value = data.additionalContext || '';
                        document.getElementById('eugenio-telegram-knowledge').value = data.telegramBotKnowledge || data.telegramKnowledge || '';
                        console.log('[Eugenio] ‚úÖ Prompt auto-loaded');
                    }
                } catch (e) {
                    console.log('[Eugenio] No existing prompt to load');
                }
            })();


            // REMOVED DUPLICATE handleUploadConfirmed FUNCTION
            // The correct version is defined above (lines ~2850)

            window.calculateOutcome = function (match) {
                const { tip, risultato } = match;
                if (!risultato || !tip) return '';

                // Source of Truth: Use shared evaluation logic for parity with App and ML Dataset
                if (window.evaluateTipLocally) {
                    return window.evaluateTipLocally(tip, risultato) || '';
                }

                // Fallback to legacy local logic if utility not loaded

                const scores = risultato.split('-').map(s => parseInt(s.trim()));
                if (scores.length !== 2 || isNaN(scores[0]) || isNaN(scores[1])) return '';

                const [homeScore, awayScore] = scores;
                const totalGoals = homeScore + awayScore;
                const normalizedTip = tip.toUpperCase().replace(/\s/g, '');

                try {
                    // 1X2
                    if (normalizedTip === '1') return homeScore > awayScore ? 'Vinto' : 'Perso';
                    if (normalizedTip === 'X') return homeScore === awayScore ? 'Vinto' : 'Perso';
                    if (normalizedTip === '2') return awayScore > homeScore ? 'Vinto' : 'Perso';

                    // Doppia Chance
                    if (normalizedTip === '1X') return homeScore >= awayScore ? 'Vinto' : 'Perso';
                    if (normalizedTip === 'X2') return awayScore >= homeScore ? 'Vinto' : 'Perso';
                    if (normalizedTip === '12') return homeScore !== awayScore ? 'Vinto' : 'Perso';

                    // Over/Under: +1.5, -2.5, OVER1.5, UNDER2.5, etc.
                    if (/^[+-]?\d+(\.\d+)?$/.test(normalizedTip) || /^(OVER|UNDER)\d+(\.\d+)?$/i.test(normalizedTip)) {
                        let threshold;
                        let isOver;

                        if (normalizedTip.startsWith('OVER')) {
                            threshold = parseFloat(normalizedTip.replace(/OVER/i, ''));
                            isOver = true;
                        } else if (normalizedTip.startsWith('UNDER')) {
                            threshold = parseFloat(normalizedTip.replace(/UNDER/i, ''));
                            isOver = false;
                        } else if (normalizedTip.startsWith('+')) {
                            threshold = parseFloat(normalizedTip.substring(1));
                            isOver = true;
                        } else if (normalizedTip.startsWith('-')) {
                            threshold = parseFloat(normalizedTip.substring(1));
                            isOver = false;
                        } else {
                            // Just a number - assume Over
                            threshold = parseFloat(normalizedTip);
                            isOver = true;
                        }

                        if (isNaN(threshold)) return '';

                        if (isOver) return totalGoals > threshold ? 'Vinto' : 'Perso';
                        return totalGoals < threshold ? 'Vinto' : 'Perso';
                    }

                    // Goal/No Goal
                    if (normalizedTip === 'GOL' || normalizedTip === 'GG' || normalizedTip === 'SI' || normalizedTip === 'S√å') {
                        return (homeScore > 0 && awayScore > 0) ? 'Vinto' : 'Perso';
                    }
                    if (normalizedTip === 'NOGOL' || normalizedTip === 'NG' || normalizedTip === 'NO') {
                        return (homeScore === 0 || awayScore === 0) ? 'Vinto' : 'Perso';
                    }

                    // Unrecognized tip
                    console.warn(`[calculateOutcome] Unrecognized tip: "${tip}"`);
                    return '';

                } catch (e) {
                    console.error('[calculateOutcome] Error:', e, 'Match:', match);
                    return '';
                }
            }

            // ==================== CANCELLAZIONE GIORNATE ====================
            function updateTipsDaysList() {

                console.log("Aggiornamento lista giornate Tips...");
                const tipsDates = [...new Set(allMatches.filter(m => !m.risultato).map(m => m.data))].sort().reverse();
                console.log("Date trovate:", tipsDates);

                const select = document.getElementById('delete-tips-date');
                select.innerHTML = '<option value="">Seleziona una data...</option>' +
                    tipsDates.map(d => {
                        const count = allMatches.filter(m => m.data === d && !m.risultato).length;
                        return `<option value="${d}">${d} (${count} partite)</option>`;
                    }).join('');

                document.getElementById('tips-days-info').textContent = `Giornate disponibili: ${tipsDates.length}`;
            }

            function updateResultsDaysList() {
                const resultsDates = [...new Set(allMatches.filter(m => m.risultato).map(m => m.data))].sort().reverse();
                const select = document.getElementById('delete-results-date');
                select.innerHTML = '<option value="">Seleziona una data...</option>' +
                    resultsDates.map(d => {
                        const count = allMatches.filter(m => m.data === d && m.risultato).length;
                        return `<option value="${d}">${d} (${count} risultati)</option>`;
                    }).join('');

                document.getElementById('results-days-info').textContent = `Giornate con risultati: ${resultsDates.length}`;
            }


            // ==================== SAVED RANKINGS VIEWER (OLD - DISABLED) ====================
            // let savedRankingData = null;

            /* DISABLED - OLD EVENT LISTENER FOR REMOVED BUTTON
            document.getElementById('load-ranking-btn').addEventListener('click', async () => {
                const selectedDate = document.getElementById('ranking-date-selector').value;
                if (!selectedDate) {
                    alert('Seleziona una data!');
                    return;
                }
     
                try {
                    const rankingDoc = await getDoc(doc(db, "rankings", selectedDate));
                    if (!rankingDoc.exists()) {
                        alert(`Nessun ranking salvato per la data ${selectedDate}`);
                        document.getElementById('ranking-strategies-list').classList.add('hidden');
                        document.getElementById('ranking-matches-detail').classList.add('hidden');
                        return;
                    }
     
                    savedRankingData = rankingDoc.data();
                    const strategies = savedRankingData.strategies;
     
                    // Display strategies list
                    const strategiesGrid = document.getElementById('ranking-strategies-grid');
                    strategiesGrid.innerHTML = '';
     
                    Object.keys(strategies).forEach(stratId => {
                        const strat = strategies[stratId];
                        const card = document.createElement('button');
                        card.className = 'bg-white p-4 rounded-lg shadow border-2 border-purple-200 hover:border-purple-400 hover:shadow-lg transition-all text-left';
                        card.innerHTML = `
                            <div class="font-bold text-sm text-gray-800 mb-1">${strat.name}</div>
                            <div class="text-xs text-gray-600">${strat.totalMatches} partite</div>
                        `;
                        card.addEventListener('click', () => displayRankingMatches(stratId, strat));
                        strategiesGrid.appendChild(card);
                    });
     
                    document.getElementById('ranking-strategies-list').classList.remove('hidden');
                    document.getElementById('ranking-matches-detail').classList.add('hidden');
                } catch (e) {
                    console.error('Error loading ranking:', e);
                    alert('Errore caricamento ranking: ' + e.message);
                }
            });
            */



            document.getElementById('ranking-back-btn').addEventListener('click', () => {
                document.getElementById('ranking-strategies-list').classList.remove('hidden');
                document.getElementById('ranking-matches-detail').classList.add('hidden');
            });

            // Set default date to today (OLD - DISABLED)
            // document.getElementById('ranking-date-selector').valueAsDate = new Date();

            document.getElementById('delete-tips-day-btn').addEventListener('click', async () => {
                const selectedDate = document.getElementById('delete-tips-date').value;
                if (!selectedDate) {
                    showModal("Errore", "Seleziona una data!", () => { });
                    return;
                }

                const toDelete = allMatches.filter(m => m.data === selectedDate);

                showModal(
                    "Conferma Cancellazione",
                    `Eliminare TUTTE le ${toDelete.length} partite del ${selectedDate}?`,
                    async () => {
                        try {
                            if (window.USE_LOCAL_DB_ONLY) {
                                // LOCAL MODE: Filter out matches and persist to IndexedDB
                                window.allMatches = window.allMatches.filter(m => m.data !== selectedDate);
                                await window.LocalDB.saveMatches(window.allMatches);
                                console.log(`[Local Delete] Deleted ${toDelete.length} matches for ${selectedDate}`);
                            } else {
                                // ONLINE MODE: Firestore writeBatch
                                const batch = writeBatch(db);
                                toDelete.forEach(m => {
                                    batch.delete(doc(db, "matches", m.id));
                                });
                                await batch.commit();
                            }

                            showModal("Successo", `${toDelete.length} partite eliminate!`, () => { });
                            await loadAllMatches();
                            populateFilters();
                            applyFiltersAndRender();
                            updateTipsDaysList();
                        } catch (e) {
                            showModal("Errore", `Errore: ${e.message}`, () => { });
                        }
                    }
                );
            });

            document.getElementById('delete-results-day-btn').addEventListener('click', async () => {
                const selectedDate = document.getElementById('delete-results-date').value;
                if (!selectedDate) {
                    showModal("Errore", "Seleziona una data!", () => { });
                    return;
                }

                const toDelete = allMatches.filter(m => m.data === selectedDate && m.risultato);

                showModal(
                    "Conferma Cancellazione",
                    `Eliminare ${toDelete.length} risultati del ${selectedDate}? Le partite torneranno senza risultato.`,
                    async () => {
                        try {
                            if (window.USE_LOCAL_DB_ONLY) {
                                // LOCAL MODE: Update window.allMatches and persist
                                toDelete.forEach(m => {
                                    m.risultato = '';
                                    m.esito = '';
                                });
                                await window.LocalDB.saveMatches(window.allMatches);
                            } else {
                                // ONLINE MODE: Firestore writeBatch
                                const batch = writeBatch(db);
                                toDelete.forEach(m => {
                                    batch.update(doc(db, "matches", m.id), { risultato: '', esito: '' });
                                });
                                await batch.commit();
                            }

                            showModal("Successo", `${toDelete.length} risultati eliminati!`, () => { });
                            await loadAllMatches();
                            populateFilters();
                            applyFiltersAndRender();
                            updateResultsDaysList();
                        } catch (e) {
                            showModal("Errore", `Errore: ${e.message}`, () => { });
                        }
                    }
                );
            });

            // ==================== RANKING ====================

            // v3.5.3: State globale per visualizzazione ranking (DEVE essere qui!)
            let currentRankingView = 'by-tip'; // 'by-tip' o 'by-time'
            let currentRankingData = null; // Salva dati ranking per toggle

            document.getElementById('generate-ranking-btn').addEventListener('click', async () => {
                const rankingDate = document.getElementById('ranking-date').value;
                const maxMatches = parseInt(document.getElementById('ranking-max-matches').value);
                const selectedFilterId = document.getElementById('ranking-filter-select').value;

                if (!rankingDate) {
                    alert('Seleziona data!');
                    return;
                }

                const resultsContainer = document.getElementById('ranking-results');
                resultsContainer.innerHTML = '<div class="bg-white p-6 rounded-xl shadow text-center"><div class="animate-pulse text-lg">üîÑ Generazione ranking... <br><span class="text-sm text-gray-500">(Recupero orari in corso...)</span></div></div>';

                try {
                    // Partite del giorno senza risultato
                    let todayMatches = allMatches.filter(m => m.data === rankingDate && !m.risultato);

                    // APPLICA FILTRO SE SELEZIONATO
                    let filterName = "Tutte le partite";

                    // FILTRO SPECIALE: BEST 0.5 HT
                    if (selectedFilterId === 'BEST_05HT') {
                        filterName = "‚ö° BEST 0.5 HT (Auto)";

                        todayMatches = todayMatches.filter(m => {
                            // Requisito 1: HT prob disponibile e >= 70%
                            if (!m.info_ht || m.info_ht.trim() === '') return false;
                            const htMatch = m.info_ht.match(/(\d+)%/);
                            if (!htMatch) return false;
                            const htProb = parseInt(htMatch[1]);
                            if (htProb < 70) return false;

                            // Requisito 2: Tip Over (squadre prolifiche)
                            if (!m.tip.startsWith('+')) return false;

                            return true;
                        });
                    }
                    // FILTRI NORMALI
                    else if (selectedFilterId) {
                        const selectedFilter = savedFilters.find(f => f.id === selectedFilterId);
                        if (selectedFilter) {
                            filterName = selectedFilter.name;
                            // Normalize state (Public uses probRange/oddsRange, Local uses prob/odds)
                            const s = selectedFilter.state;
                            const leagues = s.leagues || [];
                            const tips = s.tips || [];
                            const prob = s.prob || s.probRange;
                            const odds = s.odds || s.oddsRange;

                            // Applica filtri
                            todayMatches = todayMatches.filter(m => {
                                // Filtro leghe
                                if (leagues && leagues.length > 0) {
                                    if (!leagues.includes(m.lega)) return false;
                                }

                                // Filtro tips
                                if (tips && tips.length > 0) {
                                    if (!tips.includes(m.tip)) return false;
                                }

                                // Filtro probabilit√†
                                if (prob) {
                                    const [minProb, maxProb] = prob.map(v => parseInt(v));
                                    if (m.probabilita < minProb || m.probabilita > maxProb) return false;
                                }

                                // Filtro odds
                                if (odds) {
                                    const [minOdds, maxOdds] = odds.map(v => parseFloat(v));
                                    if (m.quota < minOdds || m.quota > maxOdds) return false;
                                }

                                return true;
                            });
                        }
                    }

                    if (todayMatches.length === 0) {
                        resultsContainer.innerHTML = '<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita per quella data con i filtri selezionati!</div>';
                        return;
                    }

                    const leaguePerformance = analyzeLeaguePerformance(allMatches);

                    // Calcola score per tutte le partite
                    const rankedMatches = todayMatches.map(m => {
                        // Se filtro BEST 0.5 HT, usa score speciale
                        const score = selectedFilterId === 'BEST_05HT'
                            ? calculateScore05HT(m, allMatches)
                            : calculateScore(m, new Set([m.lega.toLowerCase()]), new Set([m.tip]), leaguePerformance, allMatches);
                        return {
                            ...m,
                            score: score.totalScore,
                            scoreDetails: score // Salva dettagli per tooltip
                        };
                    }).filter(m => m.score > 0); // Solo partite con score > 0

                    if (rankedMatches.length === 0) {
                        resultsContainer.innerHTML = `<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita disponibile con i filtri selezionati</div>`;
                        return;
                    }

                    // Raggruppa per tip
                    const byTip = {};
                    rankedMatches.forEach(m => {
                        if (!byTip[m.tip]) byTip[m.tip] = [];
                        byTip[tip].push(m);
                    });

                    // Ordina ogni gruppo per score
                    Object.keys(byTip).forEach(tip => {
                        byTip[tip].sort((a, b) => b.score - a.score);
                        byTip[tip] = byTip[tip].slice(0, maxMatches);
                    });

                    // CARICA ORARI da Firebase cache temporanea
                    const allRankedMatches = Object.values(byTip).flat();
                    let loadedTimes = 0;

                    for (let match of allRankedMatches) {
                        const ora = await getTimeFromCache(match.data, match.partita);
                        if (ora) {
                            match.time = ora;
                            loadedTimes++;
                        }
                    }

                    console.log(`[CACHE] Orari recuperati: ${loadedTimes}/${allRankedMatches.length}`);

                    if (loadedTimes === 0) {
                        console.log('[INFO] Nessun orario in cache. Carica CSV con colonna "Ora".');
                    }
                    if (loadedTimes > 0) {
                        console.log(`Loaded ${loadedTimes} match times for ranking`);
                    }

                    // SALVA DATI PER TRACKING
                    lastGeneratedRanking = {
                        timestamp: new Date().toISOString(),
                        data_partite: rankingDate,
                        filtro_nome: filterName,
                        filtro_id: selectedFilterId || null,
                        partite_by_tip: {},
                        stats: {
                            totale_partite: rankedMatches.length,
                            tips_count: Object.keys(byTip).length
                        }
                    };

                    // Organizza partite per tip
                    Object.keys(byTip).forEach(tip => {
                        lastGeneratedRanking.partite_by_tip[tip] = byTip[tip].map(m => ({
                            fixtureId: m.fixtureId || null,
                            kickoffTimestamp: m.kickoffTimestamp || null,
                            partita: m.partita,
                            lega: m.lega,
                            tip: m.tip,
                            mercato: m.mercato,
                            quota: m.quota,
                            probabilita: m.probabilita,
                            score: m.score,
                            esito: null // Verr√† aggiornato quando carichi risultati
                        }));
                    });

                    // v3.5.3: Salva dati per toggle visualizzazione
                    currentRankingData = {
                        byTip,
                        rankingDate,
                        filterName,
                        rankedMatches,
                        todayMatches,
                        selectedFilterId,
                        maxMatches
                    };

                    // v3.5.3: Render default (per tip)
                    currentRankingView = 'by-tip';
                    renderRankingByTip(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId, maxMatches);

                } catch (e) {
                    console.error('Error:', e);
                    resultsContainer.innerHTML = `<div class="bg-red-50 p-6 rounded-xl text-center">‚ùå Errore: ${e.message}</div>`;
                }
            });

            // ==================== v3.5.3: VISUALIZZAZIONE RANKING & ORDINAMENTO ====================

            // v3.5.3: Funzione setup tooltip listeners (riattiva dopo re-render)
            function setupTooltipListeners() {
                // Tooltip gi√† gestiti da event delegation globale nel codice esistente
                // Questa funzione √® placeholder per compatibilit√†
            }

            // Funzione render ranking per tip (default)
            function renderRankingByTip(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId, maxMatches) {
                const resultsContainer = document.getElementById('ranking-results');
                const toggleContainer = document.getElementById('ranking-view-toggle');

                // Mostra toggle
                toggleContainer.classList.remove('hidden');

                // Render tip blocks (codice esistente)
                const tipBlocks = Object.keys(byTip).sort().map(tip => {
                    const matches = byTip[tip];
                    const sectionTitle = selectedFilterId === 'BEST_05HT' ? '‚ö° BEST 0.5 HT' : `üìä ${tip}`;
                    const sectionSubtitle = selectedFilterId === 'BEST_05HT'
                        ? `${matches.length} partite selezionate automaticamente`
                        : `${matches.length} partite (max ${maxMatches} per tip)`;

                    return `
                        <div class="bg-white p-6 rounded-xl shadow mb-6">
                            <h3 class="text-2xl font-bold mb-3">${sectionTitle}</h3>
                            <div class="text-sm text-gray-600 mb-4">${sectionSubtitle}</div>
                            <div class="space-y-3">
                                ${matches.map((m, idx) => renderMatchCard(m, idx, selectedFilterId)).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                resultsContainer.innerHTML = `
                    <div class="mb-6 bg-gradient-to-r from-purple-500 to-blue-500 text-white p-6 rounded-xl shadow">
                        <h2 class="text-3xl font-bold mb-2">üèÜ Ranking ${rankingDate}</h2>
                        <div class="text-lg mb-1">üìä Filtro: <span class="font-bold">${filterName}</span></div>
                        <div class="text-sm opacity-90 mb-3">
                            ‚úÖ ${rankedMatches.length} partite totali su ${todayMatches.length} filtrate ‚Ä¢ ${Object.keys(byTip).length} tip diverse
                        </div>
                        <button id="save-ranking-btn" class="bg-white text-purple-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                            <i class="fa-solid fa-save mr-2"></i>Salva Ranking per Tracking ML
                        </button>
                        <button id="export-csv-btn" class="bg-white text-blue-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                            <i class="fa-solid fa-download mr-2"></i>Esporta CSV Strategie
                        </button>
                        <button onclick="confirmAllAIStrategies()" class="bg-purple-700 text-white px-6 py-2 rounded-lg font-bold hover:bg-purple-800 transition-all shadow-md border-2 border-white">
                            <i class="fa-solid fa-robot mr-2"></i>Conferma Tutte AI Trading
                        </button>
                    </div>
                    ${tipBlocks}
                `;

                // Re-attach event listeners
                document.getElementById('save-ranking-btn').addEventListener('click', saveRankingForTracking);
                document.getElementById('export-csv-btn').addEventListener('click', exportRankingCSV);

                // Riattiva tooltips
                setupTooltipListeners();
            }

            // Funzione render ranking per orario
            function renderRankingByTime(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId) {
                const resultsContainer = document.getElementById('ranking-results');
                const toggleContainer = document.getElementById('ranking-view-toggle');

                // Mostra toggle
                toggleContainer.classList.remove('hidden');

                // Flatten e ordina per orario
                const allMatches = Object.values(byTip).flat();
                const matchesByTime = {};

                allMatches.forEach(m => {
                    const timeKey = m.time && m.time.trim() !== '' ? m.time : '‚è∞ Orario non disponibile';
                    if (!matchesByTime[timeKey]) matchesByTime[timeKey] = [];
                    matchesByTime[timeKey].push(m);
                });

                // Ordina keys per orario
                const sortedTimes = Object.keys(matchesByTime).sort((a, b) => {
                    if (a === '‚è∞ Orario non disponibile') return 1;
                    if (b === '‚è∞ Orario non disponibile') return -1;
                    return a.localeCompare(b);
                });

                const timeBlocks = sortedTimes.map(time => {
                    const matches = matchesByTime[time];
                    // Ordina per score dentro ogni orario
                    matches.sort((a, b) => b.score - a.score);

                    return `
                        <div class="bg-white p-6 rounded-xl shadow mb-6">
                            <h3 class="text-2xl font-bold mb-3">‚è∞ ${time}</h3>
                            <div class="text-sm text-gray-600 mb-4">${matches.length} partite</div>
                            <div class="space-y-3">
                                ${matches.map((m, idx) => renderMatchCard(m, idx, selectedFilterId, true)).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                resultsContainer.innerHTML = `
                    <div class="mb-6 bg-gradient-to-r from-purple-500 to-blue-500 text-white p-6 rounded-xl shadow">
                        <h2 class="text-3xl font-bold mb-2">üèÜ Ranking ${rankingDate}</h2>
                        <div class="text-lg mb-1">üìä Filtro: <span class="font-bold">${filterName}</span></div>
                        <div class="text-sm opacity-90 mb-3">
                            ‚úÖ ${rankedMatches.length} partite totali su ${todayMatches.length} filtrate
                        </div>
                        <button id="save-ranking-btn" class="bg-white text-purple-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                            <i class="fa-solid fa-save mr-2"></i>Salva Ranking per Tracking ML
                        </button>
                        <button id="export-csv-btn" class="bg-white text-blue-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                            <i class="fa-solid fa-download mr-2"></i>Esporta CSV Strategie
                        </button>
                        <button onclick="confirmAllAIStrategies()" class="bg-purple-700 text-white px-6 py-2 rounded-lg font-bold hover:bg-purple-800 transition-all shadow-md border-2 border-white">
                            <i class="fa-solid fa-robot mr-2"></i>Conferma Tutte AI Trading
                        </button>
                    </div>
                    ${timeBlocks}
                `;

                // Re-attach event listeners
                document.getElementById('save-ranking-btn').addEventListener('click', saveRankingForTracking);
                document.getElementById('export-csv-btn').addEventListener('click', exportRankingCSV);

                // Riattiva tooltips
                setupTooltipListeners();
            }

            // Funzione render singola card match (riutilizzabile)
            function renderMatchCard(m, idx, selectedFilterId, showTip = false) {
                const [team1, team2] = m.partita.split(' - ');
                const team1Stats = analyzeTeamStats(team1, true, m.tip, allMatches);
                const team2Stats = analyzeTeamStats(team2, false, m.tip, allMatches);

                // HT indicator
                let htIndicator = '';
                if (m.info_ht && m.info_ht.trim() !== '') {
                    const probMatch = m.info_ht.match(/(\d+)%/);
                    if (probMatch) {
                        const htProb = parseInt(probMatch[1]);
                        if (htProb >= 70) {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-green-100 text-green-700 px-2 py-1 rounded font-bold">‚ö° HT: ${m.info_ht}</span></div>`;
                        } else if (htProb >= 55) {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-yellow-100 text-yellow-700 px-2 py-1 rounded">üí° HT: ${m.info_ht}</span></div>`;
                        } else {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-gray-100 text-gray-600 px-2 py-1 rounded">üìä HT: ${m.info_ht}</span></div>`;
                        }
                    }
                }

                // Trading badge (AI suggestion)
                const tradingBadge = generateTradingBadge(m, selectedFilterId === 'BEST_05HT', team1Stats, team2Stats);

                // Generate unique ID for this match
                const matchUUID = (m.partita + m.data).replace(/[^a-zA-Z0-9]/g, '');

                // Check if match already has trading strategy assigned
                const hasTrading = m.hasTradingStrategy || false;
                const existingStrategy = m.tradingStrategy || null;

                // ‚ïê‚ïê‚ïê AI CALCULATION: Use Monte Carlo + Historical Analysis ‚ïê‚ïê‚ïê
                let aiCalculatedStrategy = null;
                let aiStrategyDisplay = '';

                if (!hasTrading) {
                    try {
                        // Enrich with magicStats (Monte Carlo simulation)
                        const magicStats = window.engine?.getMagiaStats?.(m, allMatches) || null;
                        const enrichedMatch = { ...m, magicStats };

                        // Calculate best trading strategy using AI engine
                        aiCalculatedStrategy = window.engine?.transformToTradingStrategy?.(enrichedMatch, allMatches);

                        if (aiCalculatedStrategy) {
                            // Store for later use by confirm button
                            window.pendingTradingStrategies = window.pendingTradingStrategies || {};
                            window.pendingTradingStrategies[matchUUID] = {
                                match: m,
                                strategy: aiCalculatedStrategy
                            };
                        }
                    } catch (e) {
                        console.warn(`[Trading AI] Error calculating strategy for ${m.partita}:`, e);
                    }
                }

                // Build trading display with AI-calculated result
                let tradingDisplay = '';

                // Trading Assignment Section
                const SIMPLE_STRATEGIES = ['italia', 'all', 'special_ai', '___magia_ai', 'top_eu', 'winrate_80'];
                const isSimple = SIMPLE_STRATEGIES.includes(selectedFilterId);

                if (!isSimple) {
                    tradingDisplay = `
                    <div class="mt-3 p-3 ${hasTrading ? 'bg-green-50 border-green-300' : aiCalculatedStrategy ? 'bg-purple-50 border-purple-300' : 'bg-gray-50 border-gray-200'} border-2 rounded-lg" id="trading-section-${matchUUID}">
                        ${hasTrading ? `
                            <!-- ALREADY ASSIGNED -->
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center gap-2">
                                    <span class="text-green-600 font-bold text-sm">‚úÖ TRADING ATTIVO</span>
                                    <span class="bg-green-600 text-white px-2 py-0.5 rounded text-xs font-bold">${existingStrategy?.label || existingStrategy?.type || 'N/A'}</span>
                                </div>
                                <button onclick="removeTradingFromMatch('${matchUUID}', '${m.partita.replace(/'/g, "\\'")}', '${m.data}')" class="text-red-500 hover:text-red-700 text-xs font-bold">
                                    <i class="fa-solid fa-trash"></i> Rimuovi
                                </button>
                            </div>
                            <div class="text-xs text-gray-600 grid grid-cols-3 gap-2">
                                <div><span class="font-bold">Entry:</span> @${existingStrategy?.entry?.range?.join('-') || 'N/A'}</div>
                                <div><span class="font-bold">Exit:</span> @${existingStrategy?.exit?.target || 'N/A'}</div>
                                <div><span class="font-bold">Conf:</span> ${existingStrategy?.confidence || 0}%</div>
                            </div>
                        ` : aiCalculatedStrategy ? `
                            <!-- AI CALCULATED STRATEGY -->
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center gap-2">
                                    <span class="text-purple-700 font-bold text-sm">üß† AI SUGGERISCE</span>
                                    <span class="bg-purple-600 text-white px-2 py-0.5 rounded text-xs font-bold animate-pulse">${aiCalculatedStrategy.strategy || aiCalculatedStrategy.label || 'N/A'}</span>
                                    <span class="bg-purple-100 text-purple-700 px-2 py-0.5 rounded text-xs font-bold">${aiCalculatedStrategy.confidence || 0}%</span>
                                </div>
                            </div>
                            <div class="text-xs text-gray-700 mb-2 italic">
                                ${aiCalculatedStrategy.reasoning || 'Analisi Monte Carlo + Storico'}
                            </div>
                            <div class="text-xs text-gray-600 grid grid-cols-3 gap-2 mb-2 bg-white/50 p-2 rounded">
                                <div><span class="font-bold">Entry:</span> @${aiCalculatedStrategy.tradingInstruction?.entryRange?.join('-') || 'N/A'}</div>
                                <div><span class="font-bold">Exit:</span> ${aiCalculatedStrategy.tradingInstruction?.exitTarget || 'N/A'}</div>
                                <div><span class="font-bold">Timing:</span> ${aiCalculatedStrategy.tradingInstruction?.timing || 'Pre-match'}</div>
                            </div>
                            <div class="grid grid-cols-2 gap-2">
                                <button onclick="confirmAITradingStrategy('${matchUUID}', '${m.partita.replace(/'/g, "\\'")}', '${m.data}')" 
                                        class="bg-purple-600 hover:bg-purple-700 text-white text-xs font-bold py-2 rounded transition-all">
                                    <i class="fa-solid fa-check mr-1"></i> CONFERMA AI
                                </button>
                                <button onclick="showManualTradingForm('${matchUUID}')" 
                                        class="bg-gray-200 hover:bg-gray-300 text-gray-700 text-xs font-bold py-2 rounded transition-all">
                                    <i class="fa-solid fa-pen mr-1"></i> MODIFICA
                                </button>
                            </div>
                            <!-- Hidden manual form -->
                            <div id="manual-form-${matchUUID}" class="hidden mt-2 pt-2 border-t border-purple-200">
                                <div class="grid grid-cols-2 gap-2 mb-2">
                                    <select id="trading-type-${matchUUID}" class="text-xs p-1.5 border rounded w-full">
                                        <option value="BACK_OVER_25" ${aiCalculatedStrategy.strategy === 'BACK_OVER_25' ? 'selected' : ''}>Back Over 2.5</option>
                                        <option value="BACK_OVER_25_2H" ${aiCalculatedStrategy.strategy === 'SECOND_HALF_SURGE' ? 'selected' : ''}>Back Over 2.5 (2¬∞ Tempo)</option>
                                        <option value="HT_SNIPER" ${aiCalculatedStrategy.strategy === 'HT_SNIPER' ? 'selected' : ''}>HT Sniper (Gol 1T)</option>
                                        <option value="LAY_THE_DRAW" ${aiCalculatedStrategy.strategy === 'LAY_THE_DRAW' ? 'selected' : ''}>Lay The Draw</option>
                                        <option value="SCALPING_OVER_15" ${aiCalculatedStrategy.strategy === 'UNDER_35_SCALPING' ? 'selected' : ''}>Scalping Over 1.5</option>
                                    </select>
                                    <input type="number" id="trading-conf-${matchUUID}" class="text-xs p-1.5 border rounded w-full" value="${aiCalculatedStrategy.confidence || 70}" min="0" max="100">
                                </div>
                                <button onclick="assignTradingToMatch('${matchUUID}', '${m.partita.replace(/'/g, "\\'")}', '${m.data}', '${m.tip}')" 
                                        class="w-full bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-2 rounded transition-all">
                                    <i class="fa-solid fa-save mr-1"></i> SALVA MANUALE
                                </button>
                            </div>
                        ` : `
                            <!-- NO AI STRATEGY AVAILABLE -->
                            <div class="flex items-center gap-2 mb-2">
                                <i class="fa-solid fa-circle-info text-gray-400"></i>
                                <span class="text-gray-500 font-bold text-sm">Nessuna strategia AI disponibile</span>
                            </div>
                            <div class="text-xs text-gray-400 mb-2">
                                Dati insufficienti per calcolo Monte Carlo o criteri non soddisfatti
                            </div>
                            <button onclick="showManualTradingForm('${matchUUID}')" 
                                    class="w-full bg-gray-200 hover:bg-gray-300 text-gray-700 text-xs font-bold py-2 rounded transition-all">
                                <i class="fa-solid fa-plus mr-1"></i> ASSEGNA MANUALMENTE
                            </button>
                            <!-- Hidden manual form -->
                            <div id="manual-form-${matchUUID}" class="hidden mt-2 pt-2 border-t border-gray-200">
                                <div class="grid grid-cols-2 gap-2 mb-2">
                                    <select id="trading-type-${matchUUID}" class="text-xs p-1.5 border rounded w-full">
                                        <option value="">-- Seleziona --</option>
                                        <option value="BACK_OVER_25">Back Over 2.5</option>
                                        <option value="BACK_OVER_25_2H">Back Over 2.5 (2¬∞ Tempo)</option>
                                        <option value="HT_SNIPER">HT Sniper (Gol 1T)</option>
                                        <option value="LAY_THE_DRAW">Lay The Draw</option>
                                        <option value="SCALPING_OVER_15">Scalping Over 1.5</option>
                                    </select>
                                    <input type="number" id="trading-conf-${matchUUID}" class="text-xs p-1.5 border rounded w-full" placeholder="Conf %" value="70" min="0" max="100">
                                </div>
                                <button onclick="assignTradingToMatch('${matchUUID}', '${m.partita.replace(/'/g, "\\'")}', '${m.data}', '${m.tip}')" 
                                        class="w-full bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-2 rounded transition-all">
                                    <i class="fa-solid fa-save mr-1"></i> ASSEGNA TRADING
                                </button>
                            </div>
                        `}
                    </div>`;
                }

                // Formato display TIP FT
                const tipDisplay = showTip ? `${m.tip} FT` : `${m.tip} FT`;

                return `
                <div class="border rounded-lg p-4 ${(m.score || 0) < 30 ? 'bg-red-50 border-red-200' : 'bg-white hover:bg-gray-50'}">
                    <div class="flex justify-between items-start mb-3">
                        <div class="flex-1">
                            <div class="flex justify-between items-start">
                                <div class="font-bold text-lg">
                                    ${idx + 1}.
                                    <span class="team-${team1Stats.color}">${team1}</span>
                                    -
                                    <span class="team-${team2Stats.color}">${team2}</span>
                                </div>
                            </div>
                            <div class="text-sm text-gray-600 flex items-center gap-2">
                                ${m.ora && m.ora.trim() !== '' ? `<span class="text-gray-900 font-bold">‚è∞ ${m.ora}</span> | ` : ''}
                                ${m.lega}
                            </div>
                            <div class="text-sm mt-1">
                                <span class="bg-blue-100 px-2 py-1 rounded text-xs font-semibold">${tipDisplay}</span>
                                <span class="ml-2 font-bold">@${(m.quota || 0).toFixed(2)}</span>
                                <span class="ml-2 text-gray-500">${m.probabilita || 0}%</span>
                            </div>
                            ${htIndicator}
                        </div>
                        <div class="text-right">
                            <div class="score-badge">${m.score || 0}</div>
                            <div class="text-xs text-gray-500 mt-1 relative inline-block">
                                <span class="tooltip-trigger cursor-help"
                                    data-tooltip-type="stats"
                                    data-mercato="${m.mercato || ''}"
                                    data-tip="${m.tip || ''}"
                                    data-home-count="${team1Stats.count || 0}"
                                    data-home-total="${team1Stats.total || 0}"
                                    data-away-count="${team2Stats.count || 0}"
                                    data-away-total="${team2Stats.total || 0}"
                                    data-home-perc="${team1Stats.percentage || 0}"
                                    data-away-perc="${team2Stats.percentage || 0}"
                                    data-home-penalty="${team1Stats.penalty || 0}"
                                    data-away-penalty="${team2Stats.penalty || 0}"
                                    data-home-score="${team1Stats.scoreValue || 0}"
                                    data-away-score="${team2Stats.scoreValue || 0}"
                                    data-home-details="${team1Stats.details || ''}"
                                    data-away-details="${team2Stats.details || ''}">
                                    ${team1Stats.stats} | ${team2Stats.stats}
                                </span>
                                <span class="ml-1 text-blue-500 cursor-help tooltip-trigger"
                                    data-tooltip-type="stats"
                                    data-mercato="${m.mercato || ''}"
                                    data-tip="${m.tip || ''}"
                                    data-home-count="${team1Stats.count || 0}"
                                    data-home-total="${team1Stats.total || 0}"
                                    data-away-count="${team2Stats.count || 0}"
                                    data-away-total="${team2Stats.total || 0}"
                                    data-home-perc="${team1Stats.percentage || 0}"
                                    data-away-perc="${team2Stats.percentage || 0}"
                                    data-home-penalty="${team1Stats.penalty || 0}"
                                    data-away-penalty="${team2Stats.penalty || 0}"
                                    data-home-score="${team1Stats.scoreValue || 0}"
                                    data-away-score="${team2Stats.scoreValue || 0}"
                                    data-home-details="${team1Stats.details || ''}"
                                    data-away-details="${team2Stats.details || ''}"
                                    title="Hover per dettagli">
                                    ‚ÑπÔ∏è
                                </span>
                            </div>
                        </div>
                    </div>
                    ${tradingDisplay}
                    ${(m.score || 0) < 30 ? '<div class="mt-2"><span class="bg-red-500 text-white text-xs px-2 py-1 rounded font-bold">‚ö†Ô∏è Score Basso - Poco Affidabile</span></div>' : ''}
                </div>
                `;
            }

            // Event listeners toggle visualizzazione ranking
            document.addEventListener('click', (e) => {
                if (e.target.id === 'view-by-tip-btn' || e.target.closest('#view-by-tip-btn')) {
                    if (currentRankingView === 'by-tip') return;
                    currentRankingView = 'by-tip';

                    // Update buttons
                    document.getElementById('view-by-tip-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white';
                    document.getElementById('view-by-time-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300';

                    // Re-render
                    if (currentRankingData) {
                        renderRankingByTip(
                            currentRankingData.byTip,
                            currentRankingData.rankingDate,
                            currentRankingData.filterName,
                            currentRankingData.rankedMatches,
                            currentRankingData.todayMatches,
                            currentRankingData.selectedFilterId,
                            currentRankingData.maxMatches
                        );
                    }
                } else if (e.target.id === 'view-by-time-btn' || e.target.closest('#view-by-time-btn')) {
                    if (currentRankingView === 'by-time') return;
                    currentRankingView = 'by-time';

                    // Update buttons
                    document.getElementById('view-by-tip-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300';
                    document.getElementById('view-by-time-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white';

                    // Re-render
                    if (currentRankingData) {
                        renderRankingByTime(
                            currentRankingData.byTip,
                            currentRankingData.rankingDate,
                            currentRankingData.filterName,
                            currentRankingData.rankedMatches,
                            currentRankingData.todayMatches,
                            currentRankingData.selectedFilterId
                        );
                    }
                }
            });

            // Funzione export CSV ranking
            function exportRankingCSV() {
                if (!currentRankingData) return;

                const csvData = [];
                csvData.push(['Data', 'Lega', 'Partita', 'Tip', 'Quota', 'Prob%', 'HT', 'Ora', 'Score', 'Trading'].join(','));

                Object.values(currentRankingData.byTip).forEach(matches => {
                    matches.forEach(m => {
                        const teams = m.partita.split(' - ');
                        let team1Stats = null;
                        let team2Stats = null;
                        if (teams.length === 2) {
                            team1Stats = analyzeTeamStats(teams[0].trim(), true, m.tip, allMatches);
                            team2Stats = analyzeTeamStats(teams[1].trim(), false, m.tip, allMatches);
                        }
                        const tradingBadge = generateTradingBadge(m, currentRankingData.selectedFilterId === 'BEST_05HT', team1Stats, team2Stats);
                        const tradingText = tradingBadge ? tradingBadge.text : 'N/A';

                        // Sanitize values for CSV
                        const row = [
                            m.data || '',
                            (m.lega || '').replace(/,/g, ';'),
                            (m.partita || '').replace(/,/g, ' -'),
                            m.tip || '',
                            String(m.quota).replace('.', ','),
                            m.probabilita || '',
                            m.info_ht || '',
                            m.ora || '',
                            m.score || '',
                            tradingText
                        ].join(',');
                        csvData.push(row);
                    });
                });

                const csvContent = csvData.join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `ranking_${currentRankingData.rankingDate}_${currentRankingData.filterName.replace(/\s+/g, '_')}.csv`;
                link.click();
            }

            // Ordinamento Dashboard
            document.getElementById('dashboard-sort-select')?.addEventListener('change', (e) => {
                const sortBy = e.target.value;
                applyFiltersAndRender(sortBy);
            });

            // ==================== STORICO PREVISIONI ====================

            // Carica previsioni per data specifica (SOLO LOCAL DB ‚ö°Ô∏è)
            async function loadStorico(date) {
                const storicoList = document.getElementById('storico-strategie-list');
                const storicoContainer = document.getElementById('storico-strategie-container');
                const storicoDateTitle = document.getElementById('storico-date-title');
                const storicoCount = document.getElementById('storico-count');
                const storicoDettaglio = document.getElementById('storico-dettaglio');
                const storicoStatsGlobali = document.getElementById('storico-stats-globali');

                storicoList.classList.remove('hidden');
                storicoDettaglio.classList.add('hidden');
                storicoStatsGlobali.classList.add('hidden');
                storicoContainer.innerHTML = '<div class="text-center py-4"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento da Archivio Locale...</div>';

                try {
                    // üî• LEAN MODE: Lettura SOLO da LocalDB
                    const storedStrategies = await window.LocalDB.loadStrategyHistory(date);

                    if (!storedStrategies || Object.keys(storedStrategies).length === 0) {
                        storicoDateTitle.textContent = `Previsioni del ${date} `;
                        storicoCount.textContent = 'Nessuna previsione salvata';
                        storicoContainer.innerHTML = `
                            <div class="text-center py-8 text-gray-500">
                                <i class="fa-solid fa-inbox text-4xl mb-3"></i>
                                <p>Nessuna strategia trovata nell'archivio locale per questa data.</p>
                                <p class="text-sm mt-2">Assicurati di aver eseguito lo Step 1 o Step 2 su questo dispositivo.</p>
                            </div>
                        `;
                        return;
                    }

                    // Converti mappa in array per visualizzazione
                    // Supporta sia formato mappa { id: {...} } che array vecchio stile
                    let strategiesList = [];
                    if (Array.isArray(storedStrategies)) {
                        strategiesList = storedStrategies;
                    } else {
                        strategiesList = Object.values(storedStrategies);
                    }

                    storicoDateTitle.innerHTML = `Previsioni del ${date} <button id="delete-date-btn" class="ml-3 bg-red-500 hover:bg-red-600 text-white text-sm px-3 py-1 rounded" title="Cancella tutte le strategie di questa giornata"><i class="fa-solid fa-trash mr-1"></i>Cancella Giornata</button>`;
                    storicoCount.textContent = `${strategiesList.length} strategie salvate`;

                    // Event listener cancella giornata
                    document.getElementById('delete-date-btn').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (!confirm(`‚ö†Ô∏è ATTENZIONE!\n\nVuoi cancellare TUTTE le strategie del ${date}?\nQuesta azione eliminer√† i dati sia in locale che sul cloud.`)) return;

                        try {
                            // 1. Delete Local
                            await window.LocalDB.saveStrategyHistory(date, null); // Remove entry

                            // 2. Delete Cloud (Clean Sync)
                            const batch = [];
                            batch.push(deleteDoc(doc(db, "ranking_history", date)));
                            batch.push(deleteDoc(doc(db, "daily_strategies", date)));
                            await Promise.all(batch);

                            showModal("‚úÖ Cancellato!", `Giornata ${date} eliminata.`, () => {
                                storicoList.classList.add('hidden');
                            });
                        } catch (e) {
                            console.error("Delete error:", e);
                            alert(`Errore cancellazione: ${e.message}`);
                        }
                    });

                    // Calcola stats per ogni strategia
                    const strategieCards = strategiesList.map(ranking => {
                        // RESILIENT: If partite_by_tip is missing, default to empty array instead of hiding
                        let allPartite = [];
                        if (ranking.matches && Array.isArray(ranking.matches)) {
                            allPartite = ranking.matches;
                        } else if (ranking.partite_by_tip) {
                            allPartite = Object.values(ranking.partite_by_tip).flat();
                        }

                        // ... Resto della logica di visualizzazione card (invariata)

                        console.log(`[loadStorico] Strategy "${ranking.filtro_nome || ranking.name}": ${allPartite.length} matches`);

                        const vinte = allPartite.filter(p => p.esito === 'Vinto').length;
                        const perse = allPartite.filter(p => p.esito === 'Perso').length;
                        const pending = allPartite.filter(p => !p.esito || p.esito === 'PENDING').length;
                        const totConEsito = vinte + perse;
                        const winRate = totConEsito > 0 ? Math.round((vinte / totConEsito) * 100) : null;

                        // Determina icona e colore
                        let icon = 'üìä';
                        let bgClass = 'bg-gray-50 hover:bg-gray-100';
                        let borderClass = 'border-gray-200';

                        if (ranking.magic_type === 'singole') {
                            icon = 'üéØ';
                            bgClass = 'bg-green-50 hover:bg-green-100';
                            borderClass = 'border-green-300';
                        } else if (ranking.magic_type === 'trading') {
                            icon = 'üìà';
                            bgClass = 'bg-blue-50 hover:bg-blue-100';
                            borderClass = 'border-blue-300';
                        }

                        // Stats badge
                        let statsBadge = '';
                        if (totConEsito > 0) {
                            const winColor = winRate >= 70 ? 'bg-green-500' : winRate >= 50 ? 'bg-yellow-500' : 'bg-red-500';
                            statsBadge = `
                    <div class="flex items-center gap-2 mt-2" >
                                    <span class="text-green-600 font-bold">${vinte}W</span>
                                    <span class="text-red-600 font-bold">${perse}L</span>
                                    ${pending > 0 ? `<span class="text-gray-500">${pending}P</span>` : ''}
                <span class="${winColor} text-white text-xs px-2 py-1 rounded-full font-bold">${winRate}%</span>
                                </div>
                    `;
                        } else if (pending > 0) {
                            statsBadge = `<div class="text-sm text-gray-500 mt-2" > <i class="fa-solid fa-clock mr-1"></i>${pending} partite in attesa risultati</div> `;
                        }

                        return `
                    <div class="p-4 rounded-lg border-2 ${borderClass} ${bgClass} transition-all storico-strategia-card"
                data - ranking - id="${ranking.id}" >
                    <div class="flex justify-between items-start">
                        <div class="flex-1 cursor-pointer storico-card-clickable">
                            <div class="flex items-center gap-2">
                                <span class="text-2xl">${icon}</span>
                                <div>
                                    <div class="font-bold text-lg">${ranking.filtro_nome}</div>
                                    <div class="text-sm text-gray-600">${allPartite.length} partite</div>
                                </div>
                            </div>
                            ${statsBadge}
                        </div>
                        <div class="flex flex-col items-end gap-2">
                            <button class="delete-strategy-btn text-red-500 hover:text-red-700 hover:bg-red-50 p-2 rounded"
                                data-strategy-id="${ranking.id}"
                                data-strategy-name="${ranking.filtro_nome}"
                                title="Cancella questa strategia">
                                <i class="fa-solid fa-trash"></i>
                            </button>
                            <div class="text-xs text-gray-500">${new Date(ranking.lastCalculated || docData.generated).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}</div>
                            <div class="cursor-pointer text-gray-400 hover:text-gray-600"><i class="fa-solid fa-chevron-right"></i></div>
                        </div>
                    </div>
                            </div>
                    `;
                    }).join('');


                    storicoContainer.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4" > ${strategieCards}</div> `;

                    // Event listeners per click area principale card
                    document.querySelectorAll('.storico-card-clickable').forEach(clickArea => {
                        clickArea.addEventListener('click', () => {
                            const card = clickArea.closest('.storico-strategia-card');
                            const rankingId = card.dataset.rankingId;
                            // Find strategy in nested structure
                            let ranking = null;
                            for (const doc of rankings) {
                                if (doc.strategies) {
                                    ranking = doc.strategies.find(r => r.id === rankingId);
                                    if (ranking) break;
                                }
                            }
                            if (ranking) showStoricoDettaglio(ranking);
                        });
                    });

                    // Event listeners per pulsanti cancella strategia
                    document.querySelectorAll('.delete-strategy-btn').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            const strategyId = btn.dataset.strategyId;
                            const strategyName = btn.dataset.strategyName;

                            if (!confirm(`‚ö†Ô∏è Cancellare la strategia "${strategyName}" ?\n\nQuesta azione √® irreversibile e pu√≤ influenzare il ML futuro.`)) return;

                            try {
                                const docRef = doc(db, "ranking_history", strategyId);
                                await deleteDoc(docRef);

                                showModal("‚úÖ Cancellato!", `Strategia "${strategyName}" eliminata.`, () => {
                                    // Ricarica la data
                                    loadStorico(date);
                                });
                            } catch (e) {
                                showModal("Errore", `Errore cancellazione: ${e.message} `, () => { });
                            }
                        });
                    });

                    // Mostra stats globali se ci sono risultati
                    showStoricoStatsGlobali(rankings);

                } catch (e) {
                    console.error('Storico Error:', e);
                    storicoContainer.innerHTML = `<div class="text-center py-4 text-red-600" > Errore: ${e.message}</div> `;
                }
            }

            // Mostra dettaglio strategia
            function showStoricoDettaglio(ranking) {
                const dettaglioEl = document.getElementById('storico-dettaglio');
                dettaglioEl.classList.remove('hidden');

                // Scroll to dettaglio
                dettaglioEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

                // Determina icona
                let icon = 'üìä';
                let gradientClass = 'from-gray-500 to-gray-600';
                if (ranking.magic_type === 'singole') {
                    icon = 'üéØ';
                    gradientClass = 'from-green-500 to-emerald-600';
                } else if (ranking.magic_type === 'trading') {
                    icon = 'üìà';
                    gradientClass = 'from-blue-500 to-indigo-600';
                }

                // Costruisci lista partite per tip
                const tipSections = Object.keys(ranking.partite_by_tip).map(tip => {
                    const partite = ranking.partite_by_tip[tip];

                    const partiteRows = partite.map(p => {
                        let esitoClass = 'bg-gray-100 text-gray-600';
                        let esitoIcon = '‚è≥';
                        let esitoBorder = 'border-gray-200';

                        if (p.esito === 'Vinto') {
                            esitoClass = 'bg-green-100 text-green-700';
                            esitoIcon = '‚úÖ';
                            esitoBorder = 'border-green-300';
                        } else if (p.esito === 'Perso') {
                            esitoClass = 'bg-red-100 text-red-700';
                            esitoIcon = '‚ùå';
                            esitoBorder = 'border-red-300';
                        }

                        const DisplayDBTip = p.originalDBTip; // STRICT: No fallback to p.tip
                        const DisplayDBQuota = p.originalDBQuota ? Number(p.originalDBQuota).toFixed(2) : '-';
                        const DisplayDBProb = p.originalDBProb || '-';

                        return `
                    <div class="p-3 rounded-lg border ${esitoBorder} ${esitoClass} mb-2" >
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="font-bold">${p.partita}</div>
                                <div class="text-xs opacity-75">${p.lega}</div>
                            </div>
                            <div class="text-right">
                                <div class="text-lg">${esitoIcon}</div>
                                ${(DisplayDBTip) ? `
                                    <div class="text-xs">Tip: <span class="font-bold text-blue-700">${DisplayDBTip}</span> @${DisplayDBQuota}</div>
                                    <div class="text-xs">Prob: ${DisplayDBProb}%</div>
                                ` : `
                                    <div class="text-xs font-bold text-purple-600 bg-purple-50 px-2 py-1 rounded border border-purple-200 mt-1">‚ú® MAGIA AI ONLY</div>
                                `}
                                <div class="text-xs font-bold mt-1">Score: ${p.score || '-'}</div>
                            </div>
                        </div>
                            </div>
                    `;
                    }).join('');

                    // Stats per tip
                    const vinte = partite.filter(p => p.esito === 'Vinto').length;
                    const perse = partite.filter(p => p.esito === 'Perso').length;
                    const pending = partite.filter(p => !p.esito || p.esito === 'PENDING').length;

                    return `
                    <div class="mb-6" >
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="text-lg font-bold">${tip}</h4>
                            <div class="text-sm">
                                <span class="text-green-600 font-bold">${vinte}W</span> /
                                <span class="text-red-600 font-bold">${perse}L</span>
                                ${pending > 0 ? ` / <span class="text-gray-500">${pending}P</span>` : ''}
                            </div>
                        </div>
                            ${partiteRows}
                        </div>
                    `;
                }).join('');

                // Stats totali
                const allPartite = Object.values(ranking.partite_by_tip).flat();
                const totVinte = allPartite.filter(p => p.esito === 'Vinto').length;
                const totPerse = allPartite.filter(p => p.esito === 'Perso').length;
                const totPending = allPartite.filter(p => !p.esito || p.esito === 'PENDING').length;
                const totConEsito = totVinte + totPerse;
                const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                dettaglioEl.innerHTML = `
                    <div class="bg-gradient-to-r ${gradientClass} text-white p-4 rounded-t-xl" >
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="text-2xl mr-2">${icon}</span>
                                <span class="text-xl font-bold">${ranking.filtro_nome}</span>
                            </div>
                            <button id="close-dettaglio-btn" class="bg-white/20 hover:bg-white/30 px-3 py-1 rounded-lg text-sm">
                                <i class="fa-solid fa-times mr-1"></i>Chiudi
                            </button>
                        </div>
                        <div class="mt-2 text-sm opacity-90">
                            üìÖ ${ranking.data_partite} ‚Ä¢ ${allPartite.length} partite ‚Ä¢ 
                            Salvato alle ${new Date(ranking.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}
                        </div>
                        ${winRate !== null ? `
                            <div class="mt-3 flex items-center gap-4">
                                <span class="bg-white/20 px-3 py-1 rounded-lg">
                                    <span class="font-bold">${totVinte}</span> Vinte
                                </span>
                                <span class="bg-white/20 px-3 py-1 rounded-lg">
                                    <span class="font-bold">${totPerse}</span> Perse
                                </span>
                                <span class="bg-white text-gray-800 px-3 py-1 rounded-lg font-bold">
                                    ${winRate}% Win Rate
                                </span>
                            </div>
                        ` : totPending > 0 ? `
                            <div class="mt-3 text-sm">
                                <i class="fa-solid fa-clock mr-1"></i>${totPending} partite in attesa risultati
                            </div>
                        ` : ''
                    }
                    </div>
                    <div class="bg-white rounded-b-xl shadow-md border border-gray-200 p-4">
                        ${tipSections}
                    </div>
                `;

                // Close button
                document.getElementById('close-dettaglio-btn').addEventListener('click', () => {
                    dettaglioEl.classList.add('hidden');
                });
            }

            // Stats globali per tutte le strategie della data
            function showStoricoStatsGlobali(rankings) {
                const statsEl = document.getElementById('storico-stats-globali');
                const statsContent = document.getElementById('storico-stats-content');

                // Calcola totali
                let totPartite = 0;
                let totVinte = 0;
                let totPerse = 0;
                let totPending = 0;

                rankings.forEach(docData => {
                    if (docData.strategies && Array.isArray(docData.strategies)) {
                        docData.strategies.forEach(r => {
                            if (r.partite_by_tip) {
                                const partite = Object.values(r.partite_by_tip).flat();
                                totPartite += partite.length;
                                totVinte += partite.filter(p => p.esito === 'Vinto').length;
                                totPerse += partite.filter(p => p.esito === 'Perso').length;
                                totPending += partite.filter(p => !p.esito || p.esito === 'PENDING').length;
                            }
                        });
                    }
                });

                const totConEsito = totVinte + totPerse;
                const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                if (totConEsito === 0) {
                    statsEl.classList.add('hidden');
                    return;
                }

                statsEl.classList.remove('hidden');

                const winRateColor = winRate >= 70 ? 'text-green-600' : winRate >= 50 ? 'text-yellow-600' : 'text-red-600';

                statsContent.innerHTML = `
                    <div class="bg-blue-50 p-4 rounded-xl text-center" >
                        <div class="text-3xl font-bold text-blue-600">${totPartite}</div>
                        <div class="text-sm text-gray-600">Partite Totali</div>
                    </div>
                    <div class="bg-green-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold text-green-600">${totVinte}</div>
                        <div class="text-sm text-gray-600">Vinte</div>
                    </div>
                    <div class="bg-red-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold text-red-600">${totPerse}</div>
                        <div class="text-sm text-gray-600">Perse</div>
                    </div>
                    <div class="bg-purple-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold ${winRateColor}">${winRate}%</div>
                        <div class="text-sm text-gray-600">Win Rate</div>
                    </div>
                `;
            }

            // Carica ultime N giornate
            async function loadUltimeGiornate(n = 10) {
                const storicoList = document.getElementById('storico-strategie-list');
                const storicoContainer = document.getElementById('storico-strategie-container');
                const storicoDateTitle = document.getElementById('storico-date-title');
                const storicoCount = document.getElementById('storico-count');
                const storicoDettaglio = document.getElementById('storico-dettaglio');
                const storicoStatsGlobali = document.getElementById('storico-stats-globali');

                storicoList.classList.remove('hidden');
                storicoDettaglio.classList.add('hidden');
                storicoStatsGlobali.classList.add('hidden');
                storicoContainer.innerHTML = '<div class="text-center py-4"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento ultime giornate...</div>';

                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    const snapshot = await getDocs(rankingHistoryCol);

                    if (snapshot.empty) {
                        storicoDateTitle.textContent = 'Storico Completo';
                        storicoCount.textContent = 'Nessuna previsione salvata';
                        storicoContainer.innerHTML = `
                    <div class="text-center py-8 text-gray-500" >
                                <i class="fa-solid fa-inbox text-4xl mb-3"></i>
                                <p>Nessuna previsione salvata nel sistema.</p>
                            </div>
                    `;
                        return;
                    }

                    // Raggruppa per data
                    const byDate = {};
                    snapshot.docs.forEach(doc => {
                        const data = doc.data();
                        const date = data.data_partite;
                        if (!byDate[date]) byDate[date] = [];
                        byDate[date].push({ id: doc.id, ...data });
                    });

                    // Ordina date e prendi ultime N
                    const sortedDates = Object.keys(byDate).sort().reverse().slice(0, n);

                    storicoDateTitle.textContent = `Ultime ${sortedDates.length} Giornate`;
                    storicoCount.textContent = `${snapshot.docs.length} strategie totali`;

                    // Costruisci cards per data
                    const dateCards = sortedDates.map(date => {
                        const rankings = byDate[date];

                        // Stats aggregate per data
                        let totVinte = 0, totPerse = 0, totPending = 0;
                        rankings.forEach(docData => {
                            if (docData.strategies && Array.isArray(docData.strategies)) {
                                docData.strategies.forEach(strategy => {
                                    if (strategy.partite_by_tip) {
                                        const partite = Object.values(strategy.partite_by_tip).flat();
                                        totVinte += partite.filter(p => p.esito === 'Vinto').length;
                                        totPerse += partite.filter(p => p.esito === 'Perso').length;
                                        totPending += partite.filter(p => !p.esito || p.esito === 'PENDING').length;
                                    }
                                });
                            }
                        });

                        const totConEsito = totVinte + totPerse;
                        const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                        let statsBadge = '';
                        if (winRate !== null) {
                            const winColor = winRate >= 70 ? 'bg-green-500' : winRate >= 50 ? 'bg-yellow-500' : 'bg-red-500';
                            statsBadge = `<span class="${winColor} text-white text-xs px-2 py-1 rounded-full ml-2" > ${winRate}% (${totVinte} /${totConEsito})</span> `;
                        }

                        if (totPending > 0) {
                            statsBadge += `<span class="bg-gray-400 text-white text-xs px-2 py-1 rounded-full ml-2" > ${totPending} Pending</span> `;
                        }

                        return `
                    <div class="p-4 rounded-lg border-2 border-gray-200 bg-gray-50 hover:bg-gray-100 cursor-pointer transition-all storico-date-card"
                data - date="${date}" >
                    <div class="flex justify-between items-center">
                        <div>
                            <div class="font-bold text-lg">üìÖ ${date} ${statsBadge}</div>
                            <div class="text-sm text-gray-600">${rankings.length} strategie</div>
                        </div>
                        <div class="text-gray-400">
                            <i class="fa-solid fa-chevron-right"></i>
                        </div>
                    </div>
                            </div>
                    `;
                    }).join('');

                    storicoContainer.innerHTML = `<div class="space-y-3" > ${dateCards}</div> `;

                    // Event listeners
                    document.querySelectorAll('.storico-date-card').forEach(card => {
                        card.addEventListener('click', () => {
                            const date = card.dataset.date;
                            document.getElementById('storico-date').value = date;
                            loadStorico(date);
                        });
                    });

                } catch (e) {
                    console.error('Storico Error:', e);
                    storicoContainer.innerHTML = `<div class="text-center py-4 text-red-600" > Errore: ${e.message}</div> `;
                }
            }

            // Event listeners Storico
            document.getElementById('load-storico-btn').addEventListener('click', () => {
                const date = document.getElementById('storico-date').value;
                if (!date) {
                    alert('Seleziona una data!');
                    return;
                }
                loadStorico(date);
            });

            document.getElementById('load-all-storico-btn').addEventListener('click', () => {
                loadUltimeGiornate(10);
            });

            // ==================== RANKING TRACKING & ML ====================
            async function saveRankingForTracking() {
                console.log('[SAVE DEBUG] saveRankingForTracking called');
                console.log('[SAVE DEBUG] lastGeneratedRanking:', lastGeneratedRanking);

                if (!lastGeneratedRanking) {
                    console.log('[SAVE DEBUG] No ranking to save!');
                    showModal("Errore", "Nessun ranking da salvare!", () => { });
                    return;
                }

                console.log('[SAVE DEBUG] Attempting to save for date:', lastGeneratedRanking.data_partite);

                try {
                    const rankingHistoryCol = collection(db, "ranking_history");

                    // CONTROLLO SE ESISTE GI√Ä un ranking con stessa data + stesso filtro
                    const q = query(rankingHistoryCol,
                        where("data_partite", "==", lastGeneratedRanking.data_partite),
                        where("filtro_nome", "==", lastGeneratedRanking.filtro_nome)
                    );
                    const snapshot = await getDocs(q);

                    if (!snapshot.empty) {
                        // SOVRASCRIVI il documento esistente
                        const docId = snapshot.docs[0].id;
                        const docRef = doc(db, "ranking_history", docId);
                        await setDoc(docRef, lastGeneratedRanking);
                        console.log('[SAVE DEBUG] ‚úÖ Updated existing doc:', docId, 'for date:', lastGeneratedRanking.data_partite);

                        // v3.5.0: Refresh immediato storico dopo salvataggio
                        const currentDate = document.getElementById('storico-data-picker')?.value;
                        if (currentDate) {
                            await loadStorico(currentDate);
                        }

                        showModal("‚úÖ Aggiornato!", `Ranking aggiornato(sovrascritto)!\nData: ${lastGeneratedRanking.data_partite} \nFiltro: ${lastGeneratedRanking.filtro_nome} \nPartite: ${lastGeneratedRanking.stats.totale_partite} `, () => { });
                    } else {
                        // CREA NUOVO documento
                        const newDocRef = await addDoc(rankingHistoryCol, lastGeneratedRanking);
                        console.log('[SAVE DEBUG] ‚úÖ Created NEW doc:', newDocRef.id, 'for date:', lastGeneratedRanking.data_partite);

                        // v3.5.0: Refresh immediato storico dopo salvataggio
                        const currentDate = document.getElementById('storico-data-picker')?.value;
                        if (currentDate) {
                            await loadStorico(currentDate);
                        }

                        showModal("‚úÖ Salvato!", `Ranking salvato per tracking ML!\nData: ${lastGeneratedRanking.data_partite} \nFiltro: ${lastGeneratedRanking.filtro_nome} \nPartite: ${lastGeneratedRanking.stats.totale_partite} `, () => { });
                    }

                    // Disabilita bottone dopo salvataggio
                    const btn = document.getElementById('save-ranking-btn');
                    if (btn) {
                        btn.disabled = true;
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                        btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Ranking Salvato';
                    }
                } catch (e) {
                    showModal("Errore", `Errore salvataggio: ${e.message} `, () => { });
                }
            }

            /**
             * üî• NEW v12.28: Auto-Sync Results from API
             * Performs a SINGLE API call for the entire date to fetch results.
             */
            async function autoSyncResultsFromAPI() {
                const resultsDate = document.getElementById('results-date').value;
                if (!resultsDate) {
                    alert('Seleziona una data per la sincronizzazione!');
                    return;
                }

                if (!confirm(`Vuoi sincronizzare automaticamente i risultati per il ${resultsDate}? \nQuesta operazione consumer√† 1 solo credito API.`)) {
                    return;
                }

                const btn = document.getElementById('auto-sync-results-btn');
                const originalText = btn.innerHTML;
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Sincronizzazione...';

                try {
                    // 1. Fetch ALL fixtures for the date (1 API call)
                    // üî• FORCE REFRESH: Per i risultati saltiamo la cache di 6 ore!
                    const fixtures = await loadDailyFixtures(resultsDate, null, true);
                    if (!fixtures || fixtures.length === 0) {
                        alert(`Nessuna fixture trovata su API-Football per il ${resultsDate}.`);
                        return;
                    }

                    // 2. Identify matches in OUR record for this date (Betmines + Magia AI Sandbox)
                    const matchesMagia = await window.LocalDB.loadMagiaMatches();
                    const filteredMagia = matchesMagia.filter(m => m.data === resultsDate);
                    const filteredBetmines = allMatches.filter(m => m.data === resultsDate);

                    // üî• FIX: Deduplicate by fixtureId to avoid counting same match twice
                    const seenFixtureIds = new Set();
                    const combinedMatches = [...filteredBetmines, ...filteredMagia].filter(m => {
                        if (!m.fixtureId) return true; // Keep matches without fixtureId
                        const fid = String(m.fixtureId);
                        if (seenFixtureIds.has(fid)) return false; // Skip duplicate
                        seenFixtureIds.add(fid);
                        return true;
                    });

                    if (combinedMatches.length === 0) {
                        alert(`Nessuna partita trovata (Betmines o Magia AI) per il ${resultsDate}.`);
                        return;
                    }

                    console.log(`[Auto-Sync] Start for ${resultsDate}. Fixtures: ${fixtures.length}, Our Matches: ${combinedMatches.length} (unique by fixtureId)`);

                    const missingIdMatches = [];
                    const pendingMatches = [];
                    const canceledMatches = []; // üî• NEW: PST, CANC, ABD
                    const foundUpdates = [];

                    for (const match of combinedMatches) {
                        if (!match.fixtureId) {
                            missingIdMatches.push(match);
                            continue;
                        }

                        const fixture = fixtures.find(f => String(f.fixture.id) === String(match.fixtureId));

                        if (fixture) {
                            const status = fixture.fixture.status.short; // FT, HT, NS, PST, CANC, etc.

                            if (status === 'FT' || status === 'AET' || status === 'PEN') {
                                let changed = false;
                                const updatedMatch = { ...match };

                                const ftHome = (fixture.goals && fixture.goals.home !== null) ? fixture.goals.home : fixture.score.fulltime.home;
                                const ftAway = (fixture.goals && fixture.goals.away !== null) ? fixture.goals.away : fixture.score.fulltime.away;
                                const htHome = fixture.score.halftime.home;
                                const htAway = fixture.score.halftime.away;

                                const finalScore = (ftHome !== null && ftAway !== null) ? `${ftHome}-${ftAway}` : null;
                                const htScore = (htHome !== null && htAway !== null) ? `${htHome}-${htAway}` : null;

                                if (finalScore && (match.risultato !== finalScore || !match.esito)) {
                                    updatedMatch.risultato = finalScore;
                                    changed = true;
                                }

                                if (htScore && match.risultato_ht !== htScore) {
                                    updatedMatch.risultato_ht = htScore;
                                    changed = true;
                                }

                                if (changed) {
                                    console.log(`[DEBUG-Sync] Trovato aggiornamento per: ${match.partita} | Risultato: ${updatedMatch.risultato}`);
                                    if (updatedMatch.risultato && updatedMatch.tip) {
                                        updatedMatch.esito = calculateOutcome(updatedMatch) || '';
                                    }
                                    foundUpdates.push(updatedMatch);
                                }
                            } else if (['PST', 'CANC', 'ABD'].includes(status)) {
                                // üî• NEW: Match non giocato
                                canceledMatches.push({
                                    partita: match.partita,
                                    status: fixture.fixture.status.long,
                                    fixtureId: match.fixtureId,
                                    id: match.id,
                                    source: match.source || 'betmines'
                                });
                            } else {
                                // Match exists but no result yet (NS, TBD, etc.)
                                pendingMatches.push({
                                    partita: match.partita,
                                    status: fixture.fixture.status.long,
                                    fixtureId: match.fixtureId,
                                    id: match.id,
                                    source: match.source || 'betmines'
                                });
                            }
                        }
                    }

                    showSyncResultsModal(foundUpdates, pendingMatches, missingIdMatches, canceledMatches);

                } catch (err) {
                    console.error('[Auto-Sync Error]', err);
                    alert(`Errore durante la sincronizzazione: ${err.message}`);
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = originalText;
                }
            }

            function showSyncResultsModal(found, pending, missing, canceled = []) {
                // Add animation styles if not present
                if (!document.getElementById('sync-modal-styles')) {
                    const style = document.createElement('style');
                    style.id = 'sync-modal-styles';
                    style.innerHTML = `
                        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
                        @keyframes slideOut { to { opacity: 0; transform: translateX(20px); height: 0; margin: 0; padding: 0; } }
                        .animate-fade-in { animation: fadeIn 0.15s ease-out; }
                        .animate-slide-out { animation: slideOut 0.3s forwards; overflow: hidden; }
                        .ht-badge-high { background: #dcfce7; color: #166534; padding: 2px 6px; rounded: 4px; font-weight: bold; }
                    `;
                    document.head.appendChild(style);
                }

                const modal = document.createElement('div');
                modal.id = 'sync-results-modal';
                modal.className = 'fixed inset-0 z-[10000] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4';

                let successTable = '';
                if (found.length > 0) {
                    const rows = found.map(m => `
                        <tr class="hover:bg-green-50/50 transition-colors">
                            <td class="px-2 py-1 text-[11px] border-b leading-tight font-medium">${m.partita}</td>
                            <td class="px-2 py-1 text-[10px] border-b text-center text-gray-500">${m.risultato_ht || '-'}</td>
                            <td class="px-2 py-1 text-[10px] border-b text-center font-bold text-green-700 bg-green-50">${m.risultato}</td>
                        </tr>
                    `).join('');
                    successTable = `
                        <div class="mb-6">
                            <h4 class="text-green-700 font-bold mb-2 flex items-center border-b border-green-200 pb-1">
                                <i class="fa-solid fa-check-circle mr-2"></i> Risultati Trovati (${found.length})
                            </h4>
                            <div class="max-h-40 overflow-y-auto rounded-lg border border-green-100">
                                <table class="w-full text-left bg-white">
                                    <thead class="bg-green-50/50 sticky top-0">
                                        <tr>
                                            <th class="px-2 py-1 text-[10px] uppercase text-gray-400">Partita</th>
                                            <th class="px-2 py-1 text-[10px] uppercase text-gray-400 text-center">HT</th>
                                            <th class="px-2 py-1 text-[10px] uppercase text-gray-400 text-center">FT</th>
                                        </tr>
                                    </thead>
                                    <tbody>${rows}</tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }

                // üî• NEW: CANCELED / POSTPONED SECTION
                let canceledTable = '';
                if (canceled.length > 0) {
                    const rows = canceled.map(m => `
                        <tr id="sync-row-${m.id}" class="hover:bg-red-50/50 transition-colors group">
                            <td class="px-2 py-1 text-[11px] border-b leading-tight">${m.partita}</td>
                            <td class="px-2 py-1 text-[10px] border-b text-red-600 font-medium italic">${m.status}</td>
                            <td class="px-2 py-1 border-b text-right">
                                <button onclick="deleteMatchFromSync('${m.id}', '${m.partita.replace(/'/g, "\\'")}', true)" class="text-gray-300 group-hover:text-red-500 p-1 transition-colors" title="Elimina Partita">
                                    <i class="fa-solid fa-trash-can"></i>
                                </button>
                            </td>
                        </tr>
                    `).join('');
                    canceledTable = `
                        <div class="mb-6 bg-red-50/30 p-3 rounded-xl border border-red-100">
                            <div class="flex justify-between items-center mb-2 border-b border-red-200 pb-2">
                                <h4 class="text-red-700 font-bold flex items-center">
                                    <i class="fa-solid fa-calendar-times mr-2"></i> Non Giocate (${canceled.length})
                                </h4>
                                <button onclick="window.autoDeleteAllCanceled()" class="text-[10px] bg-red-600 text-white px-2 py-1 rounded font-black hover:bg-red-700 shadow-sm transition-all active:scale-95">
                                    <i class="fa-solid fa-broom mr-1"></i>PULISCI TUTTO
                                </button>
                            </div>
                            <div class="max-h-32 overflow-y-auto">
                                <table class="w-full text-left">
                                    <tbody>${rows}</tbody>
                                </table>
                            </div>
                        </div>
                    `;

                    // Add global helper for bulk delete
                    window.autoDeleteAllCanceled = async () => {
                        const count = canceled.length;
                        if (!confirm(`Vuoi eliminare definitivamente tutte le ${count} partite posticipate/cancellate?`)) return;

                        console.log(`[Auto-Trash] Avvio pulizia di ${count} match... (Doppio Binario)`);
                        for (const m of canceled) {
                            await deleteMatchFromSync(m.id, m.partita, true, true);
                        }
                        alert("Pulizia completata con successo! Le partite sono state rimosse sia dal Database che dalla Sandbox.");
                    };
                }

                let pendingTable = '';
                if (pending.length > 0) {
                    const rows = pending.map(m => `
                        <tr id="sync-row-${m.id}" class="group">
                            <td class="px-2 py-1 text-[11px] border-b leading-tight">${m.partita}</td>
                            <td class="px-2 py-1 text-[10px] border-b text-orange-600 font-medium italic">${m.status}</td>
                            <td class="px-2 py-1 border-b">
                                <div class="flex gap-1 items-center justify-end">
                                    <input type="text" placeholder="HT" id="manual-ht-${m.id}" class="w-10 text-[10px] border rounded p-0.5 text-center" title="Risultato HT">
                                    <input type="text" placeholder="FT" id="manual-ft-${m.id}" class="w-10 text-[10px] border rounded p-0.5 text-center font-bold" title="Risultato Finale">
                                    <button onclick="saveManualResult('${m.id}', '${m.partita.replace(/'/g, "\\'")}')" class="text-blue-500 hover:text-blue-700 p-1" title="Salva Risultato">
                                        <i class="fa-solid fa-check-circle"></i>
                                    </button>
                                    <button onclick="deleteMatchFromSync('${m.id}', '${m.partita.replace(/'/g, "\\'")}', true)" class="text-gray-300 group-hover:text-red-500 p-1 transition-colors" title="Elimina Partita">
                                        <i class="fa-solid fa-trash-can"></i>
                                    </button>
                                </div>
                            </td>
                        </tr>
                    `).join('');
                    pendingTable = `
                        <div class="mb-6">
                            <h4 class="text-orange-700 font-bold mb-2 flex items-center border-b border-orange-200 pb-1">
                                <i class="fa-solid fa-hourglass-half mr-2"></i> Match in Sospeso (${pending.length})
                            </h4>
                            <div class="max-h-40 overflow-y-auto">
                                <table class="w-full text-left">
                                    <thead>
                                        <tr>
                                            <th class="px-2 py-1 text-[10px] uppercase text-gray-400">Partita</th>
                                            <th class="px-2 py-1 text-[10px] uppercase text-gray-400">Stato</th>
                                            <th class="px-2 py-1 text-[10px] uppercase text-gray-400 text-right">Azioni</th>
                                        </tr>
                                    </thead>
                                    <tbody>${rows}</tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }

                let missingTable = '';
                if (missing.length > 0) {
                    const rows = missing.map(m => `
                        <tr id="sync-row-${m.id}" class="group">
                            <td class="px-2 py-1 text-[11px] border-b text-red-600 leading-tight">${m.partita}</td>
                            <td class="px-2 py-1 border-b">
                                <div class="flex gap-1 items-center justify-end">
                                    <input type="text" placeholder="HT" id="manual-ht-${m.id}" class="w-10 text-[10px] border rounded p-0.5 text-center" title="Risultato HT">
                                    <input type="text" placeholder="FT" id="manual-ft-${m.id}" class="w-10 text-[10px] border rounded p-0.5 text-center font-bold" title="Risultato Finale">
                                    <button onclick="saveManualResult('${m.id}', '${m.partita.replace(/'/g, "\\'")}')" class="text-blue-500 hover:text-blue-700 p-1" title="Salva Risultato">
                                        <i class="fa-solid fa-check-circle"></i>
                                    </button>
                                    <button onclick="deleteMatchFromSync('${m.id}', '${m.partita.replace(/'/g, "\\'")}', true)" class="text-gray-300 group-hover:text-red-500 p-1 transition-colors" title="Elimina Partita">
                                        <i class="fa-solid fa-trash-can"></i>
                                    </button>
                                </div>
                            </td>
                        </tr>
                    `).join('');
                    missingTable = `
                        <div class="mb-4">
                            <h4 class="text-red-700 font-bold mb-2 flex items-center border-b border-red-200 pb-1">
                                <i class="fa-solid fa-triangle-exclamation mr-2"></i> ID Mancanti (${missing.length})
                            </h4>
                            <div class="max-h-40 overflow-y-auto">
                                <p class="mb-2 text-[10px] text-gray-500 italic px-2">Queste partite non hanno il FixtureId di API-Football.</p>
                                <table class="w-full text-left">
                                    <tbody>${rows}</tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }

                modal.innerHTML = `
                    <div class="bg-white rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden transition-all transform scale-100 animate-fade-in border border-slate-200">
                        <div class="bg-slate-800 text-white px-6 py-4 flex justify-between items-center">
                            <div class="flex items-center gap-3">
                                <div class="bg-blue-500/20 p-2 rounded-lg">
                                    <i class="fa-solid fa-sync text-blue-400"></i>
                                </div>
                                <h3 class="text-lg font-bold tracking-tight">Postino Risultati</h3>
                            </div>
                            <button onclick="document.getElementById('sync-results-modal').remove()" class="text-gray-400 hover:text-white transition-colors">
                                <i class="fa-solid fa-times text-xl"></i>
                            </button>
                        </div>
                        <div class="p-6 overflow-y-auto max-h-[70vh] bg-slate-50/30">
                            ${successTable || '<div class="text-gray-400 text-center py-6 italic bg-white rounded-xl border border-dashed border-gray-200 mb-6 font-medium text-sm">Nessun risultato trovato dalle API.</div>'}
                            ${canceledTable}
                            ${pendingTable}
                            ${missingTable}
                        </div>
                        <div class="bg-white border-t border-slate-100 px-6 py-4 flex gap-3 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
                            <button id="close-sync-modal" class="flex-1 px-4 py-2 border border-slate-200 rounded-xl font-bold text-slate-600 hover:bg-slate-50 transition-all text-sm uppercase tracking-wider">Chiudi</button>
                            <button id="save-sync-modal" class="px-8 py-2 bg-blue-600 text-white rounded-xl font-black shadow-lg shadow-blue-200 hover:bg-blue-700 transform hover:-translate-y-0.5 transition-all text-sm uppercase tracking-wider ${found.length === 0 ? 'hidden' : ''}">
                                <i class="fa-solid fa-save mr-2"></i>Salva <span id="sync-save-count">${found.length}</span> Risultati
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Event Listeners
                document.getElementById('close-sync-modal').onclick = () => modal.remove();

                // Initialize global dataToUpload with the found results from API
                window.dataToUpload = [...found];

                document.getElementById('save-sync-modal').onclick = async () => {
                    modal.remove();
                    await handleUploadConfirmed('results');
                };
            }

            // Global Helper for Manual Result Entry
            window.saveManualResult = async function (id, name) {
                const ht = document.getElementById(`manual-ht-${id}`).value.trim();
                const ft = document.getElementById(`manual-ft-${id}`).value.trim();

                if (!ft || !ft.includes('-')) {
                    alert("Inserisci il punteggio finale correttamente (es. 2-1)!");
                    return;
                }

                console.log(`[DEBUG-Manual] Input manuale per ${name}: HT ${ht}, FT ${ft}`);

                const match = window.allMatches.find(m => m.id === id);
                if (match) {
                    // Update in-memory match
                    match.risultato = ft;
                    match.risultato_ht = ht;
                    if (match.tip) {
                        match.esito = calculateOutcome(match) || '';
                    }

                    // Add to global dataToUpload (avoid duplicates)
                    const alreadyQueued = window.dataToUpload.findIndex(m => m.id === id);
                    if (alreadyQueued >= 0) {
                        window.dataToUpload[alreadyQueued] = { ...match };
                        console.log(`[DEBUG-Manual] Aggiornato match manuale gi√† in coda.`);
                    } else {
                        window.dataToUpload.push({ ...match });
                        console.log(`[DEBUG-Manual] Aggiunto nuovo match manuale alla coda.`);
                    }

                    // Update UI feedback
                    const saveBtn = document.getElementById('save-sync-modal');
                    const countSpan = document.getElementById('sync-save-count');
                    saveBtn.classList.remove('hidden');
                    countSpan.textContent = window.dataToUpload.length;
                    console.log(`[DEBUG-Manual] Coda totale aggiornata: ${window.dataToUpload.length}`);

                    // Row feedback
                    const inputRow = document.getElementById(`manual-ft-${id}`).closest('tr');
                    inputRow.style.background = '#f0f9ff';
                    inputRow.classList.add('transition-all', 'duration-500');
                    document.getElementById(`manual-ht-${id}`).classList.add('bg-green-50', 'border-green-300');
                    document.getElementById(`manual-ft-${id}`).classList.add('bg-green-50', 'border-green-300');

                    console.log(`[Manual-Queued] Pronto per il salvataggio globale. Totale in coda: ${window.dataToUpload.length}`);
                }
            };

            // üî• HELPER GLOBALE: Pulizia Snapshot (Firestore)
            async function cleanFirestoreSnapshots(matchId, date) {
                try {
                    // a. ranking_history
                    const rankingRef = doc(db, "ranking_history", date);
                    const rankingSnap = await getDoc(rankingRef);
                    if (rankingSnap.exists()) {
                        const data = rankingSnap.data();
                        let updated = false;
                        if (data.strategies) {
                            data.strategies.forEach(strat => {
                                const originalLen = strat.matches?.length || 0;
                                strat.matches = (strat.matches || []).filter(m => String(m.id) !== String(matchId));
                                if (strat.matches.length !== originalLen) updated = true;
                            });
                        }
                        if (updated) await setDoc(rankingRef, data);
                    }

                    // b. daily_strategies
                    const dailyStratsCol = collection(db, "daily_strategies", date, "strategies");
                    const dailySnap = await getDocs(dailyStratsCol);
                    if (!dailySnap.empty) {
                        for (const d of dailySnap.docs) {
                            const dData = d.data();
                            const filteredMatches = (dData.matches || []).filter(m => String(m.id) !== String(matchId));
                            if (filteredMatches.length !== (dData.matches?.length || 0)) {
                                await updateDoc(doc(db, "daily_strategies", date, "strategies", d.id), {
                                    matches: filteredMatches
                                });
                            }
                        }
                    }
                } catch (err) {
                    console.warn("[Snap-Clean] Error:", err);
                }
            }

            // Global Helper for Sync Deletion - üî• AGGIORNATO: Sincronizzazione Totale (Doppio Binario)
            window.deleteMatchFromSync = async function (id, name, silent = false, isBulk = false) {
                if (!isBulk && !confirm(`Sei sicuro di voler eliminare definitivamente "${name}"?`)) return;

                console.log(`[Sync-Delete] Eliminazione match: ${name} (${id})`);

                try {
                    // 0. Recupera data prima di cancellare per pulizia snapshot
                    const matchObj = window.allMatches.find(m => String(m.id) === String(id));
                    const matchDate = matchObj ? matchObj.data : null;

                    // 1. Remove from Memory (Betmines) - üî• Fix type mismatch
                    window.allMatches = window.allMatches.filter(m => String(m.id) !== String(id));

                    // 2. Remove from Memory (Magia Sandbox) - Doppio Binario
                    try {
                        let magiaMatches = await window.LocalDB.loadMagiaMatches();
                        const initialLen = magiaMatches.length;
                        magiaMatches = magiaMatches.filter(m => String(m.id) !== String(id));
                        if (magiaMatches.length !== initialLen) {
                            await window.LocalDB.updateMagiaMatches(magiaMatches);
                            console.log(`[Sync-Delete] Rimosso dalla Sandbox Magia.`);
                        }
                    } catch (e) {
                        console.warn("[Sync-Delete] Magia remove fail", e);
                    }

                    // 3. Persist to DBs (üî• ALWAYS Local + Firebase if needed)
                    // a. ALWAYS delete from LocalDB (Database Oro)
                    await LocalDB.deleteMatch(id);
                    await LocalDB.deleteMagiaMatch(id); // Ensure Sandbox is also clean
                    console.log(`[Sync-Delete] Rimosso dai database locali.`);

                    if (!window.USE_LOCAL_DB_ONLY) {
                        // --- FIREBASE SYNC ---
                        // b. Delete from collection 'matches'
                        await deleteDoc(doc(db, "matches", id));
                        console.log(`[Sync-Delete] Rimosso da Firestore: matches/${id}`);

                        if (matchDate) {
                            // CLEANUP SNAPSHOTS (üî• Common Logic)
                            await cleanFirestoreSnapshots(id, matchDate);
                            // Pulizia LocalDB (History)
                            await LocalDB.deleteMatchFromHistory(matchDate, id);
                        }
                    }

                    // 4. Update Modal UI (if present)
                    const row = document.getElementById(`sync-row-${id}`);
                    if (row) {
                        row.classList.add('animate-slide-out');
                        setTimeout(() => row.remove(), 400);
                    }

                    // 5. Update Main UI (Silent)
                    applyFiltersAndRender();

                    if (!isBulk && !silent) {
                        alert(`"${name}" √® stata eliminata da tutti i sistemi.`);
                    }
                } catch (e) {
                    console.error("[Sync-Delete] Errore:", e);
                    if (!isBulk) alert("Errore durante l'eliminazione completa.");
                }
            };

            async function updateRankingResults(uploadedDate, uploadedMatches) {
                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    const q = query(rankingHistoryCol, where("data_partite", "==", uploadedDate));
                    let snapshot = await getDocs(q);

                    if (snapshot.empty) {
                        console.log(`[updateRankingResults] No ranking_history for ${uploadedDate}, attempting ML-Ready self-healing from daily_strategies...`);

                        // 1. RECONSTRUCT: Fetch from daily_strategies subcollection
                        const dailyStratsCol = collection(db, "daily_strategies", uploadedDate, "strategies");
                        const dailySnap = await getDocs(dailyStratsCol);

                        if (!dailySnap.empty) {
                            const allStrats = [];
                            dailySnap.forEach(ds => {
                                const data = ds.data();
                                // Ensure matches contain all ML metadata (magicStats, odds, prob)
                                allStrats.push({ id: ds.id, ...data });
                            });

                            // 2. CREATE PERSISTENT HISTORY: Build the document
                            const newHistoryDoc = {
                                data_partite: uploadedDate,
                                date: uploadedDate,
                                strategies: allStrats,
                                generated: Date.now(),
                                type: 'self_healed_ml',
                                ml_fidelity: 'high'
                            };

                            // 3. PERSIST: Save to ranking_history so it exists for the next steps and ML analysis
                            await setDoc(doc(db, "ranking_history", uploadedDate), newHistoryDoc);
                            console.log(`[updateRankingResults] ‚úÖ ML-Ready History Created for ${uploadedDate}`);

                            // 4. RE-FETCH: Proceed with normal result update
                            const refreshedSnap = await getDocs(query(rankingHistoryCol, where("data_partite", "==", uploadedDate)));
                            if (refreshedSnap.empty) return null;
                            snapshot = refreshedSnap;
                        } else {
                            console.log(`[updateRankingResults] No source found in daily_strategies for ${uploadedDate}.`);
                            await updateDailyStrategiesResults(uploadedDate, uploadedMatches);
                            return null;
                        }
                    }

                    let totalUpdated = 0;
                    const performanceByFilter = {};

                    for (const docSnap of snapshot.docs) {
                        const ranking = docSnap.data();
                        let updated = false;

                        // NEW: Read from strategies array (new format)
                        const strategies = ranking.strategies || [];
                        if (!Array.isArray(strategies) || strategies.length === 0) {
                            console.warn(`[updateRankingResults] Skipping ${docSnap.id} - no strategies array`);
                            continue;
                        }

                        // Update each strategy's matches
                        strategies.forEach(strat => {
                            const matches = strat.matches || [];
                            matches.forEach(partita => {
                                // Find corresponding result
                                const result = uploadedMatches.find(m =>
                                    m.partita === partita.partita && m.risultato
                                );

                                if (result) {
                                    partita.risultato = result.risultato;
                                    // Calculate esito
                                    partita.esito = window.calculateOutcome ?
                                        window.calculateOutcome({ tip: partita.tip, risultato: result.risultato }) :
                                        (result.esito || null);
                                    if (partita.esito) {
                                        updated = true;
                                        totalUpdated++;
                                    }
                                }
                            });
                        });

                        if (updated) {
                            // Calculate performance
                            let totalMatches = 0;
                            let wonMatches = 0;

                            strategies.forEach(strat => {
                                (strat.matches || []).forEach(p => {
                                    if (p.esito) {
                                        totalMatches++;
                                        if (p.esito === 'Vinto') wonMatches++;
                                    }
                                });
                            });

                            const winrate = totalMatches > 0 ? Math.round((wonMatches / totalMatches) * 100) : 0;
                            ranking.performance = {
                                totale: totalMatches,
                                vinte: wonMatches,
                                perse: totalMatches - wonMatches,
                                winrate: winrate
                            };

                            // Save back to Firestore
                            await setDoc(doc(db, "ranking_history", docSnap.id), ranking);
                            console.log(`[updateRankingResults] ‚úÖ Updated ${docSnap.id}: ${totalUpdated} matches, ${winrate}% winrate`);

                            performanceByFilter[ranking.filtro_nome || docSnap.id] = ranking.performance;
                        }
                    }

                    // Also update daily_strategies subcollection
                    await updateDailyStrategiesResults(uploadedDate, uploadedMatches);

                    return {
                        updated: totalUpdated,
                        performance: performanceByFilter
                    };
                } catch (e) {
                    console.error("Error updating ranking results:", e);
                    return null;
                }
            }

            // NEW: Helper to update daily_strategies subcollection
            async function updateDailyStrategiesResults(uploadedDate, uploadedMatches) {
                try {
                    const strategiesCol = collection(db, "daily_strategies", uploadedDate, "strategies");
                    const snapshot = await getDocs(strategiesCol);

                    if (snapshot.empty) {
                        console.log(`[updateDailyStrategies] No strategies for ${uploadedDate}`);
                        return;
                    }

                    let totalUpdated = 0;

                    for (const stratDoc of snapshot.docs) {
                        const stratData = stratDoc.data();
                        const matches = stratData.matches || [];
                        let updated = false;

                        matches.forEach(partita => {
                            const result = uploadedMatches.find(m =>
                                m.partita === partita.partita && m.risultato
                            );

                            if (result) {
                                partita.risultato = result.risultato;
                                partita.risultato_ht = result.risultato_ht || '';
                                partita.esito = window.calculateOutcome ?
                                    window.calculateOutcome({ tip: partita.tip, risultato: result.risultato }) :
                                    (result.esito || null);
                                if (partita.esito) {
                                    updated = true;
                                    totalUpdated++;
                                }
                            }
                        });

                        if (updated) {
                            await setDoc(doc(db, "daily_strategies", uploadedDate, "strategies", stratDoc.id), stratData);
                            console.log(`[updateDailyStrategies] ‚úÖ Updated ${stratDoc.id}`);
                        }
                    }

                    console.log(`[updateDailyStrategies] Total updated: ${totalUpdated} matches`);
                } catch (e) {
                    console.error("[updateDailyStrategies] Error:", e);
                }
            }

            // ==================== RANKING FUNCTIONS ====================
            // V3.4.5 - SCORE SPECIALE PER 0.5 HT

            // MOVED TO js/engine.js: Statistical Engine & Trading Strategies
            // (calculateScore05HT, calculateScore, analyzeLeaguePerformance, analyzeTeamStats, 
            // analyzeDrawRate, extractHTProb, checkLiquidity, createBackOver25Strategy, 
            // createLayTheDrawStrategy, transformToTradingStrategy)

            // ==================== TRADING SPORTIVO SELECTION ====================
            // SELEZIONE TOP TRADING SPORTIVO PICKS (Outside IIFE for event listener access)
            function selectTopTradingSportivoPicks(allMatches, targetDate = null) {
                console.log('‚úÖ selectTopTradingSportivoPicks CALLED');
                console.log('[Trading Sportivo] Selezione picks da', allMatches.length, 'partite');

                // FILTRO GEOGRAFICO: Solo Europa + Competizioni Internazionali
                // LISTA RIGIDA DA top_leagues.txt
                const ALLOWED_LEAGUES = [
                    'EU-ITA Serie A',
                    'EU-ITA Serie B',
                    'EU-ITA Coppa Italia',
                    'EU-ENG Premier League',
                    'EU-ENG Championship',
                    'EU-ESP La Liga',
                    'EU-DEU Bundesliga',
                    'EU-FRA Ligue 1',
                    'EU-NLD Eredivisie',
                    'EU-NLD Eerste Divisie',
                    'EU-POR Primeira Liga',
                    'EU-BEL Pro League',
                    'EU-TUR Super Lig',
                    'EU-Champions League',
                    'EU-Europa League',
                    'EU-Conference League',
                    'EU-CHE Super League',
                    'EU-DNK Supeliga',
                    'EU-GRC Supe league',
                    'EU-IRL First Division',
                    'EU-POL 1. Liga'
                ];

                // BLACKLIST GEOGRAFICA ESPLICITA (Asia, Africa, Sud America, Oceania)
                const EXCLUDED_REGIONS = [
                    'as-', 'asia', 'thai', 'vietnam', 'china', 'japan', 'korea', 'india', 'indonesia',
                    'af-', 'africa', 'egypt', 'south africa', 'morocco', 'tunisia',
                    'sa-', 'brazil', 'argentina', 'chile', 'colombia', 'peru', 'mexico',
                    'oceania', 'australia', 'new zealand'
                ];

                // Filtra partite future senza risultati
                const dateToUse = targetDate || new Date().toISOString().split('T')[0];
                const upcomingMatches = allMatches.filter(m => {
                    if (m.risultato && m.risultato.trim() !== '') return false;
                    if (!m.data || m.data < dateToUse) return false;

                    // Esclusione dati corrotti
                    if (m.partita && m.partita.includes(' - ')) {
                        const teams = m.partita.split(' - ');
                        if (teams.length === 2 && teams[0].trim() === teams[1].trim()) return false;
                    }

                    // FILTRO GEOGRAFICO: Escludi regioni non europee
                    const league = (m.lega || '').toLowerCase();
                    if (EXCLUDED_REGIONS.some(region => league.includes(region))) {
                        console.log(`[Trading Sportivo] ‚ùå Esclusa regione non - EU: ${m.lega} `);
                        return false;
                    }

                    // NOTA: NON filtriamo per quota minima qui, la trasformazione lo far√†
                    // (Over 1.5 con quota <1.25 √® proprio quello che cerchiamo!)

                    return true;
                });

                console.log(`[Trading Sportivo] Partite future: ${upcomingMatches.length} `);

                // Calcola score e badge per ogni partita
                const matchesWithData = upcomingMatches.map(m => {
                    // Calcola score using exposed window function
                    const scoreData = window.calculateScore(m, new Set([window.normalizeLega(m.lega).toLowerCase()]), new Set([m.tip]), {}, allMatches);

                    // Create match object with calculated score for badge generation
                    const matchWithScore = { ...m, score: scoreData.totalScore };

                    // Calcola badge trading
                    const teams = m.partita.split(' - ');
                    let tradingBadge = null;
                    if (teams.length === 2) {
                        const homeStats = window.analyzeTeamStats(teams[0].trim(), true, m.tip, allMatches);
                        const awayStats = window.analyzeTeamStats(teams[1].trim(), false, m.tip, allMatches);
                        tradingBadge = window.generateTradingBadge(matchWithScore, false, homeStats, awayStats);
                    }

                    return {
                        ...m,
                        score: scoreData.totalScore,
                        scoreDetails: scoreData,
                        tradingBadge: tradingBadge
                    };
                });

                // FILTRO 1: Solo campionati allowed (Europa + Internazionali)
                const allowedLeagueMatches = matchesWithData.filter(m => {
                    const league = window.normalizeLega(m.lega).toLowerCase();
                    return ALLOWED_LEAGUES.some(allowedLeague => league.includes(allowedLeague.toLowerCase()));
                });

                console.log(`[Trading Sportivo]Partite in leghe consentite: ${allowedLeagueMatches.length} `);

                // ==================== v3.0: TRASFORMAZIONE STRATEGICA ====================
                console.log('[Trading 3.0] Arricchimento dati con AI (Monte Carlo)...');

                // Arricchisci con magicStats prima della trasformazione (Cruciale per LTD Hybrid)
                // IMPORTANTE: Usa window.allMatches per lo storico completo, non allMatches (solo giorno)
                const enrichedMatches = allowedLeagueMatches.map(m => ({
                    ...m,
                    magicStats: window.engine.getMagiaStats(m, window.allMatches || allMatches)
                }));

                console.log('[Trading v2] Applicando trasformazione strategica...');

                // Applica trasformazione a tutte le partite arricchite
                const transformedPicks = enrichedMatches
                    .map(m => transformToTradingStrategy(m, window.allMatches || allMatches))
                    .filter(p => p !== null); // Rimuovi SKIP

                console.log(`[Trading 3.0] Partite trasformate con successo: ${transformedPicks.length} `);

                // Raggruppa per strategia (per debug)
                const byStrategy = transformedPicks.reduce((acc, p) => {
                    acc[p.strategy] = (acc[p.strategy] || 0) + 1;
                    return acc;
                }, {});
                console.log('[Trading v2] Distribuzione strategie:', byStrategy);

                // Ordina per confidence (decrescente) con GLOBAL DIVERSITY (Elite Mode)
                const sortedPicks = transformedPicks.sort((a, b) => {
                    const profTypes = ['BACK_OVER_25', 'LAY_THE_DRAW', 'ELITE_SURGE', 'SECOND_HALF_SURGE'];
                    const isAProf = profTypes.includes(a.strategy);
                    const isBProf = profTypes.includes(b.strategy);

                    // Professional Priority: Se una professionale ha confidende > 60%, vince su HT Sniper (a meno di gap enormi)
                    if (isAProf && !isBProf && a.confidence >= 60 && b.confidence < 90) return -1;
                    if (!isAProf && isBProf && b.confidence >= 60 && a.confidence < 90) return 1;

                    return b.confidence - a.confidence;
                });

                // Max 20 picks (gestibile per live monitoring)
                const finalPicks = sortedPicks.slice(0, 20);

                console.log(`[Trading 3.0] Selected ${finalPicks.length} final picks (top 20 with Global Diversity)`);

                // Formatta per salvataggio (v2.0 format)
                return finalPicks.map(m => ({
                    id: m.id || Math.random().toString(36).substr(2, 9),
                    partita: m.partita || 'Sconosciuta',
                    lega: m.lega || 'Sconosciuta',
                    data: m.data || dateToUse,
                    ora: m.ora || '',

                    // v2.0: Dati strategia trasformata
                    strategy: m.strategy || 'UNKNOWN',
                    tradingInstruction: m.tradingInstruction || { action: m.tip || 'N/A', entryRange: [m.quota || '1.00'], exitTarget: 'N/A', timing: 'N/A' },
                    confidence: m.confidence || 0,
                    reasoning: m.reasoning || 'Analisi algoritmica',

                    // v1.0: Dati originali (hidden in UI)
                    _originalTip: m._originalTip || m.tip || 'N/A',
                    _originalQuota: m._originalQuota || m.quota || 'N/A',
                    _originalProb: m.probabilita || 0,

                    // NEW: Pass through API Enrichment & ID
                    fixtureId: m.fixtureId || null,
                    quota1: m.quota1 || null,
                    quotaX: m.quotaX || null,
                    quota2: m.quota2 || null,
                    magicStats: m.magicStats || null,

                    // Legacy (per compatibilit√† client se non aggiornato)
                    tip: m.tradingInstruction?.action || m.tip || 'N/A',
                    quota: parseFloat(m.tradingInstruction?.entryRange?.[0] || m.quota || '1.00'),
                    probabilita: Math.round(m.confidence || 0),
                    score: m.score || 0,
                    tradingBadge: m.badge || null,
                    whyTradable: m.reasoning || 'Analisi algoritmica',
                    calculatedStrategies: m._allPossibleStrategies || [],
                    liquidityLevel: classifyLiquidity(m.lega),
                    status: 'pending'
                }));
            }
            window.selectTopTradingSportivoPicks = selectTopTradingSportivoPicks;

            // Helper: Genera ragione trading
            function generateTradingReason(match) {
                const reasons = [];

                if (match.score >= 70) reasons.push('Score elevato (' + match.score + ')');
                if (match.probabilita >= 75) reasons.push('Alta probabilit√† (' + match.probabilita + '%)');
                if (match.scoreDetails && match.scoreDetails.homePerf && match.scoreDetails.awayPerf) {
                    const avgPerf = (match.scoreDetails.homePerf + match.scoreDetails.awayPerf) / 2;
                    if (avgPerf >= 70) reasons.push('Performance squadre consistente');
                }

                const league = window.normalizeLega(match.lega).toLowerCase();
                if (league.includes('premier') || league.includes('serie a') || league.includes('bundesliga')) {
                    reasons.push('Top campionato');
                }

                if (reasons.length === 0) return 'Analisi algoritmica';
                return reasons.join(' + ');
            }

            // Helper: Classifica liquidit√†
            function classifyLiquidity(lega) {
                const league = window.normalizeLega(lega).toLowerCase();

                // ========== ALTA LIQUIDIT√Ä (Consigliato per trading) ==========
                const HIGH_LIQUIDITY = [
                    // Top 5 Europee
                    'premier league', 'la liga', 'serie a', 'bundesliga', 'ligue 1',
                    // Seconde divisioni principali
                    'championship', 'serie b', '2. bundesliga', 'segunda', 'ligue 2',
                    // Coppe europee
                    'champions league', 'europa league', 'conference league',
                    // Altre leghe europee popolari
                    'eredivisie', 'liga portugal', 'primeira liga', 'belgian pro',
                    'scottish premiership', 'super lig', 's√ºper lig',
                    // Coppe nazionali top
                    'coppa italia', 'fa cup', 'copa del rey', 'dfb pokal', 'coupe de france',
                    // Internazionali
                    'nations league', 'euro 202', 'world cup', 'uefa'
                ];

                // ========== BASSA LIQUIDIT√Ä (Attenzione!) ==========
                const LOW_LIQUIDITY = [
                    // Irlanda e UK minori
                    'ireland', 'northern ireland', 'nifl', 'loi premier', 'welsh premier', 'cymru',
                    // Paesi nordici divisioni basse
                    'finland', 'norway', 'iceland', 'faroe',
                    // Est Europa minore
                    'latvia', 'estonia', 'lithuania', 'belarus', 'moldova', 'georgia', 'armenia', 'azerbaijan',
                    'kazakhstan', 'uzbekistan', 'tajikistan',
                    // Cipro, Malta
                    'cyprus', 'malta',
                    // Africa
                    'egypt', 'south africa', 'morocco', 'tunisia', 'nigeria', 'algeria',
                    // Sud America (bassa per Italia)
                    'brazil', 'argentina', 'chile', 'colombia', 'peru', 'paraguay', 'uruguay', 'ecuador', 'bolivia', 'venezuela',
                    // Asia
                    'japan', 'korea', 'china', 'thailand', 'vietnam', 'indonesia', 'malaysia', 'india', 'saudi',
                    // Oceania
                    'australia', 'new zealand', 'a-league',
                    // Nord/Centro America
                    'mls', 'mexico', 'liga mx', 'costa rica', 'honduras', 'guatemala'
                ];

                // Check high liquidity first
                if (HIGH_LIQUIDITY.some(hl => league.includes(hl))) {
                    return 'Alta';
                }

                // Check explicit low liquidity
                if (LOW_LIQUIDITY.some(ll => league.includes(ll))) {
                    return 'Bassa';
                }

                // Default: Media (leghe europee non classificate esplicitamente)
                // Es: Austria, Svizzera, Grecia, etc.
                return 'Media';
            }

            // ==================== INIT APP ====================
            // Init App Logic wrapped in IIFE to ensure async context
            (async () => {
                try {
                    // Set Default Date for Results Upload to Yesterday
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    document.getElementById('results-date').value = yesterday.toISOString().split('T')[0];

                    // Set Default Date for Tips Upload to Today
                    document.getElementById('tips-date').value = new Date().toISOString().split('T')[0];

                    await loadSavedFilters();
                    showPage('page-dashboard');
                    updateTipsDaysList();
                    updateResultsDaysList();
                } catch (e) {
                    console.error("Error during init:", e);
                }
            })();
            // Removed late closing brace of startApp

            // End of Init Logic - Continuing with Helper Functions


            // Legacy Strategy Builder Logic removed to prevent conflicts with new implementation.

            // Legacy Load/Delete listeners removed.

            // ==================== TOOLTIP SYSTEM ====================

            // Crea elemento tooltip
            const tooltipEl = document.createElement('div');
            tooltipEl.id = 'custom-tooltip';
            tooltipEl.className = 'fixed bg-gray-900 text-white text-xs rounded-lg p-3 shadow-xl pointer-events-none z-[9999] max-w-xs';
            tooltipEl.style.display = 'none';
            document.body.appendChild(tooltipEl);

            // Mostra tooltip - VERSIONE USER-FRIENDLY v3.3
            function showTooltipCustom(element, type) {
                const rect = element.getBoundingClientRect();
                let content = '';

                if (type === 'score') {
                    const score = element.dataset.score || '0';
                    const legaScore = parseInt(element.dataset.legaScore) || 0;
                    const tipScore = parseInt(element.dataset.tipScore) || 0;
                    const probScore = parseInt(element.dataset.probScore) || 0;
                    const teamBonus = parseInt(element.dataset.teamBonus) || 0;
                    const htBonus = parseInt(element.dataset.htBonus) || 0;

                    // Genera spiegazione user-friendly
                    const reasons = [];

                    if (legaScore >= 15) reasons.push('üèÜ <strong>Lega top</strong> per questo mercato');
                    else if (legaScore >= 10) reasons.push('üèÜ Lega con buono storico');
                    else if (legaScore >= 5) reasons.push('üèÜ Lega nella media');

                    if (tipScore >= 15) reasons.push('‚úÖ <strong>Tip molto affidabile</strong> (storico >70%)');
                    else if (tipScore >= 10) reasons.push('‚úÖ Tip affidabile');

                    if (probScore >= 20) reasons.push('üìä <strong>Prob. eccellente</strong> (>80%)');
                    else if (probScore >= 15) reasons.push('üìä Prob. alta (>75%)');
                    else if (probScore >= 10) reasons.push('üìä Prob. buona (>70%)');

                    if (teamBonus >= 20) reasons.push('‚öΩ <strong>Squadre molto prolifiche</strong>');
                    else if (teamBonus >= 10) reasons.push('‚öΩ Squadre con buona tendenza gol');
                    else if (teamBonus < 0) reasons.push('‚ö†Ô∏è Squadre poco prolifiche');

                    if (htBonus >= 10) reasons.push('üî• <strong>HT molto alto</strong> - gol probabile 1¬∞T');
                    else if (htBonus >= 5) reasons.push('üí° HT buono');
                    else if (htBonus < 0) reasons.push('‚ö†Ô∏è HT sfavorevole per questa tip');

                    content = `
                    <div class="font-bold mb-2 text-center text-base" >üìä PERCH√â SCORE ${score}</div>
                    <div class="space-y-2">
                        ${reasons.length > 0 ? reasons.map(r => `<div>${r}</div>`).join('') : '<div>Score nella media</div>'}
                    </div>
                    <div class="text-xs mt-3 pt-2 border-t border-gray-700 opacity-75 text-center">
                        <div>üî• 65+ = TOP | ‚ö° 50-64 = BUONO</div>
                        <div>üí° 30-49 = MEDIO | ‚ö†Ô∏è <30 = SKIP</div>
                    </div>
                `;
                } else if (type === 'stats') {
                    const mercato = element.dataset.mercato || '';
                    const tip = element.dataset.tip || '';
                    const homeCount = parseInt(element.dataset.homeCount) || 0;
                    const homeTotal = parseInt(element.dataset.homeTotal) || 0;
                    const awayCount = parseInt(element.dataset.awayCount) || 0;
                    const awayTotal = parseInt(element.dataset.awayTotal) || 0;

                    // v3.5.0: Dati estesi da analyzeTeamStats
                    const homePerc = parseInt(element.dataset.homePerc) || (homeTotal > 0 ? Math.round((homeCount / homeTotal) * 100) : 0);
                    const awayPerc = parseInt(element.dataset.awayPerc) || (awayTotal > 0 ? Math.round((awayCount / awayTotal) * 100) : 0);
                    const homePenalty = parseInt(element.dataset.homePenalty) || 0;
                    const awayPenalty = parseInt(element.dataset.awayPenalty) || 0;
                    const homeScore = parseInt(element.dataset.homeScore) || 0;
                    const awayScore = parseInt(element.dataset.awayScore) || 0;
                    const homeDetails = element.dataset.homeDetails || '';
                    const awayDetails = element.dataset.awayDetails || '';

                    const homeColor = homePerc >= 70 ? 'üü¢' : homePerc >= 50 ? 'üü°' : 'üî¥';
                    const awayColor = awayPerc >= 70 ? 'üü¢' : awayPerc >= 50 ? 'üü°' : 'üî¥';

                    // Per mercato GOL mostra tendenza gol
                    if (mercato.toLowerCase().includes('gol') || mercato.toLowerCase().includes('goal') || tip.startsWith('+') || tip.startsWith('-')) {
                        const tipLabel = tip.startsWith('+') ? `Over ${tip.substring(1)} ` : tip.startsWith('-') ? `Under ${tip.substring(1)} ` : tip;

                        // Valutazione complessiva
                        const avgScore = (homeScore + awayScore) / 2;
                        let verdict = '';
                        if (avgScore >= 70) verdict = '<div class="text-green-400 font-bold mt-2">‚úÖ OTTIMA AFFIDABILIT√Ä</div>';
                        else if (avgScore >= 50) verdict = '<div class="text-yellow-400 mt-2">üí° AFFIDABILIT√Ä MEDIA</div>';
                        else verdict = '<div class="text-red-400 mt-2">‚ö†Ô∏è BASSA AFFIDABILIT√Ä</div>';

                        content = `
                    <div class="font-bold mb-2 text-center" >‚öΩ ${tipLabel} - DETTAGLIO PRECISO</div>
                        <div class="space-y-2 text-xs">
                            <div class="border-b border-gray-700 pb-1">
                                ${homeColor} <strong>Casa:</strong> ${homeCount}/${homeTotal} match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${homePerc}%
                                    ${homePenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${homePenalty} punti` : ''}
                                    ${homeDetails ? `<br>‚Ä¢ ${homeDetails}` : ''}
                                    <br>‚Ä¢ <strong>Score finale: ${homeScore}</strong>
                                </div>
                            </div>
                            <div class="pb-1">
                                ${awayColor} <strong>Trasferta:</strong> ${awayCount}/${awayTotal} match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${awayPerc}%
                                    ${awayPenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${awayPenalty} punti` : ''}
                                    ${awayDetails ? `<br>‚Ä¢ ${awayDetails}` : ''}
                                    <br>‚Ä¢ <strong>Score finale: ${awayScore}</strong>
                                </div>
                            </div>
                        </div>
                        ${verdict}
                <div class="text-xs mt-2 pt-2 border-t border-gray-700 opacity-75">
                    <div><strong>Score medio partita: ${Math.round(avgScore)}</strong></div>
                    <div class="mt-1">70+ = TOP | 50-69 = BUONO | <50 = SKIP</div>
                </div>
                `;
                    } else {
                        // Per 1X2/Doppia Chance
                        const avgScore = (homeScore + awayScore) / 2;

                        content = `
                    <div class="font-bold mb-2 text-center" >üìà ${tip} - FORMA DETTAGLIATA</div>
                        <div class="space-y-2 text-xs">
                            <div class="border-b border-gray-700 pb-1">
                                ${homeColor} <strong>Casa:</strong> ${homeCount}/${homeTotal} ultimi match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${homePerc}%
                                    ${homePenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${homePenalty} punti` : ''}
                                    <br>‚Ä¢ <strong>Score: ${homeScore}</strong>
                                </div>
                            </div>
                            <div class="pb-1">
                                ${awayColor} <strong>Trasferta:</strong> ${awayCount}/${awayTotal} ultimi match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${awayPerc}%
                                    ${awayPenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${awayPenalty} punti` : ''}
                                    <br>‚Ä¢ <strong>Score: ${awayScore}</strong>
                                </div>
                            </div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t border-gray-700 opacity-75">
                            <div><strong>Score medio: ${Math.round(avgScore)}</strong></div>
                            <div class="mt-1">80+ = OTTIMA | 60-79 = BUONA | <60 = INCERTA</div>
                        </div>
                `;
                    }
                }

                tooltipEl.innerHTML = content;
                tooltipEl.style.display = 'block';

                // Posiziona tooltip - FIX: Rimuovi scrollY perch√© √® position: fixed
                setTimeout(() => {
                    const tooltipRect = tooltipEl.getBoundingClientRect();
                    let top = rect.top - tooltipRect.height - 10;
                    let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);

                    // Evita overflow top/bottom/left/right
                    if (top < 0) top = rect.bottom + 10;
                    if (left < 10) left = 10;
                    if (left + tooltipRect.width > window.innerWidth) {
                        left = window.innerWidth - tooltipRect.width - 10;
                    }

                    tooltipEl.style.top = `${top} px`; // FIX: Solo top relativo a viewport
                    tooltipEl.style.left = `${left} px`;
                }, 0);
            }

            // Nascondi tooltip
            function hideTooltipCustom() {
                tooltipEl.style.display = 'none';
            }

            // Event delegation per tooltip - FIX: Usa mouseover per bubbling corretto
            document.addEventListener('mouseover', (e) => {
                const trigger = e.target.closest('.tooltip-trigger');
                if (trigger && trigger.dataset.tooltipType) {
                    showTooltipCustom(trigger, trigger.dataset.tooltipType);
                } else {
                    hideTooltipCustom();
                }
            });

            document.addEventListener('mouseout', (e) => {
                // Lascia che mouseover gestisca la scomparsa se esce dal trigger
                const related = e.relatedTarget;
                const trigger = e.target.closest('.tooltip-trigger');
                if (trigger && (!related || !trigger.contains(related))) {
                    hideTooltipCustom();
                }
            });
            // ==================== CLIENT PRESET GENERATION (V4.0) ====================

            // Helper: Cleanup strategies older than 7 days
            async function cleanupOldStrategies() {
                try {
                    const sevenDaysAgo = new Date();
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    const cutoffDate = sevenDaysAgo.toISOString().split('T')[0];

                    const strategiesCol = collection(db, "daily_strategies");
                    const snapshot = await getDocs(strategiesCol);

                    let deletedCount = 0;
                    const batch = writeBatch(db);

                    snapshot.forEach((docSnapshot) => {
                        // Document ID is the date (YYYY-MM-DD)
                        if (docSnapshot.id < cutoffDate) {
                            batch.delete(docSnapshot.ref);
                            deletedCount++;
                        }
                    });

                    if (deletedCount > 0) {
                        await batch.commit();
                        console.log(`[7 - Day Cleanup] Deleted ${deletedCount} old strategy documents`);
                    } else {
                        console.log(`[7 - Day Cleanup] No old strategies to delete `);
                    }
                } catch (e) {
                    console.error('[7-Day Cleanup] Error:', e);
                }
            }

            // Helper: Generate Warning Stats for Volatile Leagues and Tips
            async function generateWarningStats() {
                console.log('[Warning Stats] Starting analysis...');
                const statusEl = document.getElementById('auth-status');
                if (statusEl) statusEl.textContent = "Analizzando anomalie...";

                try {
                    let matchData = [];

                    // 1. Load matches (Local vs Cloud)
                    if (window.USE_LOCAL_DB_ONLY) {
                        console.log('[Warning Stats] Using Local Data (Memory)');
                        // Filter for matches with results only
                        matchData = window.allMatches.filter(m => m.risultato && m.risultato.trim() !== '');
                    } else {
                        const matchesRef = collection(db, "matches");
                        const q = query(matchesRef, where("risultato", "!=", ""));
                        const snapshot = await getDocs(q);
                        snapshot.forEach(doc => matchData.push(doc.data()));
                    }

                    const leagueStats = {};
                    const tipStats = {};

                    // 2. Group by league and tip
                    matchData.forEach(m => {
                        // League stats
                        if (!leagueStats[m.lega]) {
                            leagueStats[m.lega] = {
                                results: [],
                                probabilities: [],
                                total: 0
                            };
                        }
                        leagueStats[m.lega].results.push(m.esito === 'Vinto' ? 1 : 0);
                        leagueStats[m.lega].probabilities.push(m.probabilita || 0);
                        leagueStats[m.lega].total++;

                        // Tip stats
                        if (!tipStats[m.tip]) {
                            tipStats[m.tip] = { total: 0, wins: 0 };
                        }
                        tipStats[m.tip].total++;
                        if (m.esito === 'Vinto') tipStats[m.tip].wins++;
                    });

                    // 3. Identify anomalies
                    const warnings = {
                        volatileLeagues: [],
                        lowPerformingTips: [],
                        overestimatedLeagues: [],
                        veryAnomalousLeagues: [],  // NEW: Leghe MOLTO anomale
                        totalLeaguesAnalyzed: 0,
                        totalLeaguesWithData: 0,
                        lastUpdated: Date.now()
                    };

                    // Count total leagues
                    warnings.totalLeaguesAnalyzed = Object.keys(leagueStats).length;
                    warnings.totalLeaguesWithData = Object.entries(leagueStats).filter(([_, stats]) => stats.total >= 20).length;

                    // A. Volatile leagues (high standard deviation)
                    Object.entries(leagueStats).forEach(([lega, stats]) => {
                        if (stats.total < 20) return; // Skip if insufficient data

                        const volatility = calculateVolatility(stats.results);
                        const winrate = (stats.results.reduce((a, b) => a + b) / stats.total) * 100;

                        if (volatility > 0.42) { // Threshold 42% (raised from 35%)
                            warnings.volatileLeagues.push({
                                lega,
                                volatility: (volatility * 100).toFixed(1) + '%',
                                winrate: winrate.toFixed(1) + '%',
                                total: stats.total,
                                volatilityRaw: volatility,  // For severe check
                                winrateRaw: winrate
                            });
                        }
                    });

                    // B. Under-performing tips
                    Object.entries(tipStats).forEach(([tip, stats]) => {
                        if (stats.total < 30) return; // Skip if insufficient data

                        const winrate = (stats.wins / stats.total) * 100;

                        if (winrate < 45) { // Below 45% (raised from 50%)
                            warnings.lowPerformingTips.push({
                                tip,
                                winrate: winrate.toFixed(1) + '%',
                                total: stats.total,
                                wins: stats.wins,
                                losses: stats.total - stats.wins
                            });
                        }
                    });

                    // C. Leagues with overestimated probabilities
                    const overestimatedMap = new Map();
                    Object.entries(leagueStats).forEach(([lega, stats]) => {
                        if (stats.total < 20) return;

                        const avgPredicted = stats.probabilities.reduce((a, b) => a + b) / stats.total;
                        const actualWinrate = (stats.results.reduce((a, b) => a + b) / stats.total) * 100;
                        const gap = avgPredicted - actualWinrate;

                        if (gap > 20) { // Overestimate by +20% (raised from 15%)
                            const entry = {
                                lega,
                                predicted: avgPredicted.toFixed(1) + '%',
                                actual: actualWinrate.toFixed(1) + '%',
                                gap: '+' + gap.toFixed(1) + '%',
                                gapRaw: gap  // For severe check
                            };
                            warnings.overestimatedLeagues.push(entry);
                            overestimatedMap.set(lega, gap);
                        }
                    });

                    // D. NEW: Identify VERY ANOMALOUS leagues (SEVERE criteria)
                    // Criteri SEVERI per identificare leghe da eliminare (VIA DI MEZZO):
                    // - Volatilit√† > 46% (molto alta)
                    // - Winrate < 38% (molto basso)
                    // - Gap sovrastima > 27% (molto irrealistico)
                    const veryAnomalousSet = new Set();

                    warnings.volatileLeagues.forEach(league => {
                        if (league.volatilityRaw > 0.46 || league.winrateRaw < 38) {
                            veryAnomalousSet.add(league.lega);
                        }
                    });

                    warnings.overestimatedLeagues.forEach(league => {
                        if (league.gapRaw > 27) {
                            veryAnomalousSet.add(league.lega);
                        }
                    });

                    // Create detailed list for very anomalous leagues
                    veryAnomalousSet.forEach(lega => {
                        const stats = leagueStats[lega];
                        const volatility = calculateVolatility(stats.results);
                        const winrate = (stats.results.reduce((a, b) => a + b) / stats.total) * 100;
                        const avgPredicted = stats.probabilities.reduce((a, b) => a + b) / stats.total;
                        const gap = avgPredicted - winrate;

                        warnings.veryAnomalousLeagues.push({
                            lega,
                            total: stats.total,
                            winrate: winrate.toFixed(1) + '%',
                            volatility: (volatility * 100).toFixed(1) + '%',
                            gap: gap > 0 ? '+' + gap.toFixed(1) + '%' : gap.toFixed(1) + '%',
                            reason: volatility > 0.45 ? 'Volatilit√† altissima' :
                                winrate < 40 ? 'Winrate molto basso' :
                                    'Gap sovrastimato'
                        });
                    });

                    // Sort by winrate (worst first)
                    warnings.veryAnomalousLeagues.sort((a, b) => {
                        const aWin = parseFloat(a.winrate);
                        const bWin = parseFloat(b.winrate);
                        return aWin - bWin;
                    });

                    // 4. Save to Firebase
                    await setDoc(doc(db, "system", "warning_stats"), warnings);

                    console.log('[Warning Stats] ‚úÖ Generated:', warnings);
                    console.log(`- Total leagues analyzed: ${warnings.totalLeaguesAnalyzed} `);
                    console.log(`- Leagues with sufficient data(‚â•20 matches): ${warnings.totalLeaguesWithData} `);
                    console.log(`- ${warnings.volatileLeagues.length} volatile leagues`);
                    console.log(`- ${warnings.lowPerformingTips.length} under - performing tips`);
                    console.log(`- ${warnings.overestimatedLeagues.length} overestimated leagues`);
                    console.log(`- ${warnings.veryAnomalousLeagues.length} VERY ANOMALOUS leagues(severe)`);

                    if (statusEl) statusEl.textContent = `Warning stats generate: ${warnings.volatileLeagues.length + warnings.lowPerformingTips.length + warnings.overestimatedLeagues.length} anomalie rilevate`;

                    return warnings;
                } catch (e) {
                    console.error('[Warning Stats] Error:', e);
                    if (statusEl) statusEl.textContent = "Errore generazione warning stats";
                }
            }

            // Helper: Calculate volatility (standard deviation)
            function calculateVolatility(results) {
                if (results.length === 0) return 0;
                const mean = results.reduce((a, b) => a + b) / results.length;
                const variance = results.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / results.length;
                return Math.sqrt(variance);
            }


            // REMOVED handleSendHistory
            // document.getElementById('send-history-btn')?.addEventListener('click', handleSendHistory);

            // Expose critical functions for trading picks (outside IIFE)
            // Expose critical functions for trading picks (outside IIFE) - With Safety Checks
            window.calculateScore = typeof calculateScore !== 'undefined' ? calculateScore : (window.engine?.calculateScore);
            window.analyzeTeamStats = typeof analyzeTeamStats !== 'undefined' ? analyzeTeamStats : (window.engine?.analyzeTeamStats);
            window.generateTradingBadge = typeof generateTradingBadge !== 'undefined' ? generateTradingBadge : (window.engine?.generateTradingBadge);
            window.normalizeLega = typeof normalizeLega !== 'undefined' ? normalizeLega : (window.normalizeLega || ((s) => String(s || '').trim().toLowerCase()));

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // ‚ö°Ô∏è PRONOSTICI LIVE DASHBOARD (OGGI SU APP - 5 STRATEGIE + MAGIA AI)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            async function loadPronosticiLiveStrategies() {
                const liveContainer = document.getElementById('pronostici-live-section');
                const contentDiv = document.getElementById('pronostici-live-content');
                const dateBadge = document.getElementById('pronostici-live-date');

                if (!liveContainer || !contentDiv) return;


                const today = new Date().toISOString().split('T')[0];
                console.log('[DEBUG loadPronosticiLive] üìÖ Data oggi:', today);
                dateBadge.textContent = today;
                liveContainer.classList.remove('hidden');

                try {
                    // üî• FIX: Prima prova daily_strategies/{date}/strategies (nuova struttura subcollection)
                    const parentDocRef = doc(db, "daily_strategies", today);
                    const strategiesSubCol = collection(parentDocRef, "strategies");
                    const subColSnapshot = await getDocs(strategiesSubCol);

                    let strategiesList = [];

                    console.log('[DEBUG loadPronosticiLive] üîç subColSnapshot.empty:', subColSnapshot.empty, '| size:', subColSnapshot.size);

                    if (!subColSnapshot.empty) {
                        // Nuova struttura subcollection
                        console.log(`[Live Today] Found ${subColSnapshot.size} strategies in daily_strategies / ${today}/strategies`);
                        subColSnapshot.forEach(docSnap => {
                            const data = docSnap.data();
                            console.log('[DEBUG loadPronosticiLive] üì¶ Strategy loaded:', docSnap.id, '| matches:', data.matches?.length || 0);
                            strategiesList.push({
                                id: docSnap.id,
                                name: data.name || docSnap.id,
                                totalMatches: data.totalMatches || (data.matches?.length || 0),
                                matches: data.matches || [],
                                description: data.description || 'Analisi Predittiva con simulazione Monte Carlo (2500+ match)',
                                ...data
                            });
                        });
                    } else {
                        // Fallback: vecchia struttura rankings/{date}
                        console.log(`[Live Today] No subcollection found, trying rankings/${today}`);
                        const docRef = doc(db, "rankings", today);
                        const docSnap = await getDoc(docRef);

                        if (docSnap.exists()) {
                            const rawData = docSnap.data();
                            if (rawData.strategies && Array.isArray(rawData.strategies)) {
                                strategiesList = rawData.strategies;
                            } else {
                                strategiesList = Object.values(rawData).filter(s => s && typeof s === 'object' && s.name);
                            }
                        }
                    }

                    if (strategiesList.length > 0) {
                        contentDiv.innerHTML = '';

                        // Create Grid
                        const grid = document.createElement('div');
                        grid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4';

                        // Sort: Magia AI first, then others
                        strategiesList.sort((a, b) => {
                            const nameA = (a.name || '').toUpperCase();
                            const nameB = (b.name || '').toUpperCase();
                            if (nameA.includes('MAGIA AI')) return -1;
                            if (nameB.includes('MAGIA AI')) return 1;
                            return 0;
                        });

                        strategiesList.forEach(strat => {
                            // const strat is already the strategy object
                            const card = document.createElement('div');
                            // Style inspired by premium cards
                            const isMagia = (strat.name || '').toUpperCase().includes('MAGIA AI');
                            card.className = `${isMagia ? 'bg-gradient-to-br from-purple-100 to-indigo-100 border-purple-300' : 'bg-white border-gray-200'} border-2 rounded-xl p-4 shadow hover:shadow-lg transition-all cursor-pointer transform hover:-translate-y-1`;

                            card.innerHTML = `
                                <div class="flex justify-between items-start mb-2">
                                    <div class="font-bold ${isMagia ? 'text-purple-800' : 'text-gray-800'} truncate pr-2" title="${strat.name}">${strat.name}</div>
                                    <div class="bg-gray-800 text-white text-xs px-2 py-1 rounded-full font-bold">${strat.totalMatches || (strat.matches ? strat.matches.length : 0)} matches</div>
                                </div>
                                <div class="text-xs text-gray-500 mb-4 line-clamp-2 h-8">${strat.description || 'Nessuna descrizione'}</div>
                                <div class="text-center mt-auto">
                                    <button class="text-xs ${isMagia ? 'bg-purple-600 text-white' : 'bg-white border border-gray-300 text-gray-700'} px-3 py-2 rounded-lg font-bold w-full shadow-sm">
                                        <i class="fas fa-eye mr-1"></i> VEDI PARTITE
                                    </button>
                                </div>
                            `;

                            // Click Handler
                            card.onclick = () => {
                                renderLiveStrategyMatches(strat);
                            };

                            grid.appendChild(card);
                        });

                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // üé∞ 8TH BOX: CONSIGLI (Parlays)
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        try {
                            const parlaysDoc = await getDoc(doc(db, "daily_parlays", today));
                            if (parlaysDoc.exists()) {
                                const parlayData = parlaysDoc.data();
                                const parlayCount = parlayData.totalParlays || Object.keys(parlayData.parlays || {}).length;
                                const uniqueMatches = parlayData.uniqueMatches || 0;

                                const consigliCard = document.createElement('div');
                                consigliCard.className = 'bg-gradient-to-br from-amber-100 to-orange-100 border-2 border-amber-400 rounded-xl p-4 shadow-lg hover:shadow-xl transition-all cursor-pointer transform hover:-translate-y-1';

                                consigliCard.innerHTML = `
                                    <div class="flex justify-between items-start mb-2">
                                        <div class="font-bold text-amber-800 truncate pr-2">üé∞ CONSIGLI</div>
                                        <div class="bg-amber-600 text-white text-xs px-2 py-1 rounded-full font-bold">${parlayCount} multiple</div>
                                    </div>
                                    <div class="text-xs text-amber-700 mb-4 line-clamp-2 h-8">Multiple AI generate da Magia AI (${uniqueMatches} partite uniche)</div>
                                    <div class="text-center mt-auto">
                                        <button class="text-xs bg-amber-600 text-white px-3 py-2 rounded-lg font-bold w-full shadow-sm hover:bg-amber-700">
                                            <i class="fas fa-eye mr-1"></i> VEDI MULTIPLE
                                        </button>
                                    </div>
                                `;

                                consigliCard.onclick = () => {
                                    showConsigliDetail(parlayData);
                                };

                                grid.appendChild(consigliCard);
                            }
                        } catch (parlayErr) {
                            console.warn('[Consigli] No parlays found for today:', parlayErr.message);
                        }

                        contentDiv.appendChild(grid);
                    } else {
                        contentDiv.innerHTML = `
                            <div class="text-center py-8 bg-gray-50 rounded-xl border border-dashed border-gray-300">
                                <div class="text-4xl mb-2">üò¥</div>
                                <h3 class="text-lg font-bold text-gray-600">Nessuna strategia live oggi</h3>
                                <p class="text-sm text-gray-500 mb-4">I pronostici di oggi (${today}) non sono ancora stati calcolati/salvati.</p>
                                <button onclick="document.getElementById('start-analysis-btn').click(); document.getElementById('pronostici-tab').click();" class="bg-green-500 text-white px-6 py-2 rounded-lg font-bold shadow hover:bg-green-600 transition text-sm">
                                    üöÄ Lancia Analisi Ora
                                </button>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error("Error loading live strategies:", error);
                    contentDiv.innerHTML = `<div class="text-red-500 text-center p-4">Errore caricamento: ${error.message}</div>`;
                }
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üé∞ SHOW CONSIGLI DETAIL (Parlays Detail View)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            function showConsigliDetail(parlayData) {
                const contentDiv = document.getElementById('pronostici-live-content');

                const header = `
                    <div class="flex items-center justify-between mb-6">
                        <button onclick="window.loadPronosticiLiveStrategies()" class="text-sm bg-white border border-gray-300 hover:bg-gray-50 px-4 py-2 rounded-lg flex items-center gap-2 font-bold shadow-sm transition">
                            <i class="fas fa-arrow-left"></i> Torna alla Dashboard
                        </button>
                        <h3 class="text-2xl font-black text-amber-700 flex items-center gap-2">
                            <i class="fas fa-dice"></i>
                            I CONSIGLI DI OGGI
                        </h3>
                    </div>
                `;

                let parlaysHtml = '<div class="space-y-6">';

                const parlays = parlayData.parlays || {};
                const colorMap = { magica: 'purple', safe: 'emerald', italia: 'green', risky: 'orange' };
                const labelMap = { magica: 'üîÆ MAGICA', safe: 'üí∞ RADDOPPIO SAFE', italia: 'üáÆüáπ TRICOLORE', risky: '‚ö° RISCHIO DEL GIORNO' };

                for (const [key, parlay] of Object.entries(parlays)) {
                    const color = parlay.color || colorMap[key] || 'gray';
                    const label = parlay.label || labelMap[key] || key.toUpperCase();

                    parlaysHtml += `
                        <div class="bg-gradient-to-br from-${color}-50 to-${color}-100 border-2 border-${color}-300 rounded-2xl p-5 shadow-lg">
                            <div class="flex justify-between items-center mb-4">
                                <div class="flex items-center gap-3">
                                    <span class="bg-${color}-600 text-white text-sm font-black px-4 py-2 rounded-full uppercase tracking-wide">${label}</span>
                                    <span class="text-xs text-${color}-700 font-semibold">AI Confidence: ${parlay.avgConfidence}%</span>
                                </div>
                                <div class="text-right">
                                    <div class="text-xs font-bold text-gray-500 uppercase">Quota Totale</div>
                                    <div class="text-3xl font-black text-${color}-700">@${parlay.totalOdds}</div>
                                </div>
                            </div>
                            
                            <div class="space-y-3">
                                ${(parlay.picks || []).map(pick => `
                                    <div class="bg-white/80 backdrop-blur rounded-xl p-3 border border-${color}-200 flex justify-between items-center">
                                        <div class="flex-1">
                                            <div class="text-xs text-gray-500 font-semibold">${pick.lega || 'LEAGUE'}</div>
                                            <div class="font-bold text-gray-800">${pick.partita}</div>
                                            <div class="text-sm mt-1">
                                                <span class="bg-${color}-100 text-${color}-700 px-2 py-0.5 rounded font-bold text-xs">${pick.tip}</span>
                                                <span class="text-gray-500 text-xs ml-2">Score: ${pick.score}%</span>
                                            </div>
                                        </div>
                                        <div class="text-xl font-black text-gray-700">@${pick.quota}</div>
                                    </div>
                                `).join('')}
                            </div>
                            
                            <div class="mt-4 text-center text-xs text-${color}-600 font-semibold">
                                ROI: +${parlay.roi}% | ${parlay.picks?.length || 0} partite
                            </div>
                        </div>
                    `;
                }

                parlaysHtml += '</div>';

                if (Object.keys(parlays).length === 0) {
                    parlaysHtml = '<div class="text-center py-12 text-gray-500">Nessuna multipla disponibile per oggi.</div>';
                }

                contentDiv.innerHTML = header + parlaysHtml;
            }

            function renderLiveStrategyMatches(strategy) {
                const contentDiv = document.getElementById('pronostici-live-content');

                // Header
                const isMagia = (strategy.name || '').toUpperCase().includes('MAGIA AI');
                const headerColor = isMagia ? 'text-purple-700' : 'text-gray-800';

                const header = `
                    <div class="flex items-center justify-between mb-6">
                        <button onclick="window.loadPronosticiLiveStrategies()" class="text-sm bg-white border border-gray-300 hover:bg-gray-50 px-4 py-2 rounded-lg flex items-center gap-2 font-bold shadow-sm transition">
                            <i class="fas fa-arrow-left"></i> Torna alla Dashboard
                        </button>
                        <h3 class="text-2xl font-black ${headerColor} flex items-center gap-2">
                            ${isMagia ? '<i class="fas fa-wand-magic-sparkles"></i>' : '<i class="fas fa-list-ul"></i>'}
                            ${strategy.name}
                        </h3>
                    </div>
                `;


                contentDiv.innerHTML = header;

                // Matches Grid (List Layout)
                const matchesDiv = document.createElement('div');
                matchesDiv.className = 'flex flex-col gap-6 animate-fade-in max-w-5xl mx-auto';

                const matches = strategy.matches || [];

                if (matches.length === 0) {
                    matchesDiv.innerHTML = '<div class="text-center text-gray-500 py-20 italic bg-white rounded-2xl border-2 border-dashed">Nessuna partita in questa strategia.</div>';
                }

                const today = new Date().toISOString().split('T')[0];

                matches.forEach((m, idx) => {
                    const matchUUID = (m.partita + (m.data || today)).replace(/[^a-zA-Z0-9]/g, '');
                    const hasTrading = m.hasTradingStrategy || false;
                    const existingStrategy = m.tradingStrategy || null;
                    const enrichedMatch = {
                        ...m,
                        magicStats: m.magicStats || window.engine?.getMagiaStats?.(m, window.allMatches)
                    };

                    // Calculate ALL possible strategies
                    const allQualfied = window.engine?.calculateAllTradingStrategies?.(enrichedMatch, window.allMatches) || [];

                    if (allQualfied.length > 0) {
                        window.pendingTradingStrategies = window.pendingTradingStrategies || {};
                        window.pendingTradingStrategies[matchUUID] = {
                            match: m,
                            strategy: allQualfied[0].strategy // Default to best
                        };
                    }

                    const card = document.createElement('div');
                    card.className = `bg-white rounded-2xl border-2 ${isMagia ? 'border-purple-200 shadow-md' : 'border-gray-100 shadow-sm'} hover:shadow-lg transition-all overflow-hidden`;

                    // üî• NORMALIZE magicStats field names (Firebase saves winHome, UI expects winHomeProb)
                    const ms = enrichedMatch.magicStats || {};
                    const normalizedStats = {
                        winHomeProb: ms.winHomeProb || ms.winHome || 0,
                        drawProb: ms.drawProb || ms.draw || 0,
                        winAwayProb: ms.winAwayProb || ms.winAway || 0,
                        over15: ms.over15 || 0,
                        over25: ms.over25Prob || ms.over25 || 0,
                        under35: ms.under35 || 0,
                        btts: ms.btts || 0,
                        noGol: ms.noGol || 0,
                        dc1X: ms.dc1X || 0,
                        dcX2: ms.dcX2 || 0,
                        dc12: ms.dc12 || 0,
                        tipMagiaAI: ms.tipMagiaAI || m.tip,
                        probMagiaAI: ms.probMagiaAI || 0,
                        oddMagiaAI: ms.oddMagiaAI || m.quota,
                        smartScore: ms.smartScore || m.score || 0,
                        top3Scores: ms.top3Scores || (ms.exactScores || []).slice(0, 3).map(s => ({ score: s.score, percent: s.prob })) || [],
                        isReinforced: ms.isReinforced || (ms.tipMagiaAI === m.tip || ms.tipMagiaAI === m.originalDBTip)
                    };

                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // UNIFIED CARD RENDERING (Simple vs Magia AI)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    const isSimple = ['italia', 'all', '___magia_ai', 'top_eu', 'winrate_80'].includes(strategy.id || '');
                    let unifiedCardHtml = '';

                    if (isSimple && typeof window.renderSimpleStrategyCard === 'function') {
                        unifiedCardHtml = window.renderSimpleStrategyCard(m, idx);
                    } else if (isMagia && typeof window.renderMagiaAICard === 'function') {
                        unifiedCardHtml = window.renderMagiaAICard(m, idx);
                    } else {
                        // Standard generic card fallback if not simple or magia
                        unifiedCardHtml = `<div class="p-4 bg-gray-50 rounded-xl border border-gray-200">
                            <div class="font-bold text-gray-800">${m.partita}</div>
                            <div class="text-xl font-black text-blue-600">${m.tip} @${m.quota || '-'}</div>
                        </div>`;
                    }

                    if (unifiedCardHtml) {
                        const temp = document.createElement('div');
                        temp.innerHTML = unifiedCardHtml.trim();
                        const newCard = temp.firstElementChild;
                        if (newCard) {
                            card.innerHTML = '';
                            card.appendChild(newCard);
                        }
                    } else {
                        card.innerHTML = `<div class="p-4 text-red-500">Error rendering card.</div>`;
                    }

                    // --- RIGHT COLUMN: Trading Center ---
                    let tradingHtml = '';
                    if (hasTrading) {
                        tradingHtml = `
                            <div class="p-6 flex-1 bg-green-50/30 flex flex-col justify-center border-l-4 border-green-500">
                                <div class="flex items-center gap-3 mb-4">
                                    <div class="w-12 h-12 bg-green-500 text-white rounded-full flex items-center justify-center text-xl shadow-lg">
                                        <i class="fa-solid fa-bolt"></i>
                                    </div>
                                    <div>
                                        <h4 class="text-green-700 font-black text-lg">TRADING ATTIVO</h4>
                                        <p class="text-green-600 text-sm font-bold">${existingStrategy?.label || 'N/A'}</p>
                                    </div>
                                    <button onclick="removeTradingFromMatch('${matchUUID}', '${m.partita.replace(/'/g, "\\'")}', '${m.data || today}')" 
                                            class="ml-auto bg-white border border-red-200 text-red-500 hover:bg-red-50 p-3 rounded-xl transition shadow-sm">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>
                                </div>
                                <div class="grid grid-cols-2 lg:grid-cols-4 gap-4 p-4 bg-white rounded-2xl border border-green-100 shadow-sm">
                                    <div class="text-center">
                                        <div class="text-[10px] text-gray-400 uppercase font-bold">Entry Range</div>
                                        <div class="text-lg font-black text-gray-800">@${existingStrategy?.entry?.range?.join('-') || '-'}</div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-[10px] text-gray-400 uppercase font-bold">Target Exit</div>
                                        <div class="text-lg font-black text-gray-800">@${existingStrategy?.exit?.target || '-'}</div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-[10px] text-gray-400 uppercase font-bold">Timing</div>
                                        <div class="text-sm font-black text-gray-800">${existingStrategy?.entry?.timing || 'Live'}</div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-[10px] text-gray-400 uppercase font-bold">Confidence</div>
                                        <div class="text-lg font-black text-blue-600">${existingStrategy?.confidence || 70}%</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (allQualfied.length > 0) {
                        // AI SUGGESTIONS LIST
                        const suggestionsHtml = allQualfied.slice(0, 3).map((sq, i) => `
                            <div class="relative group p-3 rounded-xl border-2 ${i === 0 ? 'border-amber-400 bg-amber-50 shadow-sm' : 'border-gray-100 hover:border-amber-200'} transition-all cursor-pointer flex items-center gap-3"
                                 onclick="window.selectTradingOptionByObject('${matchUUID}', ${JSON.stringify(sq).replace(/"/g, '&quot;')})">
                                <div class="w-8 h-8 rounded-lg ${i === 0 ? 'bg-amber-500 text-white' : 'bg-gray-100 text-gray-400'} flex items-center justify-center font-bold text-sm">
                                    #${i + 1}
                                </div>
                                <div class="flex-1">
                                    <div class="flex justify-between items-center">
                                        <span class="font-black text-xs uppercase tracking-tight ${i === 0 ? 'text-amber-800' : 'text-gray-500'}">${(sq.strategy || sq.type || 'N/A').replace(/_/g, ' ')}</span>
                                        <span class="font-black text-xs ${sq.confidence >= 80 ? 'text-green-600' : 'text-amber-600'}">${sq.confidence}% Conf.</span>
                                    </div>
                                    <div class="text-[10px] text-gray-500 line-clamp-1">${sq.reasoning || 'Calcolato dall\'AI'}</div>
                                </div>
                                ${i === 0 ? '<div class="absolute -top-2 -right-1 bg-amber-500 text-white text-[8px] px-1.5 py-0.5 rounded-full font-black animate-bounce shadow">TOP AI</div>' : ''}
                            </div>
                        `).join('');

                        tradingHtml = `
                            <div class="p-6 flex-1 bg-slate-50/30 flex flex-col h-full">
                                <div class="flex items-center justify-between mb-4">
                                    <h4 class="text-gray-800 font-black flex items-center gap-2">
                                        <i class="fa-solid fa-brain text-amber-500"></i>
                                        STRATEGIE TRADING AI <span class="text-[10px] text-gray-400 font-bold uppercase">(Monte Carlo Simulation)</span>
                                    </h4>
                                    <button onclick="showManualTradingForm('${matchUUID}')" class="text-xs bg-white border border-gray-200 px-3 py-1.5 rounded-lg font-bold text-blue-600 shadow-sm hover:shadow">
                                        <i class="fa-solid fa-plus mr-1"></i> ASSEGNA MANUALE
                                    </button>
                                </div>

                                <div class="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4">
                                    ${suggestionsHtml}
                                </div>

                                <div class="mt-auto flex gap-3">
                                    <button onclick="confirmAITradingStrategy('${matchUUID}', '${m.partita.replace(/'/g, "\\'")}', '${m.data || today}')" 
                                            class="flex-1 bg-amber-500 hover:bg-amber-600 text-white font-black py-4 rounded-2xl shadow-lg shadow-amber-200 transition-all text-sm flex items-center justify-center gap-2">
                                        <i class="fa-solid fa-check-circle text-lg"></i> CONFERMA SELEZIONE AI
                                    </button>
                                </div>

                                <!-- MANUAL FORM (Hidden by default) -->
                                <div id="manual-form-${matchUUID}" class="hidden mt-4 p-4 bg-white rounded-2xl border-2 border-blue-200 shadow-inner">
                                    <div class="flex items-center gap-2 mb-3">
                                        <i class="fa-solid fa-keyboard text-blue-500"></i>
                                        <span class="text-blue-800 font-bold text-xs uppercase">Configurazione Manuale</span>
                                    </div>
                                    <div class="grid grid-cols-2 gap-3 mb-3">
                                        <div>
                                            <label class="text-[9px] font-bold text-gray-400 block mb-1">STRATEGIA</label>
                                            <select id="trading-type-${matchUUID}" class="w-full text-xs p-2 border-2 rounded-xl border-gray-100 focus:border-blue-500 outline-none">
                                                <option value="BACK_OVER_25">Back Over 2.5</option>
                                                <option value="BACK_OVER_25_2H">Back Over 2.5 (2H)</option>
                                                <option value="HT_SNIPER">HT Sniper</option>
                                                <option value="LAY_THE_DRAW">Lay The Draw (LTD)</option>
                                                <option value="UNDER_35_SCALPING">Under 3.5 Scalp</option>
                                                <option value="SECOND_HALF_SURGE">Second Half Surge</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label class="text-[9px] font-bold text-gray-400 block mb-1">CONFIDENZA %</label>
                                            <input type="number" id="trading-conf-${matchUUID}" class="w-full text-xs p-2 border-2 rounded-xl border-gray-100" value="70">
                                        </div>
                                    </div>
                                    <button onclick="assignTradingToMatch('${matchUUID}', '${m.partita.replace(/'/g, "\\'")}', '${m.data || today}', '${m.tip}')" 
                                            class="w-full bg-blue-600 hover:bg-blue-700 text-white font-black py-2.5 rounded-xl text-xs">
                                        APPLICA STRATEGIA SELEZIONATA
                                    </button>
                                </div>
                            </div>
                        `;
                    } else {
                        // NO QUALIFIED STRATEGIES - Show ALL strategies as clickable cards
                        const allStrategies = [
                            { type: 'BACK_OVER_25', label: 'Back Over 2.5', entry: '@2.1-2.4', exit: '@1.70', timing: '0-20min', icon: '‚öΩ', color: 'blue' },
                            { type: 'BACK_OVER_25_2H', label: 'Over 2.5 (2¬∞ Tempo)', entry: '@1.9-2.2', exit: '@1.60', timing: '46-70min', icon: 'üî•', color: 'orange' },
                            { type: 'LAY_THE_DRAW', label: 'Lay The Draw', entry: '@3.2-4.0', exit: '@2.20', timing: 'After goal', icon: 'üé≤', color: 'purple' },
                            { type: 'HT_SNIPER', label: 'HT Sniper', entry: '@1.7-2.0', exit: '@1.40', timing: '0-15min', icon: 'üéØ', color: 'green' },
                            { type: 'SCALPING_OVER_15', label: 'Scalping O1.5', entry: '@1.4-1.6', exit: '@1.20', timing: 'Quick', icon: '‚ö°', color: 'amber' }
                        ];

                        const stratCardsHtml = allStrategies.map(s => `
                            <div class="strategy-card cursor-pointer p-2 rounded-lg border-2 border-gray-100 hover:border-${s.color}-400 hover:bg-${s.color}-50 transition-all"
                                 onclick="selectStrategyCard('${matchUUID}', '${s.type}', this)">
                                <div class="flex items-center gap-2 mb-1">
                                    <span class="text-lg">${s.icon}</span>
                                    <span class="font-bold text-xs text-gray-700">${s.label}</span>
                                </div>
                                <div class="grid grid-cols-3 gap-1 text-[9px] text-gray-500">
                                    <div><span class="font-bold text-gray-400">Entry:</span> ${s.entry}</div>
                                    <div><span class="font-bold text-gray-400">Exit:</span> ${s.exit}</div>
                                    <div><span class="font-bold text-gray-400">‚è±Ô∏è</span> ${s.timing}</div>
                                </div>
                            </div>
                        `).join('');

                        tradingHtml = `
                            <div id="trading-section-${matchUUID}" class="p-3 flex-1 bg-gray-50/50 flex flex-col">
                                <div class="text-center mb-2">
                                    <p class="text-gray-500 text-[10px] font-bold uppercase tracking-wider">üìä Scegli una strategia trading</p>
                                </div>
                                <div class="grid grid-cols-2 lg:grid-cols-3 gap-2 mb-3">
                                    ${stratCardsHtml}
                                </div>
                                <input type="hidden" id="trading-type-${matchUUID}" value="BACK_OVER_25">
                                <input type="hidden" id="trading-conf-${matchUUID}" value="75">
                                <button onclick="assignTradingToMatch('${matchUUID}', '${m.partita.replace(/'/g, "\\'")}', '${m.data || today}', '${m.tip}')" 
                                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-black py-2 rounded-lg text-xs transition mt-auto">
                                    <i class="fa-solid fa-check mr-1"></i> CONFERMA SELEZIONE
                                </button>
                            </div>
                        `;
                    }

                    // Trading HTML is appended AFTER the main card (only for non-Magia AND non-Simple strategies)
                    if (!isMagia && !isSimple && tradingHtml) {
                        card.innerHTML += tradingHtml;
                    }
                    matchesDiv.appendChild(card);
                });

                contentDiv.appendChild(matchesDiv);
            }

            /**
             * Helper for selecting a strategy from the qualified list
             */
            window.selectTradingOptionByObject = function (matchUUID, strategyObj) {
                window.pendingTradingStrategies = window.pendingTradingStrategies || {};
                window.pendingTradingStrategies[matchUUID] = {
                    match: window.pendingTradingStrategies[matchUUID]?.match || {},
                    strategy: strategyObj
                };

                // Visual feedback: find the cards in the document
                const card = event.currentTarget;
                const parent = card.parentElement;

                parent.querySelectorAll('div.group').forEach(c => {
                    c.classList.remove('border-amber-400', 'bg-amber-50');
                    c.classList.add('border-gray-100');
                    const rank = c.querySelector('div.w-8');
                    if (rank) rank.classList.replace('bg-amber-500', 'bg-gray-100');
                    if (rank) rank.classList.replace('text-white', 'text-gray-400');
                    const label = c.querySelector('span.font-black.text-xs');
                    if (label) label.classList.replace('text-amber-800', 'text-gray-500');
                });

                card.classList.replace('border-gray-100', 'border-amber-400');
                card.classList.add('bg-amber-50');
                const rank = card.querySelector('div.w-8');
                if (rank) rank.classList.replace('bg-gray-100', 'bg-amber-500');
                if (rank) rank.classList.replace('text-gray-400', 'text-white');
                const label = card.querySelector('span.font-black.text-xs');
                if (label) label.classList.replace('text-gray-500', 'text-amber-800');

                console.log(`[Trading] Selected alternative AI strategy for ${matchUUID}: ${strategyObj.strategy}`);
            };

            // Expose and Auto-Load (SEPARATED)
            window.loadOpportunities30 = loadOpportunities30;
            window.loadPronosticiLiveStrategies = loadPronosticiLiveStrategies; // Pronostici Tab
            window.loadTradingLiveOpportunities = loadTradingLiveOpportunities; // Trading 3.0 Tab (exposed in trading script)

            // Auto-load Pronostici on startup
            setTimeout(() => {
                loadPronosticiLiveStrategies();
            }, 1500); // Small delay to ensure Firebase is ready

            // ==================== CATALOGO LEGHE (Main Page Init) ====================
            async function initMainCatalogStatus() {
                const statusEl = document.getElementById('main-catalog-status');
                if (!statusEl) return;

                try {
                    await window.LocalDB.init();
                    const catalog = await window.LocalDB.getCatalog();
                    if (catalog && catalog.length > 0) {
                        statusEl.textContent = `‚úÖ ${catalog.length} leghe caricate`;
                        statusEl.classList.add('text-green-600');
                    } else {
                        statusEl.textContent = '‚ö†Ô∏è Catalogo vuoto - clicca per scaricare';
                        statusEl.classList.add('text-orange-500');
                    }
                } catch (e) {
                    statusEl.textContent = '‚ùå Errore database';
                    statusEl.classList.add('text-red-500');
                }
            }

            async function mainDownloadCatalog() {
                const btn = document.getElementById('main-download-catalog-btn');
                const statusEl = document.getElementById('main-catalog-status');
                if (!btn || !statusEl) return;

                btn.disabled = true;
                btn.textContent = '‚è≥ Scaricando...';
                statusEl.textContent = 'Download in corso...';
                statusEl.className = 'text-sm text-blue-500';

                try {
                    if (typeof window.getFootballData !== 'function') {
                        throw new Error('API bridge non disponibile');
                    }

                    const result = await window.getFootballData({
                        endpoint: 'leagues',
                        params: {}
                    });

                    if (!result || !result.data || !result.data.response) {
                        throw new Error('Risposta API vuota');
                    }

                    const leagues = result.data.response.map(l => ({
                        id: l.league.id,
                        name: l.league.name,
                        type: l.league.type,
                        logo: l.league.logo,
                        country: l.country.name,
                        countryCode: l.country.code,
                        countryFlag: l.country.flag
                    }));

                    await window.LocalDB.saveCatalog(leagues);

                    statusEl.textContent = `‚úÖ ${leagues.length} leghe scaricate!`;
                    statusEl.className = 'text-sm text-green-600 font-bold';
                    console.log(`[Catalog] Downloaded ${leagues.length} leagues`);

                } catch (err) {
                    console.error('[Catalog] Error:', err);
                    statusEl.textContent = `‚ùå Errore: ${err.message}`;
                    statusEl.className = 'text-sm text-red-500';
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'üì• Scarica Catalogo';
                }
            }

            // Bind main catalog download button
            const mainCatalogBtn = document.getElementById('main-download-catalog-btn');
            if (mainCatalogBtn) {
                mainCatalogBtn.addEventListener('click', mainDownloadCatalog);
            }

            // Init main catalog status on page load
            setTimeout(initMainCatalogStatus, 500);

            // ==================== EXPORT CATALOG JSON ====================
            async function exportCatalogJSON() {
                try {
                    const catalog = await window.LocalDB.getCatalog();
                    if (!catalog || catalog.length === 0) {
                        alert('Catalogo vuoto! Scarica prima da API.');
                        return;
                    }

                    const blob = new Blob([JSON.stringify(catalog, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `leagues_catalog_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    console.log(`[Export] Catalog exported: ${catalog.length} leagues`);
                } catch (err) {
                    console.error('[Export] Error:', err);
                    alert('Errore export: ' + err.message);
                }
            }

            // ==================== EXPORT REGISTRY JSON ====================
            async function exportRegistryJSON() {
                try {
                    const registry = await window.LocalDB.getAllLeagueMappings();
                    if (!registry || registry.length === 0) {
                        alert('Registry vuoto! Associa prima le leghe.');
                        return;
                    }

                    const blob = new Blob([JSON.stringify(registry, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `leagues_registry_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    console.log(`[Export] Registry exported: ${registry.length} mappings`);
                } catch (err) {
                    console.error('[Export] Error:', err);
                    alert('Errore export: ' + err.message);
                }
            }

            // ==================== INIT REGISTRY STATUS ====================
            async function initRegistryStatus() {
                const statusEl = document.getElementById('registry-status');
                if (!statusEl) return;

                try {
                    await window.LocalDB.init();
                    const registry = await window.LocalDB.getAllLeagueMappings();
                    const matches = await window.LocalDB.getAllMatches();
                    const uniqueLeagues = [...new Set(matches.map(m => m.lega).filter(Boolean))];

                    if (registry && registry.length > 0) {
                        statusEl.textContent = `‚úÖ ${registry.length} associazioni / ${uniqueLeagues.length} leghe nel DB`;
                        statusEl.classList.add('text-green-600');
                    } else {
                        statusEl.textContent = `‚ö†Ô∏è 0 associazioni / ${uniqueLeagues.length} leghe nel DB`;
                        statusEl.classList.add('text-orange-500');
                    }
                } catch (e) {
                    statusEl.textContent = '‚ùå Errore database';
                    statusEl.classList.add('text-red-500');
                }
            }

            // ==================== ASSOCIATE ALL LEAGUES ====================
            let pendingAssociations = { matched: [], ambiguous: [], notFound: [] };

            async function associateAllLeagues() {
                const btn = document.getElementById('associate-all-leagues-btn');
                const reportDiv = document.getElementById('association-report');
                const progressDiv = document.getElementById('association-progress');

                btn.disabled = true;
                btn.textContent = '‚è≥ Elaborazione...';
                reportDiv.classList.remove('hidden');

                pendingAssociations = { matched: [], ambiguous: [], notFound: [] };

                const updateCounters = () => {
                    document.getElementById('matched-count').textContent = pendingAssociations.matched.length;
                    document.getElementById('ambiguous-count').textContent = pendingAssociations.ambiguous.length;
                    document.getElementById('notfound-count').textContent = pendingAssociations.notFound.length;
                };

                try {
                    // 1. Get catalog
                    const catalog = await window.LocalDB.getCatalog();
                    if (!catalog || catalog.length === 0) {
                        throw new Error('Catalogo vuoto! Scarica prima da API.');
                    }

                    // 2. Get all unique leagues from matches
                    const matches = await window.LocalDB.getAllMatches();
                    const uniqueLeagues = [...new Set(matches.map(m => m.lega).filter(Boolean))];

                    // 2b. Get current registry to avoid re-matching
                    const registry = await window.LocalDB.getAllLeagueMappings();
                    const registryMap = new Map();
                    registry.forEach(r => registryMap.set(r.name.toLowerCase().trim(), r));

                    progressDiv.textContent = `Analisi di ${uniqueLeagues.length} leghe...`;

                    // 3. Country code to API country name mapping
                    const COUNTRY_MAP = {
                        // Europe
                        'ENG': 'England', 'GER': 'Germany', 'ESP': 'Spain', 'ITA': 'Italy', 'FRA': 'France',
                        'NED': 'Netherlands', 'NLD': 'Netherlands', 'POR': 'Portugal', 'BEL': 'Belgium', 'SCO': 'Scotland',
                        'TUR': 'Turkey', 'GRE': 'Greece', 'AUT': 'Austria', 'CHE': 'Switzerland', 'POL': 'Poland',
                        'UKR': 'Ukraine', 'RUS': 'Russia', 'CZE': 'Czech-Republic', 'DEN': 'Denmark', 'DNK': 'Denmark',
                        'NOR': 'Norway', 'SWE': 'Sweden', 'FIN': 'Finland', 'HRV': 'Croatia', 'SRB': 'Serbia',
                        'ROU': 'Romania', 'BUL': 'Bulgaria', 'HUN': 'Hungary', 'SLO': 'Slovenia', 'SVK': 'Slovakia',
                        'CYP': 'Cyprus', 'ISR': 'Israel', 'NIR': 'Northern-Ireland', 'WAL': 'Wales', 'IRL': 'Ireland',
                        'ISL': 'Iceland', 'MLT': 'Malta', 'LUX': 'Luxembourg', 'BIH': 'Bosnia', 'MNE': 'Montenegro',
                        'ALB': 'Albania', 'MKD': 'North-Macedonia', 'KOS': 'Kosovo', 'LTU': 'Lithuania', 'LVA': 'Latvia',
                        'EST': 'Estonia', 'BLR': 'Belarus', 'GEO': 'Georgia', 'ARM': 'Armenia', 'AZE': 'Azerbaijan',
                        'KAZ': 'Kazakhstan', 'MOL': 'Moldova', 'SVN': 'Slovenia',
                        // South America
                        'ARG': 'Argentina', 'BRA': 'Brazil', 'CHI': 'Chile', 'CHL': 'Chile', 'COL': 'Colombia',
                        'ECU': 'Ecuador', 'PER': 'Peru', 'URY': 'Uruguay', 'VEN': 'Venezuela', 'PAR': 'Paraguay',
                        'PRY': 'Paraguay', 'BOL': 'Bolivia',
                        // North/Central America
                        'USA': 'USA', 'MEX': 'Mexico', 'CAN': 'Canada', 'CRI': 'Costa-Rica', 'CRC': 'Costa-Rica', 'HON': 'Honduras',
                        'SLV': 'El-Salvador', 'GUA': 'Guatemala', 'PAN': 'Panama', 'JAM': 'Jamaica',
                        // Asia
                        'JPN': 'Japan', 'KOR': 'South-Korea', 'CHN': 'China', 'SAU': 'Saudi-Arabia', 'UAE': 'United-Arab-Emirates',
                        'QAT': 'Qatar', 'IND': 'India', 'THA': 'Thailand', 'VNM': 'Vietnam', 'IDN': 'Indonesia',
                        'MYS': 'Malaysia', 'AUS': 'Australia', 'IRN': 'Iran', 'IRQ': 'Iraq', 'JOR': 'Jordan',
                        'KWT': 'Kuwait', 'BHR': 'Bahrain', 'OMN': 'Oman', 'SYR': 'Syria', 'LBN': 'Lebanon',
                        'UZB': 'Uzbekistan', 'TJK': 'Tajikistan', 'HKG': 'Hong-Kong', 'TWN': 'Chinese-Taipei',
                        // Africa
                        'ZAF': 'South-Africa', 'EGY': 'Egypt', 'MAR': 'Morocco', 'TUN': 'Tunisia', 'ALG': 'Algeria',
                        'NGA': 'Nigeria', 'GHA': 'Ghana', 'CMR': 'Cameroon', 'SEN': 'Senegal', 'CIV': 'Ivory-Coast',
                        'KEN': 'Kenya', 'UGA': 'Uganda', 'TAN': 'Tanzania', 'ZAM': 'Zambia', 'ZIM': 'Zimbabwe',
                        'ETH': 'Ethiopia', 'COD': 'DR-Congo', 'ANG': 'Angola', 'MOZ': 'Mozambique',
                        // International
                        'INT': 'World'
                    };

                    // 4. For each league, find match in catalog
                    for (let i = 0; i < uniqueLeagues.length; i++) {
                        const label = uniqueLeagues[i];
                        progressDiv.textContent = `Analisi ${i + 1}/${uniqueLeagues.length}: ${label}`;

                        // --- NEW: Check if already in Registry ---
                        const existing = registryMap.get(label.toLowerCase().trim());
                        if (existing) {
                            pendingAssociations.matched.push({
                                label,
                                id: existing.leagueId,
                                apiName: existing.apiName || 'Saved',
                                country: existing.country || '-'
                            });
                            updateCounters();
                            continue; // Skip to next league
                        }

                        // Parse label: EU-ENG Premier League, SA-ARG Primera Division, etc.
                        let searchName = label;
                        let searchCountry = null;
                        let isInternational = false;

                        // Match patterns: EU-ENG, SA-ARG, AF-EGY, AS-JPN, etc.
                        const prefixMatch = label.match(/^(EU|SA|AF|AS|NA|OC)-([A-Z]{2,3})[\s-]+(.+)$/i);
                        const intMatch = label.match(/^EU-(?:INT[\s-])?(.+)$/i);

                        if (prefixMatch) {
                            const countryCode = prefixMatch[2].toUpperCase();
                            searchName = prefixMatch[3].trim();
                            searchCountry = COUNTRY_MAP[countryCode] || null;
                        } else if (intMatch) {
                            // International competition (Champions League, Europa League, etc.)
                            searchName = intMatch[1].trim();
                            isInternational = true;
                        }

                        // Normalize search name (Italian to English / API standards)
                        const normalizedClean = searchName.toLowerCase()
                            .replace(/\bgirone\b/g, 'group')
                            .replace(/\bcorea\b/g, 'korean') // Match South Korea or Korea
                            .replace(/\btailandia\b/g, 'thailand')
                            .replace(/\bvietnam\b/g, 'viet nam')
                            .replace(/\bbielorussia\b/g, 'belarus')
                            .replace(/\bolanda\b/g, 'netherlands');

                        const words = normalizedClean.split(/\s+/).filter(w => w.length >= 2 || (w.length === 1 && /[abc]/.test(w)));
                        const numbersInSearch = normalizedClean.match(/\d+/g) || [];

                        // Search in catalog with country filter
                        let catalogMatches = catalog.filter(l => {
                            const catalogName = l.name.toLowerCase();
                            const catalogCountry = l.country.toLowerCase();

                            // Country filter (if we have a country)
                            if (searchCountry) {
                                const cleanSearchCountry = searchCountry.toLowerCase().replace(/[\s-]/g, '');
                                const cleanCatalogCountry = catalogCountry.replace(/[\s-]/g, '');
                                if (cleanSearchCountry !== cleanCatalogCountry) return false;
                            }

                            // Match Numeri (fondamentale per Ligue 1 vs Ligue 2)
                            const numbersInCatalog = catalogName.match(/\d+/g) || [];
                            if (numbersInSearch.length > 0) {
                                // Se cerchiamo un numero, deve essere presente lo STESSO numero nel catalogo
                                const anyNumberMismatch = numbersInSearch.some(num => !numbersInCatalog.includes(num));
                                if (anyNumberMismatch) return false;
                            } else if (numbersInCatalog.length > 0) {
                                // Se NON cerchiamo numeri ma il catalogo ne ha, scarta (es. cerco "Ligue" e trovo "Ligue 1")
                                return false;
                            }

                            // Name matching (Normalization for comparison)
                            const normCatalog = catalogName
                                .replace(/\bgirone\b/g, 'group')
                                .replace(/[\s-]/g, '');
                            const normSearch = normalizedClean
                                .replace(/\bgirone\b/g, 'group')
                                .replace(/[\s-]/g, '');

                            if (normCatalog === normSearch) return true;
                            if (normCatalog.includes(normSearch) || normSearch.includes(normCatalog)) return true;

                            // Token check
                            if (words.length > 0 && words.every(w => {
                                const cleanW = w.replace(/\bgirone\b/g, 'group');
                                return normCatalog.includes(cleanW);
                            })) return true;

                            // [REMOVED] UEFA special cases (handle manually)

                            return false;
                        });

                        if (catalogMatches.length === 1) {
                            pendingAssociations.matched.push({
                                label,
                                id: catalogMatches[0].id,
                                apiName: catalogMatches[0].name,
                                country: catalogMatches[0].country
                            });
                        } else if (catalogMatches.length > 1) {
                            pendingAssociations.ambiguous.push({
                                label,
                                options: catalogMatches.slice(0, 10) // Max 10 options
                            });
                        } else {
                            pendingAssociations.notFound.push({ label });
                        }

                        updateCounters();
                    }

                    progressDiv.textContent = `‚úÖ Analisi completata!`;

                    // Show ambiguous list
                    if (pendingAssociations.ambiguous.length > 0) {
                        document.getElementById('ambiguous-section').classList.remove('hidden');
                        document.getElementById('ambiguous-list').innerHTML = pendingAssociations.ambiguous.map((l, idx) => `
                            <div class="bg-orange-100 p-2 rounded border border-orange-200">
                                <div class="font-medium text-orange-800 mb-1">${l.label}</div>
                                <select id="ambig-select-${idx}" class="w-full p-1 rounded border text-sm" data-label="${l.label}">
                                    <option value="">-- Scegli --</option>
                                    ${l.options.map(o => `<option value="${o.id}">${o.name} (${o.country}) - ID ${o.id}</option>`).join('')}
                                </select>
                            </div>
                        `).join('');
                    }

                    // Show not found list
                    if (pendingAssociations.notFound.length > 0) {
                        document.getElementById('notfound-section').classList.remove('hidden');
                        document.getElementById('notfound-list').innerHTML = pendingAssociations.notFound.map((l, idx) => `
                            <div class="bg-red-100 p-2 rounded border border-red-200">
                                <div class="flex items-center justify-between gap-2 overflow-hidden">
                                    <span class="text-red-800 font-medium truncate mr-1" title="${l.label}">${l.label}</span>
                                    <div class="flex items-center gap-2 flex-shrink-0">
                                        <button onclick="discoverByTeam('${l.label.replace(/'/g, "\\'")}', this)" 
                                                class="bg-blue-600 text-white px-2 py-1 rounded text-[10px] font-bold hover:bg-blue-700 transition-all">
                                            üîç SCOPRI
                                        </button>
                                        <input type="number" id="notfound-id-${idx}" class="w-20 p-1 rounded border text-sm" placeholder="ID API" data-label="${l.label}">
                                    </div>
                                </div>
                            </div>
                        `).join('');
                    }

                    // Show save button
                    document.getElementById('save-associations-btn').classList.remove('hidden');

                } catch (err) {
                    console.error('[Association] Error:', err);
                    progressDiv.textContent = `‚ùå Errore: ${err.message}`;
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'üîÑ Associa Tutte';
                }
            }

            // ==================== SAVE ASSOCIATIONS ====================
            async function saveAllAssociations() {
                const btn = document.getElementById('save-associations-btn');
                btn.disabled = true;
                btn.textContent = '‚è≥ Salvataggio...';

                try {
                    const toSave = [];

                    // 1. Collect matched
                    pendingAssociations.matched.forEach(m => {
                        toSave.push({
                            label: m.label,
                            id: m.id,
                            meta: {
                                apiName: m.apiName,
                                country: m.country,
                                source: 'bulk-association'
                            }
                        });
                    });

                    // 2. Collect selected ambiguous
                    for (let i = 0; i < pendingAssociations.ambiguous.length; i++) {
                        const select = document.getElementById(`ambig-select-${i}`);
                        if (select && select.value) {
                            const label = select.getAttribute('data-label');
                            const selectedOption = pendingAssociations.ambiguous[i].options.find(o => o.id == select.value);
                            if (selectedOption) {
                                toSave.push({
                                    label: label,
                                    id: selectedOption.id,
                                    meta: {
                                        apiName: selectedOption.name,
                                        country: selectedOption.country,
                                        source: 'bulk-association-manual'
                                    }
                                });
                            }
                        }
                    }

                    // 3. Collect manual Not Found inputs
                    for (let i = 0; i < pendingAssociations.notFound.length; i++) {
                        const input = document.getElementById(`notfound-id-${i}`);
                        if (input && input.value) {
                            const label = input.getAttribute('data-label');
                            const manualId = parseInt(input.value);
                            if (!isNaN(manualId)) {
                                toSave.push({
                                    label: label,
                                    id: manualId,
                                    meta: {
                                        apiName: 'Manual Entry',
                                        source: 'bulk-association-manual-notfound'
                                    }
                                });
                            }
                        }
                    }

                    if (toSave.length === 0) {
                        alert("Nessuna associazione da salvare!");
                        btn.disabled = false;
                        btn.textContent = '‚úÖ Salva Tutte le Associazioni';
                        return;
                    }

                    // 4. Bulk Save
                    console.log(`[Association] Saving ${toSave.length} mappings...`, toSave);
                    await window.LocalDB.saveLeagueMappingsBulk(toSave);

                    btn.textContent = `‚úÖ Salvate ${toSave.length} leghe!`;
                    btn.classList.replace('bg-green-600', 'bg-blue-600');

                    // Refresh registry status in UI
                    await initRegistryStatus();

                    // Optional: hide report or reset 
                    setTimeout(() => {
                        btn.textContent = '‚úÖ Salva Tutte le Associazioni';
                        btn.classList.replace('bg-blue-600', 'bg-green-600');
                        btn.disabled = false;
                    }, 3000);

                } catch (err) {
                    console.error('[Association] Save error:', err);
                    alert("Errore durante il salvataggio: " + err.message);
                    btn.textContent = '‚ùå Errore!';
                    btn.disabled = false;
                }
            }

            // Bind buttons
            const exportCatalogBtn = document.getElementById('export-catalog-btn');
            if (exportCatalogBtn) exportCatalogBtn.addEventListener('click', exportCatalogJSON);

            const listLeaguesBtn = document.getElementById('list-leagues-btn');
            const leaguesListModal = document.getElementById('leagues-list-modal');
            const closeLeaguesListBtn = document.getElementById('close-leagues-list-btn');
            const leaguesListBody = document.getElementById('leagues-list-body');
            const leagueListSearch = document.getElementById('league-list-search');
            const totalLeaguesCountEl = document.getElementById('total-leagues-registry-count');

            async function listLeaguesRegistry() {
                try {
                    const registry = await window.LocalDB.getAllLeagues();
                    renderLeaguesList(registry);
                    if (totalLeaguesCountEl) totalLeaguesCountEl.textContent = registry.length;
                    if (leaguesListModal) leaguesListModal.classList.remove('hidden');
                } catch (err) {
                    console.error("Error listing leagues:", err);
                    alert("Errore nel caricamento del Registry");
                }
            }

            function renderLeaguesList(leagues, filter = '') {
                if (!leaguesListBody) return;
                leaguesListBody.innerHTML = '';

                const filtered = filter ? leagues.filter(l => l.name.toLowerCase().includes(filter.toLowerCase())) : leagues;

                // Sort by TrustScore (desc) then name
                filtered.sort((a, b) => (b.trustScore || 0) - (a.trustScore || 0) || a.name.localeCompare(b.name));

                filtered.forEach(l => {
                    const trust = l.trustScore || 5.0;
                    const mode = l.mode || 'STANDARD';
                    const samples = l.samples || 0;
                    const wr = l.o15_wr || '0.0';

                    const modeColor = mode === 'SNIPER' ? 'text-purple-600 bg-purple-50 border-purple-200' :
                        (mode === 'DEFENDER' ? 'text-red-600 bg-red-50 border-red-200' : 'text-gray-600 bg-gray-50 border-gray-200');
                    const modeIcon = mode === 'SNIPER' ? 'üéØ' : (mode === 'DEFENDER' ? 'üõ°Ô∏è' : 'üìä');

                    const row = document.createElement('tr');
                    row.className = 'hover:bg-amber-50/30 transition-colors cursor-default';
                    row.innerHTML = `
                        <td class="p-3 border-b font-medium">${l.name}</td>
                        <td class="p-3 border-b">
                            <div class="flex items-center gap-1">
                                <input type="number" 
                                       id="registry-id-${l.name.replace(/[^a-z0-9]/gi, '_')}" 
                                       value="${l.leagueId}" 
                                       class="w-20 p-1 text-xs border border-gray-300 rounded font-mono"
                                       data-original="${l.leagueId}">
                                <button onclick="updateRegistryLeagueId('${l.name.replace(/'/g, "\\\\'").replace(/"/g, '&quot;')}', document.getElementById('registry-id-${l.name.replace(/[^a-z0-9]/gi, '_')}').value, ${l.leagueId})"
                                        class="bg-amber-600 text-white px-2 py-1 text-[10px] rounded hover:bg-amber-700 font-bold transition-colors">
                                    üíæ
                                </button>
                            </div>
                        </td>
                        <td class="p-3 border-b">
                            <div class="flex flex-wrap gap-1">
                                ${l.aliases && l.aliases.length > 0 ?
                            l.aliases.map(a => `
                                        <div class="flex items-center gap-1 bg-gray-50 p-1 rounded border border-gray-200 mb-1">
                                            <span class="text-[9px] font-bold text-gray-600 truncate max-w-[100px]" title="${a}">${a}</span>
                                            <input type="number" 
                                                   id="alias-id-${a.replace(/[^a-z0-9]/gi, '_')}" 
                                                   value="${l.leagueId}" 
                                                   class="w-12 p-0.5 text-[9px] border border-gray-300 rounded text-center focus:ring-1 focus:ring-blue-400" />
                                            <button onclick="updateRegistryAliasId('${a.replace(/'/g, "\\\\'")}', document.getElementById('alias-id-${a.replace(/[^a-z0-9]/gi, '_')}').value, ${l.leagueId})" 
                                                    class="bg-blue-600 text-white px-1 py-0.5 rounded text-[9px] hover:bg-blue-700 transition-colors shadow-sm">
                                                üíæ
                                            </button>
                                        </div>
                                    `).join('') :
                            '<span class="text-gray-300 text-[10px] italic">nessuna</span>'
                        }

                            </div>
                        </td>
                        <td class="p-3 border-b text-center">
                            <input type="checkbox" 
                                   ${l.trading ? 'checked' : ''} 
                                   onchange="toggleLeagueTrading('${l.name.replace(/'/g, "\\\\'").replace(/"/g, '&quot;')}', this.checked)"
                                   class="w-5 h-5 accent-amber-600 cursor-pointer">
                        </td>
                        <td class="p-3 border-b font-bold text-amber-700">${trust.toFixed(1)}/10</td>
                        <td class="p-3 border-b">
                            <span class="px-2 py-0.5 rounded border text-[10px] font-bold ${modeColor}">${modeIcon} ${mode}</span>
                        </td>
                        <td class="p-3 border-b text-gray-500">${samples}</td>
                        <td class="p-3 border-b font-semibold ${parseFloat(wr) >= 80 ? 'text-green-600' : (parseFloat(wr) < 60 ? 'text-red-500' : 'text-gray-600')}">${wr}%</td>
                        <td class="p-3 border-b text-right">
                            <button onclick="deleteLeagueRegistry('${l.name.replace(/'/g, "\\'")}')" 
                                    class="text-red-400 hover:text-red-600 transition-colors p-2" 
                                    title="Elimina dal Registry (sar√† esclusa dall'AI)">
                                <i class="fa-solid fa-trash-can"></i>
                            </button>
                        </td>
                    `;
                    leaguesListBody.appendChild(row);
                });
            }

            // üî• NEW: Funzione per modificare league ID dal Registry Intelligence
            window.updateRegistryLeagueId = async function (leagueLabel, newId, originalId) {
                const id = parseInt(newId);
                if (isNaN(id) || id <= 0) {
                    alert('‚ùå ID non valido! Inserisci un numero positivo.');
                    return;
                }

                try {
                    // Salva nel Database locale
                    await window.LocalDB.saveLeagueMapping(leagueLabel, id, {
                        source: 'registry_edit',
                        editedAt: Date.now(),
                        previousId: originalId
                    });

                    console.log(`[Registry ID Update] "${leagueLabel}": ${originalId} ‚Üí ${id}`);
                    alert(`‚úÖ ID aggiornato!\n\n"${leagueLabel}"\n\nID: ${originalId} ‚Üí ${id}\n\nSalvato nel database.`);

                    // Ricarica lista per mostrare modifiche
                    const registry = await window.LocalDB.getAllLeagues();
                    const currentFilter = document.getElementById('league-list-search')?.value || '';
                    renderLeaguesList(registry, currentFilter);

                } catch (error) {
                    console.error('[Registry ID Update] Error:', error);
                    alert(`‚ùå Errore nel salvataggio: ${error.message}`);
                }
            };

            // üî• NEW: Funzione per spostare un Alias tra diverse leghe del Registry
            window.updateRegistryAliasId = async function (aliasName, newId, currentLeagueId) {
                const targetId = parseInt(newId);
                if (isNaN(targetId) || targetId <= 0) {
                    alert('‚ùå ID non valido! Inserisci un numero positivo.');
                    return;
                }

                if (targetId === currentLeagueId) {
                    alert(`Socio, l'ID ${targetId} √® lo stesso di prima. Nessuna modifica necessaria.`);
                    return;
                }

                try {
                    const registry = await window.LocalDB.getAllLeagues();

                    // 1. Trova la lega sorgente (quella che ha attualmente l'alias)
                    const sourceLeague = registry.find(l => l.leagueId === currentLeagueId && l.aliases && l.aliases.includes(aliasName));

                    if (!sourceLeague) {
                        alert(`‚ùå Impossibile trovare la lega che contiene l'alias "${aliasName}" con ID ${currentLeagueId}.`);
                        return;
                    }

                    // 2. Rimuovi l'alias dalla sorgente
                    sourceLeague.aliases = sourceLeague.aliases.filter(a => a !== aliasName);
                    await window.LocalDB.saveLeagueMapping(sourceLeague.name, sourceLeague.leagueId, sourceLeague);

                    // 3. Trova la lega di destinazione (se esiste)
                    const targetLeague = registry.find(l => l.leagueId === targetId);

                    if (targetLeague) {
                        // Aggiungi l'alias alla destinazione
                        if (!targetLeague.aliases) targetLeague.aliases = [];
                        if (!targetLeague.aliases.includes(aliasName)) {
                            targetLeague.aliases.push(aliasName);
                        }
                        await window.LocalDB.saveLeagueMapping(targetLeague.name, targetLeague.leagueId, targetLeague);
                        console.log(`[Alias Move] "${aliasName}" moved from ID ${currentLeagueId} to ID ${targetId} (${targetLeague.name})`);
                        alert(`‚úÖ Alias "${aliasName}" spostato con successo!\n\nDa: ${sourceLeague.name}\nA: ${targetLeague.name}`);
                    } else {
                        // Crea una nuova voce principale se l'ID non esiste
                        if (confirm(`Socio, l'ID ${targetId} non esiste ancora nel registro.\n\nVuoi creare una NUOVA lega principale chiamata "${aliasName}" con questo ID?`)) {
                            await window.LocalDB.saveLeagueMapping(aliasName, targetId, {
                                aliases: [],
                                trustScore: 5.0,
                                mode: 'STANDARD',
                                samples: 0,
                                o15_wr: '0.0',
                                updatedAt: Date.now()
                            });
                            alert(`‚úÖ Creata nuova lega principale "${aliasName}" con ID ${targetId}`);
                        }
                    }

                    // Refresh UI
                    const updatedRegistry = await window.LocalDB.getAllLeagues();
                    const currentFilter = document.getElementById('league-list-search')?.value || '';
                    renderLeaguesList(updatedRegistry, currentFilter);

                } catch (error) {
                    console.error('[Alias Update] Error:', error);
                    alert(`‚ùå Errore nello spostamento: ${error.message}`);
                }
            };


            // Funzione per eliminare lega dal registry
            window.deleteLeagueRegistry = async function (leagueName) {
                if (!confirm(`Socio, vuoi davvero eliminare "${leagueName}" dal Registry?\n\n‚ö†Ô∏è Non sar√† pi√π considerata dal Pulsantone AI!`)) return;

                try {
                    await window.LocalDB.deleteLeagueMapping(leagueName);
                    console.log(`[Registry] Eliminata lega: ${leagueName}`);

                    // Ricarica lista
                    const registry = await window.LocalDB.getAllLeagues();
                    const currentFilter = document.getElementById('league-list-search')?.value || '';
                    renderLeaguesList(registry, currentFilter);

                    // Aggiorna conteggi UI
                    if (totalLeaguesCountEl) totalLeaguesCountEl.textContent = registry.length;
                    if (typeof initRegistryStatus === 'function') initRegistryStatus();

                } catch (err) {
                    console.error("Delete Error:", err);
                    alert("Errore durante l'eliminazione");
                }
            };

            // üî• NEW: Toggle Trading Flag per lo Step 3
            window.toggleLeagueTrading = async function (leagueLabel, autoTrading) {
                try {
                    // Recuperiamo la mappatura esistente per preservare gli altri campi
                    const registry = await window.LocalDB.getAllLeagueMappings();
                    const mapping = registry.find(m => m.name === leagueLabel || m.label === leagueLabel);

                    if (!mapping) {
                        console.warn(`[Registry Trading] Lega "${leagueLabel}" non trovata nel DB.`);
                        return;
                    }

                    // Aggiorniamo solo il flag trading
                    await window.LocalDB.saveLeagueMapping(leagueLabel, mapping.leagueId, {
                        ...mapping,
                        trading: autoTrading,
                        updatedAt: Date.now()
                    });

                    console.log(`[Registry Trading] "${leagueLabel}": Trading ‚Üí ${autoTrading}`);

                    // Notifica visiva veloce (opzionale, ma utile per feedback)
                    // Non usiamo alert per non bloccare l'utente durante i click multipli
                } catch (error) {
                    console.error('[Registry Trading Update] Error:', error);
                    alert(`‚ùå Errore nel salvataggio: ${error.message}`);
                }
            };

            if (listLeaguesBtn) listLeaguesBtn.addEventListener('click', listLeaguesRegistry);

            const clearRegistryBtn = document.getElementById('clear-registry-btn');
            if (clearRegistryBtn) {
                clearRegistryBtn.addEventListener('click', async () => {
                    if (!confirm("‚ö†Ô∏è ATTENZIONE SOCIO!\n\nVuoi davvero SVUOTARE COMPLETAMENTE il Registry?\nQuesta operazione non pu√≤ essere annullata. Dovrai re-importare il file JSON pulito.")) return;

                    try {
                        const transaction = window.LocalDB.db.transaction(['leagues_registry'], 'readwrite');
                        const store = transaction.objectStore('leagues_registry');
                        const request = store.clear();
                        request.onsuccess = () => {
                            alert("‚úÖ Registry svuotato con successo!");
                            if (typeof initRegistryStatus === 'function') initRegistryStatus();
                            const totalLeaguesCountEl = document.getElementById('total-leagues-registry-count');
                            if (totalLeaguesCountEl) totalLeaguesCountEl.textContent = '0';
                            document.getElementById('leagues-list-body').innerHTML = '';
                        };
                    } catch (e) {
                        alert("‚ùå Errore durante lo svuotamento: " + e.message);
                    }
                });
            }

            if (closeLeaguesListBtn) closeLeaguesListBtn.addEventListener('click', () => leaguesListModal.classList.add('hidden'));
            if (leagueListSearch) leagueListSearch.addEventListener('input', async (e) => {
                const registry = await window.LocalDB.getAllLeagues();
                renderLeaguesList(registry, e.target.value);
            });

            const exportRegistryBtn = document.getElementById('export-registry-btn');
            if (exportRegistryBtn) exportRegistryBtn.addEventListener('click', exportRegistryJSON);

            const associateBtn = document.getElementById('associate-all-leagues-btn');
            if (associateBtn) associateBtn.addEventListener('click', associateAllLeagues);

            const saveAssocBtn = document.getElementById('save-associations-btn');
            if (saveAssocBtn) saveAssocBtn.addEventListener('click', saveAllAssociations);

            // --- Registry Import ---
            const importRegistryBtn = document.getElementById('import-registry-btn');
            const importRegistryInput = document.getElementById('import-registry-input');
            if (importRegistryBtn) importRegistryBtn.onclick = () => importRegistryInput.click();
            if (importRegistryInput) importRegistryInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (!Array.isArray(data)) throw new Error("Formato non valido: atteso un array JSON.");
                        const ok = confirm(`Importare ${data.length} mappature nel database locale?`);
                        if (!ok) return;
                        const mappings = data.map(m => ({
                            ...m,
                            label: m.name || m.label,
                            id: m.leagueId || m.id,
                            // üî• NEW v12.0: Preserve intelligence fields
                            trustScore: m.trustScore !== undefined ? m.trustScore : 5.0,
                            mode: m.mode || 'STANDARD',
                            samples: m.samples || 0,
                            o15_wr: m.o15_wr || '0.0',
                            trading: m.trading || false, // ‚úÖ Preserve Trading Flag
                            meta: {
                                apiName: m.apiName || 'Imported',
                                country: m.country || '-',
                                source: 'master-trust-v12'
                            }
                        }));
                        await window.LocalDB.saveLeagueMappingsBulk(mappings);
                        alert(`‚úÖ Importate ${data.length} leghe con successo!`);
                        if (typeof initRegistryStatus === 'function') initRegistryStatus();
                    } catch (err) {
                        alert("Errore caricamento: " + err.message);
                    }
                };
                reader.readAsText(file);
            };

            // --- Team Discovery Function ---
            window.discoverByTeam = async function (leagueLabel, btn) {
                const oldText = btn.textContent;
                btn.disabled = true;
                btn.textContent = "‚è≥...";
                try {
                    const matches = await window.LocalDB.getAllMatches();
                    const sampleMatch = matches.find(m => m.lega === leagueLabel);
                    if (!sampleMatch) throw new Error("Nessun match trovato nello storico per questa lega.");

                    if (typeof window.getFootballData !== 'function') return;
                    const result = await window.getFootballData({
                        endpoint: 'teams',
                        params: { name: teamName }
                    });
                    const data = result.data;
                    if (!data.response || data.response.length === 0) throw new Error(`Squadra "${teamName}" non trovata API.`);

                    const teamId = data.response[0].team.id;
                    if (typeof window.getFootballData !== 'function') return;
                    const leaguesRes = await window.getFootballData({
                        endpoint: 'leagues',
                        params: { team: teamId, current: 'true' }
                    });
                    const leaguesData = leaguesRes.data;
                    if (!leaguesData.response || leaguesData.response.length === 0) throw new Error("Nessuna lega trovata per questa squadra.");

                    const options = leaguesData.response.map(r => `${r.league.name} (${r.country.name}) - ID: ${r.league.id}`).join('\n');
                    const choice = prompt(`üîç Discovery per "${leagueLabel}"\nSquadra trovata: ${data.response[0].team.name}\n\nLeghe possibili:\n${options}\n\nCopia qui l'ID della lega corretta:`, leaguesData.response[0].league.id);

                    if (choice) {
                        const idx = btn.nextElementSibling.id.split('-').pop();
                        const input = document.getElementById(`notfound-id-${idx}`);
                        if (input) {
                            input.value = choice;
                            btn.textContent = "‚úÖ";
                            btn.className = "bg-green-600 text-white px-2 py-1 rounded text-[10px] font-bold";
                        }
                    } else {
                        btn.textContent = oldText;
                        btn.disabled = false;
                    }
                } catch (err) {
                    alert("Errore: " + err.message);
                    btn.textContent = oldText;
                    btn.disabled = false;
                }
            };

            // Init registry status
            setTimeout(initRegistryStatus, 600);

        }); // Close DOMContentLoaded

        // ==================== AI KNOWLEDGE BASE UPLOAD ====================
        const uploadAiBtn = document.getElementById('upload-ai-knowledge-btn');

        // Populate Custom Strategies Dropdown
        async function populateAiStrategySelect() {
            const selectGroup = document.getElementById('ai-custom-strats-group');
            if (!selectGroup) return;

            selectGroup.innerHTML = ''; // Clear

            try {
                // Use savedFilters loaded from Firestore (via loadSavedFilters)
                // Ensure savedFilters is populated (it is loaded in init)
                if (typeof savedFilters !== 'undefined' && savedFilters.length > 0) {
                    savedFilters.forEach(strat => {
                        const option = document.createElement('option');
                        option.value = strat.id; // e.g. "magic_ai_123"
                        option.textContent = strat.name;
                        selectGroup.appendChild(option);
                    });
                }
            } catch (e) {
                console.warn("Error populating AI dropdown:", e);
            }
        }

        // Call it after init
        setTimeout(populateAiStrategySelect, 2000); // Wait for loadSavedFilters

        if (uploadAiBtn) {
            uploadAiBtn.addEventListener('click', async () => {
                const stratId = document.getElementById('ai-strat-id').value; // Value from SELECT
                const desc = document.getElementById('ai-strat-desc').value.trim();
                const fileInput = document.getElementById('ai-csv-file');
                const statusEl = document.getElementById('ai-upload-status');

                if (!stratId) {
                    alert("Inserisci un ID Strategia (es. top_eu)");
                    return;
                }

                statusEl.textContent = "Elaborazione in corso...";
                statusEl.className = "text-sm text-blue-600 block mt-2";
                statusEl.classList.remove('hidden');

                let uniqueLeagues = [];

                // Helper to save to Firestore
                const saveToFirestore = async (leagues) => {
                    try {
                        const docRef = doc(db, "strategies_metadata", "definitions");
                        const updateData = {};
                        updateData[stratId] = {
                            name: stratId,
                            description: desc,
                            leagues: leagues,
                            lastUpdated: new Date().toISOString()
                        };

                        await setDoc(docRef, updateData, { merge: true });

                        statusEl.innerHTML = `<i class="fa-solid fa-check-circle text-green-500"></i> Salvato con successo! (${leagues.length} leghe)`;
                        statusEl.className = "text-sm text-green-600 block mt-2";
                    } catch (e) {
                        console.error("Error saving AI knowledge:", e);
                        statusEl.textContent = "Errore salvataggio: " + e.message;
                        statusEl.className = "text-sm text-red-600 block mt-2";
                    }
                };

                if (fileInput.files.length > 0) {
                    Papa.parse(fileInput.files[0], {
                        header: true,
                        skipEmptyLines: true,
                        complete: function (results) {
                            const leagues = new Set();
                            results.data.forEach(row => {
                                if (row.lega) {
                                    // Clean league name (remove EU-, AS-, etc.)
                                    const cleanLega = (row.lega || "").replace(/^(EU-|AS-|AF-|NA-|SA-)/i, '').trim();
                                    leagues.add(cleanLega);
                                }
                            });
                            uniqueLeagues = Array.from(leagues).sort();
                            saveToFirestore(uniqueLeagues);
                        },
                        error: function (err) {
                            statusEl.textContent = "Errore CSV: " + err.message;
                            statusEl.className = "text-sm text-red-600 block mt-2";
                        }
                    });
                } else {
                    // Save without leagues (just description update)
                    saveToFirestore([]);
                }
            });
        }

        // ==================== TRADING SPORTIVO ALGORITHMS ====================

        // Helper: Normalizza la Tip per evitare problemi di formato
        function normalizeTip(tip) {
            if (!tip) return '';
            let normalized = tip.toLowerCase().replace(',', '.').trim();
            if (normalized.startsWith('+')) normalized = 'over ' + normalized.substring(1);
            if (normalized.startsWith('-')) normalized = 'under ' + normalized.substring(1);
            return normalized;
        }

        // Helper: Safe Float Parse
        function safeParseFloat(value) {
            if (!value) return 0;
            if (typeof value === 'number') return value;
            return parseFloat(value.toString().replace(',', '.'));
        }

        // 1. STRATEGIA LAY THE DRAW - DISABILITATA (mancanza quote 1-X-2 reali)
        function checkLTD(match) {
            return false;
        }

        // 2. STRATEGIA OVER 2.5 POISSON (con BONUS 0.5HT)
        function checkOver25(match) {
            const tip = normalizeTip(match.tip);
            if (!tip.includes('over 1.5') && !tip.includes('over 2.5')) return false;

            const quota = safeParseFloat(match.quota);
            const prob = safeParseFloat(match.probabilita);

            // Fallback se manca Poisson
            if (typeof window.calculatePoissonOdds !== 'function') {
                let risk = prob >= 75 ? 'low' : (prob >= 65 ? 'medium' : 'high');
                return { type: 'Over2.5', prob: prob, valore: quota, risk: risk };
            }

            // Calcolo Poisson
            let poissonCode = '+1.5';
            if (tip.includes('2.5')) poissonCode = '+2.5';

            const stats = window.calculatePoissonOdds(poissonCode, quota, prob, '+2.5');
            if (!stats) return { type: 'Over2.5', prob: prob, valore: quota, risk: 'high' };

            // BONUS 0.5HT: Quota bassa = alta probabilit√† gol primo tempo
            let htBonus = 0;
            const quota05HT = safeParseFloat(match.quota_05ht);
            if (quota05HT > 0 && quota05HT < 1.30) {
                htBonus = Math.min((1.30 - quota05HT) * 20, 10); // Max +10%
                console.log(`[Over 2.5] BONUS 0.5HT per ${match.partita}: +${htBonus.toFixed(1)}% (quota_05ht=${quota05HT})`);
            }

            const finalProb = Math.min(stats.prob + htBonus, 95);

            // Risk assessment
            let risk = 'medium';
            if (finalProb >= 60) risk = 'low';
            else if (finalProb < 45) risk = 'high';

            return { type: 'Over2.5', prob: finalProb, valore: stats.odds, risk: risk };
        }

        // 3. STRATEGIA UNDER 3.5 SAFETY
        function checkUnder35(match) {
            const tip = normalizeTip(match.tip);
            let confidence = 0;
            let risk = 'medium';

            if (tip.includes('under 3.5')) {
                confidence = 79;
                const prob = safeParseFloat(match.probabilita);
                risk = prob >= 75 ? 'low' : (prob >= 65 ? 'medium' : 'high');
                return { type: 'Under3.5', confidence: confidence, risk: risk };
            }
            if (tip.includes('under 2.5')) {
                confidence = 82;
                const prob = safeParseFloat(match.probabilita);
                risk = prob >= 80 ? 'low' : (prob >= 70 ? 'medium' : 'high');
                return { type: 'Under3.5', confidence: confidence, risk: risk };
            }
            return false;
        }


        // EVENT LISTENER - GENERA TRADING SPORTIVO PICKS
        const generateTradingPicksBtn = document.getElementById('generate-trading-picks-btn');
        if (generateTradingPicksBtn) {
            generateTradingPicksBtn.addEventListener('click', async () => {
                console.log('üñ±Ô∏è Button Clicked. Checking function...');

                // Get selected date from picker
                const selectedDate = document.getElementById('pronostici-unified-date')?.value || new Date().toISOString().split('T')[0];
                console.log('[Trading] Selected date:', selectedDate);

                try {
                    const btn = generateTradingPicksBtn;
                    const originalText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Elaborazione...';

                    // STEP 1: Check if trading picks already exist for this date
                    const existingDoc = await getDoc(doc(db, "daily_trading_picks", selectedDate));

                    if (existingDoc.exists()) {
                        // Picks exist - UPDATE OUTCOMES instead of regenerating
                        console.log('[Trading] Picks gi√† esistenti per', selectedDate, '- aggiorno esiti...');

                        const tradingData = existingDoc.data();
                        const picks = tradingData.picks || [];

                        // Get matches for this date from DB to find results
                        const matchesRef = collection(db, "matches");
                        const q = query(matchesRef, where("data", "==", selectedDate));
                        const matchesSnapshot = await getDocs(q);
                        const matchesWithResults = [];
                        matchesSnapshot.forEach(doc => matchesWithResults.push(doc.data()));

                        console.log('[Trading] Partite con risultato trovate:', matchesWithResults.filter(m => m.risultato).length);

                        // Helper function: calculate trading outcome
                        const calculateTradingOutcome = (pick, risultato) => {
                            if (!risultato || risultato.trim() === '') return null;

                            const parts = risultato.split('-').map(g => parseInt(g.trim()));
                            if (parts.length !== 2 || isNaN(parts[0]) || isNaN(parts[1])) return null;

                            const [golCasa, golTrasferta] = parts;
                            const golTotali = golCasa + golTrasferta;
                            const isPareggio = golCasa === golTrasferta;

                            if (pick.strategy === 'BACK_OVER_25') {
                                if (golTotali <= 1) return { esito: 'Stop-loss', color: 'red' };
                                if (golTotali === 2) return { esito: 'Cash-out', color: 'yellow' };
                                return { esito: 'Vinta', color: 'green' };
                            }

                            if (pick.strategy === 'LAY_THE_DRAW') {
                                if (risultato === '0-0') return { esito: 'Stop-loss', color: 'red' };
                                if (isPareggio && golTotali > 0) return { esito: 'Cash-out', color: 'yellow' };
                                return { esito: 'Vinta', color: 'green' };
                            }

                            return null;
                        };

                        // Update outcomes
                        let updatedCount = 0;
                        picks.forEach(pick => {
                            const matchResult = matchesWithResults.find(m => m.fixtureId === pick.fixtureId);

                            if (matchResult && matchResult.risultato) {
                                const outcome = calculateTradingOutcome(pick, matchResult.risultato);
                                if (outcome) {
                                    pick.esito = outcome.esito;
                                    pick.esitoColor = outcome.color;
                                    pick.risultato = matchResult.risultato;
                                    updatedCount++;
                                    console.log(`[Trading] ‚úÖ Updated (ID: ${pick.fixtureId}): ${pick.partita} ‚Üí ${matchResult.risultato} ‚Üí ${outcome.esito}`);
                                }
                            } else {
                                console.log(`[Trading] ‚ö†Ô∏è No result for (ID: ${pick.fixtureId}): ${pick.partita}`);
                            }
                        });

                        // Save updated picks
                        if (updatedCount > 0) {
                            await setDoc(doc(db, "daily_trading_picks", selectedDate), {
                                ...tradingData,
                                picks: picks,
                                lastOutcomeUpdate: new Date().toISOString()
                            });
                            alert(`‚úÖ Esiti aggiornati per ${updatedCount}/${picks.length} trading picks del ${selectedDate}`);
                        } else {
                            alert(`‚ö†Ô∏è Nessun esito aggiornato.\n\n${picks.length} picks senza risultato per ${selectedDate}.\n\nAssicurati di aver caricato i risultati prima!`);
                        }

                        btn.disabled = false;
                        btn.innerHTML = originalText;
                        return;
                    }

                    // Picks DON'T exist - GENERATE NEW
                    console.log('[Trading] Nessuna pick esistente, genero nuovo...');

                    if (typeof window.selectTopTradingSportivoPicks !== 'function') {
                        alert('‚ùå Errore: Algoritmi Trading Sportivo non caricati. Ricarica la pagina.');
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                        return;
                    }

                    // Load blacklist first
                    let tradingBlacklist = [];
                    try {
                        const blDoc = await getDoc(doc(db, "system", "blacklisted_leagues"));
                        if (blDoc.exists()) {
                            tradingBlacklist = blDoc.data().leagues || [];
                            console.log(`[Trading] Loaded ${tradingBlacklist.length} blacklisted leagues`);
                        }
                    } catch (e) {
                        console.warn('[Trading] Could not fetch blacklist:', e);
                    }

                    // Filter matches by date AND exclude blacklisted leagues
                    let matchesToProcess = window.allMatches?.filter(m => m.data === selectedDate) || [];
                    if (tradingBlacklist.length > 0) {
                        const beforeCount = matchesToProcess.length;
                        matchesToProcess = matchesToProcess.filter(m => !tradingBlacklist.includes(m.lega));
                        console.log(`[Trading] Filtered blacklist: ${beforeCount} -> ${matchesToProcess.length} (${beforeCount - matchesToProcess.length} removed)`);
                    }
                    console.log('[Trading Sportivo] Generazione da', matchesToProcess.length, 'matches per', selectedDate);

                    if (matchesToProcess.length === 0) {
                        alert(`‚ö†Ô∏è Nessuna partita trovata per ${selectedDate}.\n\nCarica prima le tip per questa data!`);
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                        return;
                    }

                    const tradingPicks = window.selectTopTradingSportivoPicks(matchesToProcess);

                    if (tradingPicks.length === 0) {
                        alert('‚ùå Nessuna partita trovata con i criteri trading!\n\nVerifica:\n- Over 1.5 con quota <1.25 + prob >80%\n- Over 2.5 con prob >65%\n- 1X2 con prob >75% + pareggi <25%');
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                        return;
                    }

                    // Salva su Firestore
                    await setDoc(doc(db, "daily_trading_picks", selectedDate), {
                        picks: tradingPicks,
                        generated: new Date().toISOString(),
                        count: tradingPicks.length
                    });

                    console.log(`[Trading Sportivo] ${tradingPicks.length} picks salvate per ${selectedDate}`);
                    alert(`‚úÖ ${tradingPicks.length} Trading Picks generate per ${selectedDate}!`);

                    // VISUAL IZZA NELLA UI
                    const container = document.getElementById('trading-picks-container');
                    if (container) {
                        container.innerHTML = '';
                        container.classList.remove('hidden');

                        // Header
                        const header = document.createElement('div');
                        header.className = 'text-center font-bold text-green-600 mb-4 text-xl';
                        header.textContent = `‚úÖ ${tradingPicks.length} Trading Sportivo Picks generate per ${today}`;
                        container.appendChild(header);

                        // Cards - COMPACT VERSION
                        tradingPicks.forEach((p, i) => {
                            const card = document.createElement('div');
                            card.className = 'bg-white p-3 rounded-lg border border-purple-300 shadow-sm hover:shadow-md transition-shadow';

                            // Liquidity color
                            const liquidityColor = p.liquidityLevel === 'Alta' ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700';

                            card.innerHTML = `
                                <div class="flex justify-between items-start gap-2 mb-2">
                                    <div class="flex-1 min-w-0">
                                        <div class="text-xs text-gray-500 font-medium truncate">${p.lega}</div>
                                        <div class="text-base font-bold text-gray-900 mt-0.5 leading-tight">${p.partita}</div>
                                        <div class="text-xs text-gray-400 mt-0.5">${p.data}${p.ora ? ' ‚Ä¢ ' + p.ora : ''}</div>
                                    </div>
                                    <div class="text-right flex-shrink-0">
                                        <div class="text-xl font-bold text-purple-600">${p.confidence || p.score}</div>
                                        <div class="text-xs text-gray-500">Confidence</div>
                                    </div>
                                </div>

                                ${p.tradingBadge ? `
                                    <div class="px-2 py-1.5 rounded ${p.tradingBadge.color} text-xs font-bold text-center mb-2">
                                        üéØ ${p.tradingBadge.text}
                                    </div>
                                ` : ''}
                                
                                <div class="bg-gradient-to-r from-blue-50 to-purple-50 p-3 rounded-lg mb-2 border border-blue-200">
                                    <div class="text-xs font-bold text-blue-900 mb-2">üìã Istruzioni Trading</div>
                                    <div class="space-y-1.5 text-xs">
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">Azione:</span>
                                            <span class="font-bold text-gray-900">${p.tradingInstruction?.action || p.tip}</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">Range Ingresso:</span>
                                            <span class="font-bold text-green-700">${p.tradingInstruction?.entryRange ? p.tradingInstruction.entryRange.join(' - ') : p.quota}</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">Target Uscita:</span>
                                            <span class="font-bold text-orange-700">${p.tradingInstruction?.exitTarget || 'Live'}</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-600">Timing:</span>
                                            <span class="font-bold text-purple-700">${p.tradingInstruction?.timing || 'Pre-match'}</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="grid grid-cols-2 gap-1.5 text-xs mb-2">
                                    <div class="${liquidityColor} px-2 py-1.5 rounded">
                                        <div class="text-xs opacity-75 leading-tight">Liquidit√†</div>
                                        <div class="font-bold text-sm">${p.liquidityLevel}</div>
                                    </div>
                                    <div class="bg-gray-50 px-2 py-1.5 rounded">
                                        <div class="text-gray-500 text-xs leading-tight">Strategia</div>
                                        <div class="font-bold text-sm">${p.strategy || 'Standard'}</div>
                                    </div>
                                </div>

                                <div class="bg-blue-50 px-2 py-1.5 rounded border border-blue-200">
                                    <div class="text-xs text-blue-700 font-semibold">${p.reasoning || p.whyTradable}</div>
                                </div>
                            `;

                            container.appendChild(card);
                        });
                    }

                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Picks Salvate!';
                    btn.classList.remove('bg-purple-600');
                    btn.classList.add('bg-green-600');

                    setTimeout(() => {
                        btn.innerHTML = '<i class="fa-solid fa-chart-line mr-2"></i>Genera Trading Sportivo Picks';
                        btn.classList.remove('bg-green-600');
                        btn.classList.add('bg-purple-600');
                    }, 3000);

                } catch (e) {
                    console.error('[Trading Sportivo] Error:', e);
                    alert('‚ùå Errore durante la generazione: ' + e.message);
                    const btn = generateTradingPicksBtn;
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-chart-line mr-2"></i>Genera Trading Sportivo Picks';
                }
            });
        }

        // ==================== TRADING STRATEGY ASSIGNMENT FUNCTIONS ====================

        /**
         * Get default trading parameters for each strategy type
         */
        function getTradingDefaults(strategyType) {
            const defaults = {
                'BACK_OVER_25': {
                    label: 'Back Over 2.5',
                    entry: { range: [2.10, 2.40], timing: '0-20min' },
                    exit: { target: 1.70, timing: 'After 1st goal or 60min' },
                    stopLoss: { trigger: 3.00, timing: '75min+ if 0 goals' }
                },
                'BACK_OVER_25_2H': {
                    label: 'Back Over 2.5 (2¬∞ Tempo)',
                    entry: { range: [1.90, 2.20], timing: '0-25min' },
                    exit: { target: 1.60, timing: 'After 1st goal (2H)' },
                    stopLoss: { trigger: 2.80, timing: '70min+ if 0 goals 2H' }
                },
                'HT_SNIPER': {
                    label: 'HT Sniper (Gol 1T)',
                    entry: { range: [1.70, 2.00], timing: '0-15min' },
                    exit: { target: 1.40, timing: 'After HT goal or HT whistle' },
                    stopLoss: { trigger: 2.50, timing: '35min+ if 0 goals' }
                },
                'LAY_THE_DRAW': {
                    label: 'Lay The Draw',
                    entry: { range: [3.20, 4.00], timing: '0-15min or after goal' },
                    exit: { target: 2.20, timing: 'After any goal' },
                    stopLoss: { trigger: 5.00, timing: '80min+ if still draw' }
                },
                'SCALPING_OVER_15': {
                    label: 'Scalping Over 1.5',
                    entry: { range: [1.40, 1.60], timing: '0-20min' },
                    exit: { target: 1.20, timing: 'After 1st goal' },
                    stopLoss: { trigger: 2.00, timing: '60min+ if 0 goals' }
                }
            };
            return defaults[strategyType] || defaults['BACK_OVER_25'];
        }

        /**
         * Show/hide manual trading form
         */
        window.showManualTradingForm = function (matchUUID) {
            const form = document.getElementById(`manual-form-${matchUUID}`);
            if (form) {
                form.classList.toggle('hidden');
            }
        };

        /**
         * Select a strategy card (visual selection + update hidden input)
         */
        window.selectStrategyCard = function (matchUUID, strategyType, cardElement) {
            // Update hidden input
            const typeInput = document.getElementById(`trading-type-${matchUUID}`);
            if (typeInput) {
                typeInput.value = strategyType;
            }

            // Visual feedback - remove highlight from all cards in this section
            const section = document.getElementById(`trading-section-${matchUUID}`);
            if (section) {
                section.querySelectorAll('.strategy-card').forEach(card => {
                    card.classList.remove('border-blue-500', 'bg-blue-100', 'border-purple-500', 'bg-purple-100', 'border-green-500', 'bg-green-100', 'border-orange-500', 'bg-orange-100', 'border-amber-500', 'bg-amber-100');
                    card.classList.add('border-gray-100');
                });
            }

            // Highlight clicked card
            if (cardElement) {
                cardElement.classList.remove('border-gray-100');
                cardElement.classList.add('border-blue-500', 'bg-blue-100');
            }

            console.log(`[Trading] Selected ${strategyType} for ${matchUUID}`);
        };

        /**
         * Select a trading option from the strategy cards (Legacy)
         */
        window.selectTradingOption = function (matchUUID, strategyType) {
            // Update hidden input
            const typeInput = document.getElementById(`trading-type-${matchUUID}`);
            if (typeInput) {
                typeInput.value = strategyType;
            }

            // Visual feedback - highlight selected card
            const section = document.getElementById(`trading-section-${matchUUID}`);
            if (section) {
                // Remove highlight from all cards
                section.querySelectorAll('.p-2.rounded.border-2').forEach(card => {
                    card.classList.remove('border-purple-500', 'bg-purple-50');
                    card.classList.add('border-gray-200');
                });

                // Highlight clicked card
                event.currentTarget.classList.remove('border-gray-200');
                event.currentTarget.classList.add('border-purple-500', 'bg-purple-50');
            }

            console.log(`[Trading] Selected ${strategyType} for ${matchUUID}`);
        };

        /**
         * Confirm AI-calculated trading strategy (one-click)
         */
        window.confirmAITradingStrategy = async function (matchUUID, partita, data) {
            const pending = window.pendingTradingStrategies?.[matchUUID];
            if (!pending || !pending.strategy) {
                alert('‚ö†Ô∏è Nessuna strategia AI da confermare!');
                return;
            }

            const aiStrategy = pending.strategy;
            const match = pending.match;

            // Convert AI strategy format to storage format
            const tradingStrategy = {
                type: aiStrategy.strategy || 'UNKNOWN',
                label: aiStrategy.label || aiStrategy.tradingInstruction?.action || aiStrategy.strategy,
                confidence: aiStrategy.confidence || 70,
                entry: {
                    range: aiStrategy.tradingInstruction?.entryRange?.map(parseFloat) || [2.10, 2.40],
                    timing: aiStrategy.tradingInstruction?.timing || '0-20min'
                },
                exit: {
                    target: parseFloat(aiStrategy.tradingInstruction?.exitTarget) || 1.70,
                    timing: 'After key event'
                },
                stopLoss: {
                    trigger: 0,
                    timing: '75min+'
                },
                reasoning: aiStrategy.reasoning || 'AI Monte Carlo + Storico',
                assignedAt: new Date().toISOString(),
                aiGenerated: true,  // Flag to track AI-generated strategies
                alerts: {
                    entry: true,
                    cashOut: true,
                    hold: true,
                    stopLoss: true
                }
            };

            try {
                // Save to Firestore (same logic as assignTradingToMatch)
                const strategyRef = doc(db, "daily_strategies", "Top Live");
                const strategySnap = await getDoc(strategyRef);

                if (strategySnap.exists()) {
                    const data_snap = strategySnap.data();
                    let matches = data_snap.matches || [];

                    const existingIdx = matches.findIndex(m => m.partita === partita && m.data === data);
                    if (existingIdx !== -1) {
                        matches[existingIdx].hasTradingStrategy = true;
                        matches[existingIdx].tradingStrategy = tradingStrategy;
                    } else {
                        matches.push({
                            ...match,
                            hasTradingStrategy: true,
                            tradingStrategy: tradingStrategy
                        });
                    }

                    await updateDoc(strategyRef, { matches: matches, lastUpdated: new Date().toISOString() });
                } else {
                    await setDoc(strategyRef, {
                        name: "Top Live",
                        description: "Partite con trading strategy attivo",
                        matches: [{
                            ...match,
                            hasTradingStrategy: true,
                            tradingStrategy: tradingStrategy
                        }],
                        createdAt: new Date().toISOString()
                    });
                }

                // Update live_scores_hub
                const hubKey = partita.toLowerCase().replace(/[^a-z0-9]/g, '');
                const hubRef = doc(db, "live_scores_hub", hubKey);
                await setDoc(hubRef, {
                    hasTradingStrategy: true,
                    tradingStrategy: tradingStrategy
                }, { merge: true });

                // Update UI
                const section = document.getElementById(`trading-section-${matchUUID}`);
                if (section) {
                    section.classList.remove('bg-purple-50', 'border-purple-300', 'bg-gray-50', 'border-gray-200');
                    section.classList.add('bg-green-50', 'border-green-300');
                    section.innerHTML = `
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-2">
                                <span class="text-green-600 font-bold text-sm">‚úÖ TRADING ATTIVO (AI)</span>
                                <span class="bg-green-600 text-white px-2 py-0.5 rounded text-xs font-bold">${tradingStrategy.label}</span>
                            </div>
                            <button onclick="removeTradingFromMatch('${matchUUID}', '${partita.replace(/'/g, "\\'")}', '${data}')" class="text-red-500 hover:text-red-700 text-xs font-bold">
                                <i class="fa-solid fa-trash"></i> Rimuovi
                            </button>
                        </div>
                        <div class="text-xs text-gray-600 grid grid-cols-3 gap-2">
                            <div><span class="font-bold">Entry:</span> @${tradingStrategy.entry.range.join('-')}</div>
                            <div><span class="font-bold">Exit:</span> @${tradingStrategy.exit.target}</div>
                            <div><span class="font-bold">Conf:</span> ${tradingStrategy.confidence}%</div>
                        </div>
                    `;
                }

                // Remove from pending
                delete window.pendingTradingStrategies[matchUUID];

                console.log(`[Trading AI] ‚úÖ Confirmed ${tradingStrategy.type} for ${partita}`);

            } catch (error) {
                console.error('[Trading AI] Error confirming strategy:', error);
                alert('‚ùå Errore: ' + error.message);
            }
        };

        /**
         * Confirm ALL pending AI strategies at once
         */
        window.confirmAllAIStrategies = async function () {
            const pending = window.pendingTradingStrategies || {};
            const keys = Object.keys(pending);

            if (keys.length === 0) {
                alert('‚ö†Ô∏è Nessuna strategia AI da confermare!');
                return;
            }

            if (!confirm(`Confermare ${keys.length} strategie AI Trading?`)) return;

            let confirmed = 0;
            let errors = 0;

            for (const matchUUID of keys) {
                const p = pending[matchUUID];
                try {
                    await window.confirmAITradingStrategy(matchUUID, p.match.partita, p.match.data);
                    confirmed++;
                } catch (e) {
                    console.error(`[Trading AI Bulk] Error for ${p.match.partita}:`, e);
                    errors++;
                }
            }

            alert(`‚úÖ Confermate ${confirmed} strategie AI${errors > 0 ? ` (${errors} errori)` : ''}`);
        };

        /**
         * Assign trading strategy to a match
         */
        window.assignTradingToMatch = async function (matchUUID, partita, data, originalTip) {
            const typeSelect = document.getElementById(`trading-type-${matchUUID}`);
            const confInput = document.getElementById(`trading-conf-${matchUUID}`);

            if (!typeSelect || !typeSelect.value) {
                alert('‚ö†Ô∏è Seleziona una strategia trading!');
                return;
            }

            const strategyType = typeSelect.value;
            const confidence = confInput ? (parseInt(confInput.value) || 75) : 75; // Safe fallback
            const defaults = getTradingDefaults(strategyType);

            const tradingStrategy = {
                type: strategyType,
                label: defaults.label,
                confidence: confidence,
                entry: defaults.entry,
                exit: defaults.exit,
                stopLoss: defaults.stopLoss,
                reasoning: `Assegnata manualmente - ${originalTip} originale`,
                assignedAt: new Date().toISOString(),
                alerts: {
                    entry: true,
                    cashOut: true,
                    hold: true,
                    stopLoss: true
                }
            };

            try {
                // Find the match in allMatches and update it
                const matchIndex = window.allMatches?.findIndex(m => m.partita === partita && m.data === data);
                if (matchIndex !== -1) {
                    window.allMatches[matchIndex].hasTradingStrategy = true;
                    window.allMatches[matchIndex].tradingStrategy = tradingStrategy;
                }

                // Save to daily_strategies/Top Live document (or create if not exists)
                const strategyRef = doc(db, "daily_strategies", "Top Live");
                const strategySnap = await getDoc(strategyRef);

                if (strategySnap.exists()) {
                    // Update existing matches array
                    const data_snap = strategySnap.data();
                    let matches = data_snap.matches || [];

                    // Find and update the match
                    const existingIdx = matches.findIndex(m => m.partita === partita && m.data === data);
                    if (existingIdx !== -1) {
                        matches[existingIdx].hasTradingStrategy = true;
                        matches[existingIdx].tradingStrategy = tradingStrategy;
                    } else {
                        // Add new match with trading
                        matches.push({
                            partita: partita,
                            data: data,
                            tip: originalTip,
                            fixtureId: window.allMatches[matchIndex]?.fixtureId || null,
                            hasTradingStrategy: true,
                            tradingStrategy: tradingStrategy
                        });
                    }

                    await updateDoc(strategyRef, { matches: matches, lastUpdated: new Date().toISOString() });
                } else {
                    // Create new Top Live strategy
                    await setDoc(strategyRef, {
                        name: "Top Live",
                        description: "Partite con trading strategy attivo",
                        matches: [{
                            partita: partita,
                            data: data,
                            tip: originalTip,
                            fixtureId: window.allMatches[matchIndex]?.fixtureId || null,
                            hasTradingStrategy: true,
                            tradingStrategy: tradingStrategy
                        }],
                        createdAt: new Date().toISOString()
                    });
                }

                // Also save to live_scores_hub for app sync
                const hubKey = partita.toLowerCase().replace(/[^a-z0-9]/g, '');
                const hubRef = doc(db, "live_scores_hub", hubKey);
                await setDoc(hubRef, {
                    hasTradingStrategy: true,
                    tradingStrategy: tradingStrategy
                }, { merge: true });

                // Update UI
                const section = document.getElementById(`trading-section-${matchUUID}`);
                if (section) {
                    section.classList.remove('bg-blue-50', 'border-blue-200');
                    section.classList.add('bg-green-50', 'border-green-300');
                    section.innerHTML = `
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-2">
                                <span class="text-green-600 font-bold text-sm">‚úÖ TRADING ATTIVO</span>
                                <span class="bg-green-600 text-white px-2 py-0.5 rounded text-xs font-bold">${defaults.label}</span>
                            </div>
                            <button onclick="removeTradingFromMatch('${matchUUID}', '${partita.replace(/'/g, "\\'")}', '${data}')" class="text-red-500 hover:text-red-700 text-xs font-bold">
                                <i class="fa-solid fa-trash"></i> Rimuovi
                            </button>
                        </div>
                        <div class="text-xs text-gray-600 grid grid-cols-3 gap-2">
                            <div><span class="font-bold">Entry:</span> @${defaults.entry.range.join('-')}</div>
                            <div><span class="font-bold">Exit:</span> @${defaults.exit.target}</div>
                            <div><span class="font-bold">Conf:</span> ${confidence}%</div>
                        </div>
                    `;
                }

                console.log(`[Trading] ‚úÖ Assigned ${strategyType} to ${partita}`);

            } catch (error) {
                console.error('[Trading] Error assigning strategy:', error);
                alert('‚ùå Errore: ' + error.message);
            }
        };

        /**
         * Remove trading strategy from a match
         */
        window.removeTradingFromMatch = async function (matchUUID, partita, data) {
            if (!confirm(`Rimuovere la trading strategy da "${partita}"?`)) return;

            try {
                // Update allMatches
                const matchIndex = window.allMatches?.findIndex(m => m.partita === partita && m.data === data);
                if (matchIndex !== -1) {
                    window.allMatches[matchIndex].hasTradingStrategy = false;
                    delete window.allMatches[matchIndex].tradingStrategy;
                }

                // Update daily_strategies/Top Live
                const strategyRef = doc(db, "daily_strategies", "Top Live");
                const strategySnap = await getDoc(strategyRef);

                if (strategySnap.exists()) {
                    let matches = strategySnap.data().matches || [];
                    const existingIdx = matches.findIndex(m => m.partita === partita && m.data === data);
                    if (existingIdx !== -1) {
                        matches[existingIdx].hasTradingStrategy = false;
                        delete matches[existingIdx].tradingStrategy;
                        await updateDoc(strategyRef, { matches: matches, lastUpdated: new Date().toISOString() });
                    }
                }

                // Update live_scores_hub
                const hubKey = partita.toLowerCase().replace(/[^a-z0-9]/g, '');
                const hubRef = doc(db, "live_scores_hub", hubKey);
                await updateDoc(hubRef, {
                    hasTradingStrategy: false,
                    tradingStrategy: deleteField()
                });

                // Refresh UI - show form again
                const section = document.getElementById(`trading-section-${matchUUID}`);
                if (section) {
                    section.classList.remove('bg-green-50', 'border-green-300');
                    section.classList.add('bg-blue-50', 'border-blue-200');
                    section.innerHTML = `
                        <div class="flex items-center gap-2 mb-2">
                            <i class="fa-solid fa-chart-line text-blue-600"></i>
                            <span class="text-blue-800 font-bold text-sm">Assegna Strategia Trading</span>
                        </div>
                        <div class="grid grid-cols-2 gap-2 mb-2">
                            <select id="trading-type-${matchUUID}" class="text-xs p-1.5 border rounded w-full">
                                <option value="">-- Seleziona --</option>
                                <option value="BACK_OVER_25">Back Over 2.5</option>
                                <option value="BACK_OVER_25_2H">Back Over 2.5 (2¬∞ Tempo)</option>
                                <option value="HT_SNIPER">HT Sniper (Gol 1T)</option>
                                <option value="LAY_THE_DRAW">Lay The Draw</option>
                                <option value="SCALPING_OVER_15">Scalping Over 1.5</option>
                            </select>
                            <input type="number" id="trading-conf-${matchUUID}" class="text-xs p-1.5 border rounded w-full" placeholder="Conf %" value="70" min="0" max="100">
                        </div>
                        <button onclick="assignTradingToMatch('${matchUUID}', '${partita.replace(/'/g, "\\'")}', '${data}', '')" 
                                class="w-full bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-2 rounded transition-all">
                            <i class="fa-solid fa-save mr-1"></i> ASSEGNA TRADING STRATEGY
                        </button>
                    `;
                }

                console.log(`[Trading] ‚ùå Removed trading from ${partita}`);

            } catch (error) {
                console.error('[Trading] Error removing strategy:', error);
                alert('‚ùå Errore: ' + error.message);
            }
        };

        // ==================== RENAME STRATEGY EVENT LISTENERS ====================

        /**
         * Helper function to open rename modal for a strategy
         * @param {string} strategyId - ID of the strategy to rename
         * @param {string} currentName - Current display name
         */
        window.openRenameModal = function (strategyId, currentName) {
            document.getElementById('rename-strategy-id').textContent = strategyId;
            document.getElementById('rename-strategy-input').value = currentName;
            document.getElementById('rename-strategy-modal').classList.remove('hidden');
            // Focus sul campo input
            setTimeout(() => {
                document.getElementById('rename-strategy-input').focus();
                document.getElementById('rename-strategy-input').select();
            }, 100);
        };

        // Confirm rename button
        document.getElementById('rename-confirm-btn')?.addEventListener('click', async () => {
            const strategyId = document.getElementById('rename-strategy-id').textContent;
            const newName = document.getElementById('rename-strategy-input').value;

            const success = await renameStrategy(strategyId, newName);

            if (success) {
                // Close modal
                document.getElementById('rename-strategy-modal').classList.add('hidden');

                // Reload page to show new name
                setTimeout(() => {
                    location.reload();
                }, 1500);
            }
        });

        // ==================== TRADING 3.0 LOGIC ====================

        // LISTA RIGIDA DA top_leagues.txt
        const TOP_LEAGUES_30 = [
            'EU-ITA Serie A',
            'EU-ITA Serie B',
            'EU-ITA Coppa Italia',
            'EU-ENG Premier League',
            'EU-ENG Championship',
            'EU-ESP La Liga',
            'EU-DEU Bundesliga',
            'EU-FRA Ligue 1',
            'EU-NLD Eredivisie',
            'EU-NLD Eerste Divisie',
            'EU-POR Primeira Liga',
            'EU-BEL Pro League',
            'EU-TUR Super Lig',
            'EU-Champions League',
            'EU-Europa League',
            'EU-Conference League',
            'EU-CHE Super League',
            'EU-DNK Supeliga',
            'EU-GRC Supe league',
            'EU-IRL First Division',
            'EU-POL 1. Liga'
        ];

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üì¶ STRATEGY TEMPLATES (Centralized Definitions)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const STRATEGY_TEMPLATES = {
            'LAY_THE_DRAW': {
                id: 'LAY_THE_DRAW',
                shortId: 'ltd',
                name: 'Lay The Draw',
                icon: 'üé≤',
                color: 'orange',
                badgeClass: 'bg-orange-100 text-orange-700 border-orange-200',
                description: 'Scommetti contro il pareggio. Ideale per partite con favorito netto che tende a sbloccarsi.',
                defaultTiming: 'Primi 10-15 minuti',
                defaultEntry: '@ 3.2 - 4.0',
                defaultExit: '@ 2.20',
                riskLevel: 'Medio',
                actionLabel: 'Lay The Draw'
            },
            'BACK_OVER_25': {
                id: 'BACK_OVER_25',
                shortId: 'over25',
                name: 'Back Over 2.5',
                icon: '‚öΩ',
                color: 'blue',
                badgeClass: 'bg-blue-100 text-blue-700 border-blue-200',
                description: 'Punta su partite con almeno 3 gol. Ideale per sfide aperte tra attacchi prolifici.',
                defaultTiming: 'Pre-match o primi 20 minuti',
                defaultEntry: '@ 2.1 - 2.4',
                defaultExit: '@ 1.70',
                riskLevel: 'Medio-Alto',
                actionLabel: 'Back Over 2.5 Goals'
            },
            'SECOND_HALF_SURGE': {
                id: 'SECOND_HALF_SURGE',
                shortId: 'over25_2t',
                name: 'Gol nel 2¬∞ Tempo',
                icon: 'üî•',
                color: 'red',
                badgeClass: 'bg-red-100 text-red-700 border-red-200',
                description: 'Entra live sul mercato gol secondo tempo. Partite bloccate che esplodono nella ripresa.',
                defaultTiming: 'Fine primo tempo / Inizio secondo',
                defaultEntry: '@ 1.9 - 2.2',
                defaultExit: '@ 1.60',
                riskLevel: 'Medio',
                actionLabel: 'Back Over 0.5 2¬∞ Tempo'
            },
            'HT_SNIPER': {
                id: 'HT_SNIPER',
                shortId: 'ht_sniper',
                name: 'HT Sniper',
                icon: 'üéØ',
                color: 'purple',
                badgeClass: 'bg-purple-100 text-purple-700 border-purple-200',
                description: 'Sfrutta il mercato Over 0.5 primo tempo. Partite con squadre aggressive nei primi 45 minuti.',
                defaultTiming: 'Minuto 15-20',
                defaultEntry: '@ 1.7 - 2.0',
                defaultExit: '@ 1.40',
                riskLevel: 'Medio-Basso',
                actionLabel: 'Back Over 0.5 HT'
            },
            'UNDER_35_SCALPING': {
                id: 'UNDER_35_SCALPING',
                shortId: 'scalping',
                name: 'Scalping U3.5',
                icon: '‚ö°',
                color: 'emerald',
                badgeClass: 'bg-emerald-100 text-emerald-700 border-emerald-200',
                description: 'Scalping veloce su Under 3.5. Entrata dopo primo gol, uscita rapida per profitto sicuro.',
                defaultTiming: 'Dopo il primo gol',
                defaultEntry: '@ 1.4 - 1.6',
                defaultExit: '@ 1.20',
                riskLevel: 'Basso',
                actionLabel: 'Back Under 3.5'
            }
        };

        // Esponi globalmente per App
        window.STRATEGY_TEMPLATES = STRATEGY_TEMPLATES;

        // üîß Funzione per inizializzare i templates su Firebase (da eseguire una volta sola)
        window.initStrategyTemplates = async function () {
            console.log('[Strategy Templates] Inizializzazione su Firebase...');
            try {
                for (const [id, template] of Object.entries(STRATEGY_TEMPLATES)) {
                    await setDoc(doc(db, "strategy_templates", id), template);
                    console.log(`[Strategy Templates] ‚úÖ Salvato: ${id}`);
                }
                alert('‚úÖ Templates salvati su Firebase!');
            } catch (e) {
                console.error('[Strategy Templates] ‚ùå Errore:', e);
                alert('‚ùå Errore: ' + e.message);
            }
        };

        const datePicker30 = document.getElementById('trading-30-date');
        window.datePicker30 = datePicker30;
        const generateBtn30 = document.getElementById('trading-30-generate-btn');
        const regenerateBtn30 = document.getElementById('trading-30-regenerate-btn');
        const calculateBtn30 = document.getElementById('trading-30-calculate-btn');

        if (datePicker30) {
            datePicker30.valueAsDate = new Date();
            datePicker30.addEventListener('change', loadTradingLiveOpportunities);
        }

        generateBtn30?.addEventListener('click', () => executeTradingGeneration(false));
        regenerateBtn30?.addEventListener('click', () => executeTradingGeneration(true));
        calculateBtn30?.addEventListener('click', executeOutcomeCalculation);

        if (generateBtn30) {
            // Unifica Stile Pulsanti
            const baseBtnClass = "h-10 px-4 rounded-lg text-xs font-bold shadow-sm flex items-center gap-2 whitespace-nowrap transition-all";

            // Fix existing buttons
            generateBtn30.className = `bg-white text-emerald-700 border border-emerald-200 hover:bg-emerald-50 ${baseBtnClass} flex-1 justify-center`;
            if (regenerateBtn30) regenerateBtn30.className = `bg-emerald-600 text-white hover:bg-emerald-700 ${baseBtnClass}`;
            if (calculateBtn30) calculateBtn30.className = `bg-emerald-900 text-emerald-100 hover:bg-emerald-800 border border-emerald-700 ${baseBtnClass} w-full justify-center`;
            const historyBtn30 = document.getElementById('trading-30-history-btn');
            if (historyBtn30) {
                historyBtn30.className = `bg-purple-700 text-white hover:bg-purple-600 border border-purple-500 ${baseBtnClass} w-full justify-center`;

            }

            // Aggiungo tasto GESTIONE TEMPLATES con lo stesso stile
            const tmplBtn = document.createElement('button');
            tmplBtn.className = `bg-slate-700 hover:bg-slate-800 text-white border border-slate-600 ${baseBtnClass} ml-2`;
            tmplBtn.innerHTML = '<i class="fa-solid fa-layer-group"></i> Gestione Templates';
            tmplBtn.onclick = openTemplateManager;

            // Insert safely into the same container using appendChild
            generateBtn30.parentNode.appendChild(tmplBtn);
        }

        // --- STRATEGY TEMPLATE MANAGER LOGIC ---
        let loadedTemplates = {};

        async function openTemplateManager() {
            // Create Modal if not exists
            let modal = document.getElementById('template-manager-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'template-manager-modal';
                modal.className = "fixed inset-0 bg-slate-900/80 backdrop-blur-sm z-[9999] hidden flex items-center justify-center p-4";
                modal.innerHTML = `
                    <div class="bg-white rounded-2xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col overflow-hidden">
                        <!-- Header -->
                        <div class="bg-slate-50 px-6 py-4 border-b border-slate-200 flex justify-between items-center">
                            <div>
                                <h3 class="text-lg font-black text-slate-800 uppercase tracking-tight">Gestione Strategie Operative</h3>
                                <p class="text-xs text-slate-500">Definisci i parametri standard per i segnali di trading</p>
                            </div>
                            <button onclick="closeTemplateManager()" class="bg-white text-slate-400 hover:text-red-500 hover:bg-red-50 w-8 h-8 rounded-full flex items-center justify-center transition border border-slate-200">
                                <i class="fa-solid fa-times"></i>
                            </button>
                        </div>
                        
                        <!-- Content -->
                        <div class="p-6 overflow-y-auto bg-slate-100 flex-1 space-y-4" id="template-editor-content">
                            <div class="text-center py-10"><i class="fa-solid fa-spinner fa-spin text-3xl text-slate-300"></i></div>
                        </div>

                        <!-- Footer -->
                        <div class="bg-white px-6 py-4 border-t border-slate-200 flex justify-between items-center">
                            <button onclick="closeTemplateManager()" class="px-4 py-2 rounded-lg text-slate-600 font-bold hover:bg-slate-50 text-sm">Annulla</button>
                            <button onclick="saveTemplates()" class="px-6 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-bold text-sm shadow-lg shadow-indigo-200">
                                <i class="fa-solid fa-save mr-2"></i> Salva Modifiche
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            modal.classList.remove('hidden');
            await loadAndRenderTemplates();
        }

        window.closeTemplateManager = function () {
            document.getElementById('template-manager-modal')?.classList.add('hidden');
        }

        async function loadAndRenderTemplates() {
            const container = document.getElementById('template-editor-content');
            try {
                const snap = await getDocs(collection(db, "strategy_templates"));
                loadedTemplates = {};
                snap.forEach(doc => loadedTemplates[doc.id] = doc.data());

                // AUTO-POPULATE DEFAULTS IF EMPTY
                if (Object.keys(loadedTemplates).length === 0) {
                    console.log('[Templates] Database vuoto, carico default in memoria...');
                    loadedTemplates = JSON.parse(JSON.stringify(window.STRATEGY_TEMPLATES || {})); // Clone defaults
                }

                container.innerHTML = Object.entries(loadedTemplates).map(([key, t]) => `
                    <div class="bg-white rounded-xl border border-slate-200 shadow-sm p-4 relative group hover:border-indigo-300 transition-all">
                        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                            <!-- Basic Info -->
                            <div class="md:col-span-1 border-r border-slate-100 pr-4">
                                <label class="block text-[10px] font-bold text-slate-400 uppercase mb-1">ID (Backend)</label>
                                <input type="text" value="${key}" readonly class="w-full bg-slate-50 border border-slate-200 rounded px-2 py-1 text-xs font-mono text-slate-500 mb-2">
                                
                                <label class="block text-[10px] font-bold text-indigo-500 uppercase mb-1">Nome Strategia</label>
                                <input type="text" id="t-name-${key}" value="${t.name || ''}" class="w-full bg-white border border-slate-200 rounded px-2 py-1 text-sm font-bold text-slate-800 focus:ring-2 focus:ring-indigo-500 outline-none">
                            </div>

                            <!-- Parameters -->
                            <div class="md:col-span-3 grid grid-cols-3 gap-3">
                                <div>
                                    <label class="block text-[10px] font-bold text-slate-400 uppercase mb-1">Entry (Default)</label>
                                    <input type="text" id="t-entry-${key}" value="${t.defaultEntry || ''}" class="w-full bg-white border border-slate-200 rounded px-2 py-1 text-sm font-medium text-emerald-700">
                                </div>
                                <div>
                                    <label class="block text-[10px] font-bold text-slate-400 uppercase mb-1">Exit (Default)</label>
                                    <input type="text" id="t-exit-${key}" value="${t.defaultExit || ''}" class="w-full bg-white border border-slate-200 rounded px-2 py-1 text-sm font-medium text-red-600">
                                </div>
                                <div>
                                    <label class="block text-[10px] font-bold text-slate-400 uppercase mb-1">Timing</label>
                                    <input type="text" id="t-timing-${key}" value="${t.defaultTiming || ''}" class="w-full bg-white border border-slate-200 rounded px-2 py-1 text-sm text-slate-600">
                                </div>
                                <div class="col-span-3 mt-1">
                                    <label class="block text-[10px] font-bold text-slate-400 uppercase mb-1">Descrizione / Reasoning</label>
                                    <input type="text" id="t-desc-${key}" value="${t.description || t.reasoning || ''}" class="w-full bg-white border border-slate-200 rounded px-2 py-1 text-xs text-slate-500 italic">
                                </div>
                            </div>
                        </div>
                        <div class="absolute top-2 right-2 opacity-10 text-4xl pointer-events-none">${t.icon || 'üì¶'}</div>
                    </div>
                `).join('');

                if (Object.keys(loadedTemplates).length === 0 && !window.STRATEGY_TEMPLATES) {
                    container.innerHTML = '<div class="text-center p-10 text-red-500">Nessun default trovato. Controlla window.STRATEGY_TEMPLATES</div>';
                }

            } catch (e) {
                console.error(e);
                container.innerHTML = `<div class="text-red-500 p-4">Errore caricamento: ${e.message}</div>`;
            }
        }

        window.saveTemplates = async function () {
            const btn = document.querySelector('#template-manager-modal button i.fa-save').parentNode;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Saving...';
            btn.disabled = true;

            try {
                let batchCount = 0;
                for (const key of Object.keys(loadedTemplates)) {
                    // Update object from DOM
                    loadedTemplates[key].name = document.getElementById(`t-name-${key}`).value;
                    loadedTemplates[key].defaultEntry = document.getElementById(`t-entry-${key}`).value;
                    loadedTemplates[key].defaultExit = document.getElementById(`t-exit-${key}`).value;
                    loadedTemplates[key].defaultTiming = document.getElementById(`t-timing-${key}`).value;
                    loadedTemplates[key].description = document.getElementById(`t-desc-${key}`).value;

                    // SAVE TO FIREBASE
                    await setDoc(doc(db, "strategy_templates", key), loadedTemplates[key]);
                    batchCount++;
                }

                alert(`‚úÖ Salvati ${batchCount} templates con successo!`);
                closeTemplateManager();
            } catch (e) {
                alert('Errore salvataggio: ' + e.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async function executeTradingGeneration(isRegenerate = false) {
            const selectedDate = datePicker30?.value || new Date().toISOString().split('T')[0];
            const btn = isRegenerate ? regenerateBtn30 : generateBtn30;

            if (!btn) return;
            const originalHTML = btn.innerHTML;

            btn.disabled = true;
            btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> RECUPERO ODDS...';

            try {
                if (typeof window.selectTopTradingSportivoPicks !== 'function') {
                    throw new Error('Algoritmi Trading Sportivo non caricati (engine.js missing?).');
                }

                // Carica Blacklist di sistema (opzionale ma consigliato)
                let blacklistSystem = [];
                const blDoc = await getDoc(doc(db, "system", "blacklisted_leagues"));
                if (blDoc.exists()) blacklistSystem = blDoc.data().leagues || [];

                // Filtra match per data
                let matchesToProcess = window.allMatches?.filter(m => m.data === selectedDate) || [];

                // Applica Filtro Blacklist
                if (blacklistSystem.length > 0) {
                    const blLower = blacklistSystem.map(l => String(l || "").toLowerCase().trim());
                    matchesToProcess = matchesToProcess.filter(m => {
                        const ln = (window.normalizeLega(m.lega) || "").toLowerCase().trim();
                        return !blLower.includes(ln);
                    });
                }

                // Applica Filtro Leghe Principali (REQUISITO TRADING 3.0)
                const preLeagueFilterCount = matchesToProcess.length;
                matchesToProcess = matchesToProcess.filter(m => {
                    const normLega = (window.normalizeLega(m.lega) || "").toLowerCase();
                    return TOP_LEAGUES_30.some(top => {
                        return normLega.includes(top.toLowerCase());
                    });
                });
                console.log(`[Trading 3.0] Filtro Leghe: ${preLeagueFilterCount} -> ${matchesToProcess.length}`);

                if (matchesToProcess.length === 0) {
                    alert(`‚ö†Ô∏è Nessuna partita dei Campionati Principali trovata per il ${selectedDate}.`);
                    return;
                }

                // === 1. SYNC ODDS FETCHING (CRITICAL FIX) ===
                // Fetch odds for ALL candidates BEFORE calculation to ensure Value Edge works
                const fixturesToFetch = matchesToProcess.filter(m => m.fixtureId).map(m => m.fixtureId);

                if (fixturesToFetch.length > 0) {
                    console.log(`[Trading 3.0] Fetching Odds for ${fixturesToFetch.length} matches...`);

                    // Helper batch fetch (simulated if no bulk endpoint, simplified loop here)
                    // In production, we should use a bulk endpoint. Here we loop for safety 
                    // or use the existing single fetch if batch not avail.
                    // Assuming we have to fetch individually or in small parallel batches.

                    // Let's use parallel fetching with limit
                    const CONCURRENCY = 5;
                    for (let i = 0; i < fixturesToFetch.length; i += CONCURRENCY) {
                        const chunk = fixturesToFetch.slice(i, i + CONCURRENCY);
                        await Promise.all(chunk.map(async (fid) => {
                            try {
                                const oddsData = await getOddsFromAPI(fid); // Uses existing function
                                // Find match and update
                                const m = matchesToProcess.find(x => x.fixtureId == fid);
                                if (m && oddsData) {
                                    // Merge odds into match object for the engine
                                    m.betfairOver25 = oddsData.over25;
                                    m.betfairUnder25 = oddsData.under25;
                                    m.betfairDraw = oddsData.draw;
                                    m.quota1 = oddsData.home; // Update 1X2 as well
                                    m.quotaX = oddsData.draw;
                                    m.quota2 = oddsData.away;
                                    m.betfairGG = oddsData.gg;
                                    m.betfairNG = oddsData.ng;
                                }
                            } catch (err) {
                                console.warn(`Failed odds fetch for ${fid}`, err);
                            }
                        }));
                        // Small delay to respect rate limits if needed
                        btn.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i> ODDS ${Math.min(i + CONCURRENCY, fixturesToFetch.length)}/${fixturesToFetch.length}...`;
                    }
                }

                btn.innerHTML = '<i class="fa-solid fa-cog fa-spin"></i> CALCOLO STRATEGIE...';

                // === 2. EXECUTE ENGINE (WITH ODDS NOW) ===
                const tradingPicks = window.selectTopTradingSportivoPicks(matchesToProcess, selectedDate);

                if (tradingPicks.length === 0) {
                    alert('‚ùå Nessuna opportunit√† di Trading 3.0 identificata per oggi (anche dopo analisi odds).');
                    return;
                }

                await setDoc(doc(db, "daily_trading_picks", selectedDate), {
                    picks: tradingPicks,
                    generated: new Date().toISOString(),
                    count: tradingPicks.length,
                    date: selectedDate,
                    isTrading30: true
                });

                alert(`üéØ Professional Trading 3.0: Generati ${tradingPicks.length} studi per il ${selectedDate} con Quote Betfair!`);

                // Update specific views
                loadTradingLiveOpportunities(); // Trading Dashboard
                loadOpportunities30();     // Cards Section (Immediate Update)

            } catch (e) {
                console.error('[Trading Gen] Error:', e);
                alert('‚ùå Errore: ' + e.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalHTML;
            }
        }

        async function executeOutcomeCalculation() {
            const selectedDate = datePicker30?.value || new Date().toISOString().split('T')[0];
            console.log('[DEBUG ESITI] üéØ INIZIO CALCOLO per data:', selectedDate);

            const btn = calculateBtn30;
            if (!btn) {
                console.log('[DEBUG ESITI] ‚ùå Bottone non trovato!');
                return;
            }
            const originalHTML = btn.innerHTML;

            btn.disabled = true;
            btn.innerHTML = '<i class="fa-solid fa-sync fa-spin"></i> CALCOLO...';

            try {
                const docRef = doc(db, "daily_trading_picks", selectedDate);
                console.log('[DEBUG ESITI] üìÑ Recupero documento:', selectedDate);
                const docSnap = await getDoc(docRef);

                if (!docSnap.exists()) {
                    console.log('[DEBUG ESITI] ‚ùå Documento NON esiste per:', selectedDate);
                    alert('‚ùå Nessuno studio trovato per questa data.');
                    return;
                }

                const tradingData = docSnap.data();
                const picks = tradingData.picks || [];
                console.log('[DEBUG ESITI] üìä Picks trovati:', picks.length);
                console.log('[DEBUG ESITI] üìã Picks dettaglio:', picks.map(p => ({ partita: p.partita, strategy: p.strategy })));

                // Recupera risultati FT, HT e fixtureId da window.allMatches o Firestore
                const resultsMap = {}; // Key: fixtureId
                const htMap = {};      // Key: fixtureId

                if (window.allMatches && window.allMatches.length > 0) {
                    console.log('[ESITI] ‚úÖ Uso window.allMatches (LOCAL MODE)');
                    const localMatches = window.allMatches.filter(m => m.data === selectedDate);
                    console.log('[ESITI] üì¶ Matches locali per', selectedDate, ':', localMatches.length);

                    localMatches.forEach(m => {
                        if (m.fixtureId) {
                            resultsMap[m.fixtureId] = m.risultato;
                            if (m.risultato_ht) htMap[m.fixtureId] = m.risultato_ht;
                        }
                    });
                } else {
                    const matchesRef = collection(db, "matches");
                    const q = query(matchesRef, where("data", "==", selectedDate));
                    const matchesSnap = await getDocs(q);
                    matchesSnap.forEach(d => {
                        const m = d.data();
                        if (m.fixtureId) {
                            resultsMap[m.fixtureId] = m.risultato;
                            if (m.risultato_ht) htMap[m.fixtureId] = m.risultato_ht;
                        }
                    });
                }

                let updated = 0;

                // Process each pick
                for (let i = 0; i < picks.length; i++) {
                    const p = picks[i];
                    console.log(`[ESITI] üîÑ Pick ${i + 1}/${picks.length}: ${p.partita} (ID: ${p.fixtureId || 'NO ID'})`);

                    if (!p.fixtureId) {
                        console.log(`[ESITI]    ‚ö†Ô∏è Pick senza fixtureId, impossibile calcolare esito sicuro`);
                        continue;
                    }

                    const resFT = resultsMap[p.fixtureId];
                    const resHTFromDB = htMap[p.fixtureId];

                    if (!resFT || !resFT.includes('-')) {
                        console.log(`[ESITI]    ‚ö†Ô∏è Risultato FT non trovato in DB per ID: ${p.fixtureId}`);
                        continue;
                    }

                    // Parse FT score
                    const ftParts = resFT.split('-').map(g => parseInt(g.trim()));
                    if (ftParts.length !== 2 || isNaN(ftParts[0]) || isNaN(ftParts[1])) continue;
                    const [ftHome, ftAway] = ftParts;
                    const ftTotal = ftHome + ftAway;

                    // Use HT score from DB or already in pick
                    let htHome = null, htAway = null, htTotal = 0;
                    const finalHT = resHTFromDB || p.risultatoHT;

                    if (finalHT && finalHT.includes('-')) {
                        const htParts = finalHT.split('-').map(g => parseInt(g.trim()));
                        if (htParts.length === 2) {
                            htHome = htParts[0];
                            htAway = htParts[1];
                            htTotal = htHome + htAway;
                            p.risultatoHT = finalHT;
                            console.log(`[ESITI]    üì¶ HT da DB/Pick: ${p.risultatoHT}`);
                        }
                    }

                    p.risultato = resFT;
                    const stTotal = (ftHome - (htHome || 0)) + (ftAway - (htAway || 0));

                    // Calculate ALL strategies outcomes
                    const allStrategies = [];

                    // BACK_OVER_25
                    if (ftTotal >= 3) allStrategies.push({ type: 'BACK_OVER_25', esito: 'Vinta', color: 'green' });
                    else if (ftTotal === 2) allStrategies.push({ type: 'BACK_OVER_25', esito: 'Cash-out', color: 'yellow' });
                    else allStrategies.push({ type: 'BACK_OVER_25', esito: 'Stop-loss', color: 'red' });

                    // LAY_THE_DRAW
                    if (ftHome !== ftAway) allStrategies.push({ type: 'LAY_THE_DRAW', esito: 'Vinta', color: 'green' });
                    else if (ftTotal > 0) allStrategies.push({ type: 'LAY_THE_DRAW', esito: 'Cash-out', color: 'yellow' });
                    else allStrategies.push({ type: 'LAY_THE_DRAW', esito: 'Stop-loss', color: 'red' });

                    // HT_SNIPER (requires HT)
                    if (htHome !== null) {
                        if (htTotal >= 1) allStrategies.push({ type: 'HT_SNIPER', esito: 'Vinta', color: 'green' });
                        else allStrategies.push({ type: 'HT_SNIPER', esito: 'Persa', color: 'red' });
                    }

                    // SECOND_HALF_SURGE (requires HT)
                    if (htHome !== null) {
                        if (stTotal >= 1) allStrategies.push({ type: 'SECOND_HALF_SURGE', esito: 'Vinta', color: 'green' });
                        else allStrategies.push({ type: 'SECOND_HALF_SURGE', esito: 'Persa', color: 'red' });
                    }

                    // UNDER_35_SCALPING
                    if (ftTotal < 4) allStrategies.push({ type: 'UNDER_35_SCALPING', esito: 'Vinta', color: 'green' });
                    else allStrategies.push({ type: 'UNDER_35_SCALPING', esito: 'Persa', color: 'red' });

                    p.allStrategiesOutcomes = allStrategies;

                    const chosenOutcome = allStrategies.find(s => s.type === p.strategy);
                    if (chosenOutcome) {
                        p.esito = chosenOutcome.esito;
                        p.esitoColor = chosenOutcome.color;
                        updated++;
                        console.log(`[ESITI]    ‚úÖ ${p.strategy}: ${chosenOutcome.esito}`);
                    }
                }

                console.log('[ESITI] üìà Totale:', updated, '/', picks.length);

                if (updated > 0) {
                    const dataToSave = { ...tradingData, picks, lastOutcomeUpdate: new Date().toISOString() };

                    try {
                        await setDoc(docRef, dataToSave);
                    } catch (saveError) {
                        console.error('[ESITI] ‚ùå setDoc FALLITO:', saveError);
                        alert('‚ùå Errore salvataggio: ' + saveError.message);
                        return;
                    }

                    alert(`‚úÖ Esiti Trading aggiornati (Local DB Mode)!\n${updated}/${picks.length} match chiusi.`);
                    loadTradingLiveOpportunities();
                } else {
                    alert('‚ö†Ô∏è Nessun risultato nuovo trovato nel database.');
                }

            } catch (e) {
                console.error('[ESITI] ‚ùå ERRORE:', e);
                alert('‚ùå Errore calcolo: ' + e.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalHTML;
            }
        }

        /**
         * üî• NEW v13.0: Aggiornamento Automatico Esiti Trading 3.0 (Silent Mode)
         * Viene chiamata dopo ogni salvataggio di risultati per automatizzare il calcolo esiti.
         */
        async function autoUpdateTrading30(selectedDate, resultsData) {
            console.log(`[DEBUG-Trading] üîÑ Avvio calcolo automatico per ${selectedDate} (${resultsData.length} nuovi risultati)`);

            try {
                const docRef = doc(db, "daily_trading_picks", selectedDate);
                const docSnap = await getDoc(docRef);

                if (!docSnap.exists()) {
                    console.log(`[DEBUG-Trading] üìÑ Nessuno studio Trading 3.0 trovato per il ${selectedDate}.`);
                    return;
                }

                const tradingData = docSnap.data();
                const picks = tradingData.picks || [];
                let updatedCount = 0;

                // Mappatura risultati per velocit√†
                const resultsMap = {};
                const htMap = {};
                resultsData.forEach(m => {
                    const norm = window.normalizeTeamName(m.partita);
                    resultsMap[norm] = m.risultato;
                    if (m.risultato_ht) htMap[norm] = m.risultato_ht;
                });

                for (const p of picks) {
                    const normPick = window.normalizeTeamName(p.partita);
                    const resFT = resultsMap[normPick];
                    const resHT = htMap[normPick] || p.risultatoHT; // Usa HT appena caricato o quello gi√† nel pick

                    if (!resFT) continue;

                    // Parse Scores
                    const ftParts = resFT.split('-').map(g => parseInt(g.trim()));
                    if (ftParts.length !== 2 || isNaN(ftParts[0]) || isNaN(ftParts[1])) continue;
                    const ftH = ftParts[0], ftA = ftParts[1];
                    const ftTotal = ftH + ftA;

                    let htHome = null, htAway = null, htTotal = 0;
                    if (resHT && resHT.includes('-')) {
                        const htParts = resHT.split('-').map(g => parseInt(g.trim()));
                        if (htParts.length === 2) {
                            htHome = htParts[0]; htAway = htParts[1];
                            htTotal = htHome + htAway;
                            p.risultatoHT = resHT;
                        }
                    }

                    p.risultato = resFT;
                    const stTotal = (ftH - (htHome || 0)) + (ftA - (htAway || 0));

                    // Strategie
                    const allOutcomes = [];

                    // 1. BACK_OVER_25
                    if (ftTotal >= 3) allOutcomes.push({ type: 'BACK_OVER_25', esito: 'Vinta', color: 'green' });
                    else if (ftTotal === 2) allOutcomes.push({ type: 'BACK_OVER_25', esito: 'Cash-out', color: 'yellow' });
                    else allOutcomes.push({ type: 'BACK_OVER_25', esito: 'Stop-loss', color: 'red' });

                    // 2. LAY_THE_DRAW
                    if (ftH !== ftA) allOutcomes.push({ type: 'LAY_THE_DRAW', esito: 'Vinta', color: 'green' });
                    else if (ftTotal > 0) allOutcomes.push({ type: 'LAY_THE_DRAW', esito: 'Cash-out', color: 'yellow' });
                    else allOutcomes.push({ type: 'LAY_THE_DRAW', esito: 'Stop-loss', color: 'red' });

                    // 3. HT_SNIPER (solo se HT presente)
                    if (htHome !== null) {
                        if (htTotal >= 1) allOutcomes.push({ type: 'HT_SNIPER', esito: 'Vinta', color: 'green' });
                        else allOutcomes.push({ type: 'HT_SNIPER', esito: 'Persa', color: 'red' });
                    }

                    // 4. SECOND_HALF_SURGE (solo se HT presente)
                    if (htHome !== null) {
                        if (stTotal >= 1) allOutcomes.push({ type: 'SECOND_HALF_SURGE', esito: 'Vinta', color: 'green' });
                        else allOutcomes.push({ type: 'SECOND_HALF_SURGE', esito: 'Persa', color: 'red' });
                    }

                    // 5. UNDER_35_SCALPING
                    if (ftTotal < 4) allOutcomes.push({ type: 'UNDER_35_SCALPING', esito: 'Vinta', color: 'green' });
                    else allOutcomes.push({ type: 'UNDER_35_SCALPING', esito: 'Persa', color: 'red' });

                    p.allStrategiesOutcomes = allOutcomes;

                    // Applica esito alla strategia scelta per il pick
                    const chosen = allOutcomes.find(s => s.type === p.strategy);
                    if (chosen && (p.esito !== chosen.esito)) {
                        p.esito = chosen.esito;
                        p.esitoColor = chosen.color;
                        updatedCount++;
                        console.log(`[DEBUG-Trading] ‚úÖ Pick Aggiornato: ${p.partita} (${p.strategy}) -> ${p.esito}`);
                    }
                }

                if (updatedCount > 0) {
                    await setDoc(docRef, { ...tradingData, picks, lastOutcomeUpdate: new Date().toISOString() });
                    console.log(`[DEBUG-Trading] üíæ Database aggiornato: ${updatedCount} esiti Trading 3.0 chiusi.`);
                    // Ricarica la sezione se visibile
                    if (document.getElementById('trading-30-section') && !document.getElementById('trading-30-section').classList.contains('hidden')) {
                        loadTradingLiveOpportunities();
                    }
                }

            } catch (err) {
                console.error(`[DEBUG-Trading] ‚ùå Errore aggiornamento automatico:`, err);
            }
        }


        function calculateTradingOutcome(pick, risultato) {
            console.log('[DEBUG OUTCOME] üßÆ Calcolo per:', pick.partita, '| Strategy:', pick.strategy, '| Risultato:', risultato);

            const parts = risultato.split('-').map(g => parseInt(g.trim()));
            if (parts.length !== 2 || isNaN(parts[0]) || isNaN(parts[1])) {
                console.log('[DEBUG OUTCOME] ‚ùå Risultato non valido:', risultato);
                return null;
            }
            const [gH, gA] = parts;
            const tot = gH + gA;
            console.log('[DEBUG OUTCOME] üìä Gol: Home=', gH, ', Away=', gA, ', Tot=', tot);

            if (pick.strategy === 'BACK_OVER_25') {
                console.log('[DEBUG OUTCOME] üéØ Strategy: BACK_OVER_25');
                if (tot <= 1) return { esito: 'Stop-loss', color: 'red' };
                if (tot === 2) return { esito: 'Cash-out', color: 'yellow' };
                return { esito: 'Vinta', color: 'green' };
            }
            if (pick.strategy === 'LAY_THE_DRAW') {
                console.log('[DEBUG OUTCOME] üéØ Strategy: LAY_THE_DRAW');
                if (risultato === '0-0') return { esito: 'Stop-loss', color: 'red' };
                if (gH === gA && tot > 0) return { esito: 'Cash-out', color: 'yellow' };
                return { esito: 'Vinta', color: 'green' };
            }

            console.log('[DEBUG OUTCOME] üîÑ Fallback a evaluateTipLocally...');
            // Fallback evaluation
            const evalEsito = typeof evaluateTipLocally === 'function' ? evaluateTipLocally(pick.tip || pick.tradingInstruction?.action, risultato) : null;
            console.log('[DEBUG OUTCOME] üìã evaluateTipLocally returned:', evalEsito);

            if (evalEsito) {
                return { esito: evalEsito, color: (evalEsito === 'Vinto' || evalEsito === 'Vinta') ? 'green' : 'red' };
            }

            console.log('[DEBUG OUTCOME] ‚ö†Ô∏è Nessun esito calcolato, return NULL');
            return null;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ‚ö°Ô∏è TRADING 3.0 LIVE OPPORTUNITIES (Leghe Top Live)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function loadTradingLiveOpportunities() {
            const selectedDate = datePicker30?.value || new Date().toISOString().split('T')[0];
            const container = document.getElementById('trading-live-content');
            const section = document.getElementById('trading-live-section');
            const dateLabel = document.getElementById('trading-live-date');

            if (!container) return;


            try {
                const docRef = doc(db, "daily_trading_picks", selectedDate);
                const docSnap = await getDoc(docRef);

                section.classList.remove('hidden');
                dateLabel.textContent = selectedDate;

                if (!docSnap.exists()) {
                    container.innerHTML = `
                        <div class="text-center py-10 text-gray-400 bg-gray-50 rounded-xl border-2 border-dashed border-gray-200">
                            <i class="fa-solid fa-hand-pointer text-4xl mb-3 block text-indigo-300"></i>
                            <div class="text-gray-600 font-bold mb-1">Nessuno studio attivo per questa data.</div>
                            <div class="text-xs">Usa il tasto <span class="font-bold text-emerald-600 uppercase">Genera Studio</span> per l'automatismo.</div>
                        </div>`;
                    regenerateBtn30?.classList.add('hidden');
                    return;
                }

                regenerateBtn30?.classList.remove('hidden');
                const data = docSnap.data();
                const picks = data.picks || [];

                if (picks.length === 0) {
                    container.innerHTML = `<div class="text-center py-10 text-gray-500 italic">Analisi completata: nessuna opportunit√† identificata.</div>`;
                    return;
                }

                // Calculate stats for summary
                const stats = { total: picks.length, vinte: 0, perse: 0, cashout: 0, stoploss: 0, pending: 0 };
                picks.forEach(p => {
                    const e = (p.esito || '').toLowerCase();
                    if (e.includes('vinta') || e.includes('vinto') || e.includes('win')) stats.vinte++;
                    else if (e.includes('persa') || e.includes('perso') || e.includes('lose')) stats.perse++;
                    else if (e.includes('cash')) stats.cashout++;
                    else if (e.includes('stop')) stats.stoploss++;
                    else stats.pending++;
                });

                // Helper for outcome badge
                const getOutcomeBadge = (esito, color) => {
                    const e = (esito || '').toLowerCase();
                    if (e.includes('vinta') || e.includes('vinto')) return `<span class="bg-green-500 text-white px-2 py-0.5 rounded text-[10px] font-black">‚úÖ ${esito}</span>`;
                    if (e.includes('persa') || e.includes('perso')) return `<span class="bg-red-500 text-white px-2 py-0.5 rounded text-[10px] font-black">‚ùå ${esito}</span>`;
                    if (e.includes('cash')) return `<span class="bg-yellow-500 text-white px-2 py-0.5 rounded text-[10px] font-black">üü° ${esito}</span>`;
                    if (e.includes('stop')) return `<span class="bg-red-700 text-white px-2 py-0.5 rounded text-[10px] font-black">üõë ${esito}</span>`;
                    return `<span class="bg-gray-400 text-white px-2 py-0.5 rounded text-[10px] font-black">‚è≥ In attesa</span>`;
                };

                // Small outcome icon for strategy list
                const getSmallIcon = (esito) => {
                    const e = (esito || '').toLowerCase();
                    if (e.includes('vinta') || e.includes('vinto')) return '‚úÖ';
                    if (e.includes('persa') || e.includes('perso')) return '‚ùå';
                    if (e.includes('cash')) return 'üü°';
                    if (e.includes('stop')) return 'üõë';
                    return '‚è≥';
                };

                // Inject Back Button if not present (only if NOT today)
                const today = new Date().toISOString().split('T')[0];
                const headerTitle = section.querySelector('h2');

                if (selectedDate !== today) {
                    if (headerTitle && !document.getElementById('trading-hist-back-btn')) {
                        const backBtn = document.createElement('button');
                        backBtn.id = 'trading-hist-back-btn';
                        backBtn.className = "mr-3 text-emerald-800 hover:text-emerald-600 transition bg-emerald-100 w-8 h-8 rounded-full flex items-center justify-center";
                        backBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                        backBtn.onclick = () => window.switchTradingView30('history_list');
                        headerTitle.prepend(backBtn);
                    }
                } else {
                    // Remove if exists (we are in today view)
                    const existingBtn = document.getElementById('trading-hist-back-btn');
                    if (existingBtn) existingBtn.remove();
                }


                container.innerHTML = `
                    <!-- SUMMARY STATS -->
                    <div class="bg-gradient-to-r from-indigo-600 to-purple-600 rounded-xl p-4 mb-6 text-white shadow-lg">
                        <div class="text-sm font-bold uppercase tracking-wider mb-2 opacity-80">üìä Riepilogo ${selectedDate}</div>
                        <div class="grid grid-cols-5 gap-2 text-center">
                            <div class="bg-white/20 rounded-lg p-2">
                                <div class="text-2xl font-black">${stats.total}</div>
                                <div class="text-[10px] uppercase opacity-80">Totali</div>
                            </div>
                            <div class="bg-green-500/50 rounded-lg p-2">
                                <div class="text-2xl font-black">${stats.vinte}</div>
                                <div class="text-[10px] uppercase">Vinte</div>
                            </div>
                            <div class="bg-yellow-500/50 rounded-lg p-2">
                                <div class="text-2xl font-black">${stats.cashout}</div>
                                <div class="text-[10px] uppercase">Cash-out</div>
                            </div>
                            <div class="bg-red-500/50 rounded-lg p-2">
                                <div class="text-2xl font-black">${stats.perse + stats.stoploss}</div>
                                <div class="text-[10px] uppercase">Perse</div>
                            </div>
                            <div class="bg-gray-500/50 rounded-lg p-2">
                                <div class="text-2xl font-black">${stats.pending}</div>
                                <div class="text-[10px] uppercase">Pending</div>
                            </div>
                        </div>
                        <div class="mt-3 text-center">
                            <span class="text-xl font-black">${stats.total > 0 ? Math.round((stats.vinte / stats.total) * 100) : 0}%</span>
                            <span class="text-sm opacity-80 ml-1">Win Rate (solo Vinte)</span>
                        </div>
                    </div>

                    <!-- PICKS LIST -->
                    <div class="space-y-4">
                        ${picks.map((p, idx) => {
                    // Helper expects 'o' object wrapper
                    const o = {
                        match: p, // 'p' from Firestore has match data merged
                        magicStats: p.magicStats || {},
                        strategy: p.strategy,
                        confidence: p.confidence
                    };
                    return window.renderTrading30Card(o, p.strategy, selectedDate);
                }).join('')}

                    </div>
                `;

            } catch (e) {
                console.error('[Load Today] Error:', e);
                container.innerHTML = `<div class="text-red-500 text-center py-10">Errore: ${e.message}</div>`;
            }
        }


        // ========== STORICO TRADING FUNCTIONS ==========





        // View management logic moved to the bottom script block to avoid redeclaration.
        window.loadOpportunities30 = loadOpportunities30;
        window.loadTradingLiveOpportunities = loadTradingLiveOpportunities;


        // Renamed to clarify it loads the LIST of dates
        // loadTradingHistoryList moved to the bottom script block.


        // Expose to window for backward compatibility if needed, but logic is moved to switchTradingView30
        window.loadTradingHistory = loadTradingHistoryList;




        // Initialize display if active page is trading-30
        document.querySelectorAll('.nav-button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.getAttribute('data-page') === 'page-trading-30') {
                    loadTradingLiveOpportunities();
                    // REMOVED AUTO-LOAD: loadOpportunities30(); 
                    // User must explicitly generate or load history.
                }
            });
        });

        // Helper to calc last 5 stats
        function calculateLast5Stats(teamName, refDate, allMatches) {
            const pastMatches = allMatches.filter(m =>
                (m.casa === teamName || m.trasferta === teamName) &&
                m.data < refDate &&
                m.risultato
            ).sort((a, b) => b.data.localeCompare(a.data))
                .slice(0, 5);

            const stats = { gf: 0, gs: 0, count: pastMatches.length };
            pastMatches.forEach(m => {
                const scores = m.risultato.split('-').map(Number);
                if (scores.length !== 2) return;
                if (m.casa === teamName) { stats.gf += scores[0]; stats.gs += scores[1]; }
                else { stats.gf += scores[1]; stats.gs += scores[0]; }
            });
            return stats;
        }

        /**
         * üî• TRADING 3.0 CARD RENDERER (SHARED)
         * Renders the premium card for both Generation and Active Studies views.
         */
        window.renderTrading30Card = function (o, savedStrategyId, selectedDate) {
            const m = o.match;
            const matchId = (m.partita + m.data).replace(/[^a-zA-Z0-9]/g, '');
            const savedStrat = savedStrategyId; // ID of the saved strategy unique code (e.g. 'over25') match it with s.id

            // Check for API Odds placeholders
            const api1 = m.quota1 || m.odds1 || '-';
            const apiX = m.quotaX || m.oddsX || '-';
            const api2 = m.quota2 || m.odds2 || '-';

            const strategydefs = [
                { id: 'over25', backendId: 'BACK_OVER_25', name: 'Back Over 2.5', icon: '‚öΩ', defaultIn: '@2.1-2.4', defaultOut: '@1.70' },
                { id: 'over25_2t', backendId: 'SECOND_HALF_SURGE', name: 'Gol nel 2¬∞ Tempo (Live)', icon: 'üî•', defaultIn: '@1.9-2.2', defaultOut: '@1.60' },
                { id: 'ltd', backendId: 'LAY_THE_DRAW', name: 'Lay The Draw', icon: 'üé≤', defaultIn: '@3.2-4.0', defaultOut: '@2.20' },
                { id: 'ht_sniper', backendId: 'HT_SNIPER', name: 'HT Sniper', icon: 'üéØ', defaultIn: '@1.7-2.0', defaultOut: '@1.40' },
                { id: 'scalping', backendId: 'UNDER_35_SCALPING', name: 'Scalping U3.5', icon: '‚ö°', defaultIn: '@1.4-1.6', defaultOut: '@1.20' }
            ];

            const strategiesHtml = strategydefs.map(s => {
                // 1. Logic Selection  
                // üî• Use activeStrategy as primary, fallback to strategy for legacy
                const activeStrat = o.activeStrategy || o.strategy;
                const isRecommended = activeStrat && activeStrat === s.backendId;
                const isSaved = savedStrat === s.id || savedStrat === s.backendId;

                // 2. Data Mapping - üî• FIRST check calculatedStrategies array (NEW)
                let confidence = 0;
                let reasoning = "Requisiti statistici non soddisfatti";
                let rangeIn = s.defaultIn;
                let targetOut = s.defaultOut;

                // üî• NEW: Read from calculatedStrategies if available
                if (o.match.calculatedStrategies && Array.isArray(o.match.calculatedStrategies)) {
                    const calcStrat = o.match.calculatedStrategies.find(cs => cs.type === s.backendId);
                    if (calcStrat) {
                        confidence = calcStrat.confidence || 0;
                        reasoning = typeof calcStrat.reasoning === 'object' ? (calcStrat.reasoning?.text || JSON.stringify(calcStrat.reasoning)) : (calcStrat.reasoning || reasoning);

                        // Extract Entry Range (Unpack Object)
                        if (calcStrat.entryRange) {
                            if (typeof calcStrat.entryRange === 'object' && calcStrat.entryRange.range) {
                                rangeIn = `@ ${Array.isArray(calcStrat.entryRange.range) ? calcStrat.entryRange.range.join(' - ') : calcStrat.entryRange.range}`;
                            } else {
                                rangeIn = calcStrat.entryRange;
                            }
                        }

                        // Extract Exit Target (Unpack Object)
                        if (calcStrat.exitTarget) {
                            if (typeof calcStrat.exitTarget === 'object' && calcStrat.exitTarget.target) {
                                targetOut = `@ ${calcStrat.exitTarget.target}`;
                            } else {
                                targetOut = calcStrat.exitTarget;
                            }
                        }
                    }
                }

                // Fallback: Legacy data without calculatedStrategies - use magicStats
                if (confidence === 0) {
                    const stats = o.match.magicStats || {};

                    if (s.backendId === 'BACK_OVER_25') {
                        const p = stats.over25 || 0;
                        confidence = p;
                        if (p > 0) reasoning = `Prob. Statistica Over 2.5: ${p}%`;
                    } else if (s.backendId === 'LAY_THE_DRAW') {
                        const p = stats.draw || 0;
                        confidence = 100 - p;
                        if (p > 0) reasoning = `Prob. Statistica Pareggio: ${p}% (Bassa)`;
                    } else if (s.backendId === 'SECOND_HALF_SURGE') {
                        confidence = (isRecommended) ? (o.confidence || 75) : 0;
                        if (confidence > 0) reasoning = "Attesa gol nel 2¬∞ Tempo (Statistica)";
                    } else if (s.backendId === 'HT_SNIPER') {
                        confidence = (isRecommended) ? (o.confidence || 80) : 0;
                        if (confidence > 0) reasoning = "Strategia HT Sniper";
                    } else if (s.backendId === 'UNDER_35_SCALPING') {
                        confidence = (isRecommended) ? (o.confidence || 65) : 0;
                        if (confidence > 0) reasoning = "Scalping Under 3.5";
                    } else if (isRecommended) {
                        confidence = o.confidence || 80;
                        reasoning = "Strategia Raccomandata AI";
                    }
                }

                // Determine Esito - üî• Check allStrategiesOutcomes FIRST (where outcomes are stored)
                let pOutcome = null;

                // 1. Primary: allStrategiesOutcomes (where executeOutcomeCalculation saves results)
                if (o.match.allStrategiesOutcomes) {
                    const matchStrat = o.match.allStrategiesOutcomes.find(os => os.type === s.backendId);
                    if (matchStrat && matchStrat.esito) pOutcome = matchStrat.esito;
                }

                // 2. Fallback: calculatedStrategies (if it has esito)
                if (!pOutcome && o.match.calculatedStrategies) {
                    const calcStrat = o.match.calculatedStrategies.find(cs => cs.type === s.backendId);
                    if (calcStrat && calcStrat.esito) pOutcome = calcStrat.esito;
                }

                // 3. Final fallback: direct esito on saved strategy
                if (!pOutcome && isSaved && o.match.esito) {
                    pOutcome = o.match.esito;
                }

                // Styling
                let containerClass = "bg-white border-gray-100 hover:border-indigo-100";
                let badgeHtml = "";
                let opacityClass = "opacity-100";
                let confidenceClass = confidence >= 70 ? "text-green-600" : (confidence >= 50 ? "text-yellow-600" : "text-gray-400");

                if (isRecommended) {
                    containerClass = "bg-indigo-50 border-2 border-indigo-600 ring-2 ring-indigo-200 shadow-lg z-10 transform scale-[1.02]";
                    badgeHtml = `<span class="ml-auto flex items-center gap-1 px-3 py-1 bg-indigo-600 text-white text-[10px] rounded-full font-black tracking-wider uppercase shadow-md animate-pulse">
                        <i class="fa-solid fa-rocket"></i> AI PICK
                    </span>`;
                } else if (confidence < 40) {
                    opacityClass = "opacity-70 grayscale-[30%]";
                }

                if (isSaved) {
                    containerClass = "bg-green-50 border-2 border-green-500 ring-2 ring-green-200 shadow-md z-20";
                    badgeHtml = `<span class="ml-auto flex items-center gap-1 px-3 py-1 bg-green-600 text-white text-[10px] rounded-full font-black tracking-wider uppercase shadow-md">
                        <i class="fa-solid fa-check"></i> SCELTA
                    </span>`;
                }

                const strategyElemId = `strat-${matchId}-${s.id}`;

                return `
                    <div id="${strategyElemId}" class="flex items-center p-2 rounded-lg border transition-all duration-150 group relative gap-3 ${containerClass} ${opacityClass}"
                            data-strat-type="${s.backendId}" data-ai-prob="${confidence}">
                        <!-- Icon & Confidence -->
                        <div class="w-8 h-8 rounded-full flex flex-shrink-0 items-center justify-center bg-white text-lg shadow-sm border border-gray-100">
                            ${s.icon}
                        </div>
                        
                        <!-- Main Info -->
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <div class="text-xs font-black text-gray-800 truncate">${s.name}</div>
                                ${confidence > 0 ? `<div class="text-[9px] font-bold ${confidenceClass}">(${confidence}%)</div>` : ''}
                                ${isRecommended ? badgeHtml : ''}
                            </div>
                            <div class="text-[9px] text-gray-400 truncate italic leading-tight max-w-[95%] reasoning-text">
                                ${reasoning}
                            </div>
                        </div>

                        <!-- Compact Entry/Exit -->
                        <div class="flex-col text-[10px] items-center justify-center flex min-w-[66px] leading-tight">
                            ${pOutcome ? `<span class="px-2 py-0.5 rounded-full text-white font-black uppercase text-[8px] ${pOutcome.includes('Vint') ? 'bg-green-500' : pOutcome.includes('Pers') ? 'bg-red-500' : 'bg-yellow-500'}">${pOutcome}</span>` : `
                            <span class="text-gray-400">In: <b class="text-gray-700">${rangeIn}</b></span>
                            <span class="text-gray-400">Out: <b class="text-gray-700">${targetOut}</b></span>
                            `}
                        </div>

                        <!-- Action Button -->
                        <button onclick="selectStrategy30('${matchId}', '${s.id}', this)" 
                                class="h-8 px-3 rounded-md text-[10px] font-bold uppercase tracking-wider transition-all transform active:scale-95 shadow-sm whitespace-nowrap flex items-center gap-1 min-w-[60px] justify-center
                                ${isSaved ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-white border border-gray-200 text-gray-500 hover:bg-indigo-600 hover:text-white hover:border-indigo-600'}">
                            ${isSaved ? '<i class="fa-solid fa-check"></i>' : 'USA'}
                        </button>
                    </div>
                `;
            }).join('');

            // === FULL CARD HTML ===
            return `
                <div class="w-full bg-white rounded-2xl border border-gray-200 shadow-sm hover:shadow-md transition-all overflow-hidden flex flex-col mb-4">
                    
                    <!-- HEADER & BODY -->
                    <div class="flex flex-col md:flex-row divide-y md:divide-y-0 md:divide-x divide-gray-100">
                        <!-- LEFT: INFO & STATS (35%) -->
                        <div class="md:w-[35%] p-4 bg-slate-50/50 flex flex-col gap-4">
                            <div>
                                <div class="flex justify-between items-start mb-2">
                                    <span class="px-2 py-0.5 rounded-md bg-white border border-gray-200 text-[9px] font-black text-gray-400 uppercase tracking-wider">${m.lega}</span>
                                    <div class="flex items-center gap-1 text-[10px] font-bold text-gray-400 bg-white px-2 py-0.5 rounded-full border border-gray-100">
                                        <i class="fa-regular fa-clock text-indigo-400"></i> ${m.ora || '--:--'}
                                    </div>
                                </div>
                                <h3 class="text-lg font-black text-gray-800 leading-tight tracking-tight mb-3">${m.partita}</h3>
                                
                                <!-- COMPACT STATS ROW -->
                                <div class="flex gap-2 mb-3">
                                    <div class="bg-white px-3 py-2 rounded-lg border border-gray-100 shadow-sm flex-1 text-center">
                                        <div class="text-[9px] text-gray-400 font-bold uppercase">HT | FT</div>
                                        <div class="text-lg font-black text-gray-900 leading-none mt-1">${m.risultatoHT || '0-0'} | ${m.risultato || '0-0'}</div>
                                    </div>
                                    <div class="bg-white px-3 py-2 rounded-lg border border-gray-100 shadow-sm flex-1 text-center">
                                        <div class="text-[9px] text-gray-400 font-bold uppercase">Valore AI</div>
                                            ${o.confidence ? o.confidence + '%' : '-'}
                                    </div>
                                </div>

                                <!-- SAVED STRATEGY HIDDEN INPUT -->
                                <input type="hidden" id="strat-val-${matchId}" value="${savedStrat || ''}">
                                
                                <button id="save-btn-${matchId}" onclick="confirmStrategy30('${matchId}', '${m.partita.replace(/'/g, "\\'")}', '${selectedDate}')" 
                                    class="w-full py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold text-xs transition-all shadow-md active:scale-95 ${savedStrat ? '' : 'hidden'}">
                                    <i class="fa-solid fa-save mr-1"></i> SALVA SCELTA
                                </button>
                            </div>
                            
                            <!-- 1X2 MATRIX COMPACT -->
                                <div class="mt-auto bg-white rounded-lg border border-gray-100 p-2">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="text-[9px] text-gray-300 font-bold uppercase"><i class="fa-solid fa-table-cells"></i> 1X2</span>
                                    <div class="flex gap-2 text-[9px] font-bold text-gray-400">
                                        <span class="w-8 text-center">1</span>
                                        <span class="w-8 text-center">X</span>
                                        <span class="w-8 text-center">2</span>
                                    </div>
                                </div>
                                
                                <!-- AI ROW -->
                                <div class="flex justify-between items-center mb-1">
                                    <span class="text-[9px] text-purple-500 font-black">AI%</span>
                                    <div class="flex gap-2 text-[10px]">
                                        <span class="w-8 text-center bg-purple-50 text-purple-700 rounded py-0.5 font-bold">${o.match.magicStats?.winHome || 0}</span>
                                        <span class="w-8 text-center bg-purple-50 text-purple-700 rounded py-0.5 font-bold">${o.match.magicStats?.draw || 0}</span>
                                        <span class="w-8 text-center bg-purple-50 text-purple-700 rounded py-0.5 font-bold">${o.match.magicStats?.winAway || 0}</span>
                                    </div>
                                </div>
                                <!-- BF ROW -->
                                <div class="flex justify-between items-center">
                                    <span class="text-[9px] text-green-500 font-black">BF</span>
                                    <div class="flex gap-2 text-[10px]">
                                        <span id="odds-1-${matchId}" class="w-8 text-center bg-green-50 text-green-700 rounded py-0.5 font-mono font-bold">${api1}</span>
                                        <span id="odds-x-${matchId}" class="w-8 text-center bg-green-50 text-green-700 rounded py-0.5 font-mono font-bold">${apiX}</span>
                                        <span id="odds-2-${matchId}" class="w-8 text-center bg-green-50 text-green-700 rounded py-0.5 font-mono font-bold">${api2}</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- RIGHT: COMPACT STRATEGIES (65%) -->
                        <div class="md:w-[65%] p-4 bg-white">
                            <div class="flex items-center gap-2 mb-3">
                                <span class="w-1.5 h-1.5 rounded-full bg-indigo-500"></span>
                                <h4 class="text-[10px] font-black text-gray-400 uppercase tracking-widest">Strategie Operative</h4>
                            </div>
                            
                            <div class="flex flex-col gap-1.5 js-strategies-container">
                                ${strategiesHtml}
                            </div>
                        </div>
                    </div>

                    <!-- FOOTER: EXTRA ODDS (CORRECTED GRID) -->
                    <div class="grid grid-cols-12 border-t border-gray-100 bg-slate-50/30 p-2 gap-2">
                        <!-- DC & GG (Col 1-5) -->
                        <div class="col-span-5 grid grid-cols-2 gap-2 border-r border-gray-200 pr-2">
                            <div class="flex flex-col gap-1">
                                <span class="text-[8px] font-black text-gray-400 uppercase tracking-widest">Doppia Chance</span>
                                <div id="odds-dc-${matchId}" class="flex flex-wrap gap-1 text-[8px] font-mono">
                                    <span class="text-gray-300 italic">...</span>
                                </div>
                            </div>
                            <div class="flex flex-col gap-1">
                                <span class="text-[8px] font-black text-gray-400 uppercase tracking-widest">GG/NG</span>
                                <div id="odds-gg-${matchId}" class="flex flex-wrap gap-1 text-[8px] font-mono">
                                    <span class="text-gray-300 italic">...</span>
                                </div>
                            </div>
                        </div>

                        <!-- O/U (Col 6-9) -->
                        <div class="col-span-4 border-r border-gray-200 pr-2">
                            <div class="flex flex-col gap-1">
                                <span class="text-[8px] font-black text-gray-400 uppercase tracking-widest">Over / Under</span>
                                <div id="odds-ou-${matchId}" class="text-[8px] text-gray-400 italic font-mono">
                                    Loading...
                                </div>
                            </div>
                        </div>

                        <!-- CS (Col 10-12) -->
                        <div class="col-span-3">
                            <div class="flex flex-col gap-1">
                                <span class="text-[8px] font-black text-gray-400 uppercase tracking-widest">CS (LTD)</span>
                                <div id="odds-cs-${matchId}" class="grid grid-cols-2 gap-1 text-[8px] font-mono">
                                      <!-- Will be populated by JS -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        };

        async function loadOpportunities30() {
            const selectedDate = datePicker30?.value || new Date().toISOString().split('T')[0];
            const grid = document.getElementById('trading-30-opportunities-grid');
            const section = document.getElementById('trading-30-opportunities-section');
            if (!grid) return;

            // Updated grid layout
            grid.className = "grid grid-cols-1 xl:grid-cols-2 gap-6";

            grid.innerHTML = `<div class="col-span-full py-10 text-center text-gray-400 italic">Analisi opportunit√† in corso...</div>`;
            section.classList.remove('hidden');

            try {
                // 1. Get matches
                let matchesToProcess = window.allMatches?.filter(m => m.data === selectedDate) || [];

                // 2. Get existing picks FIRST
                const docRef = doc(db, "daily_trading_picks", selectedDate);
                const docSnap = await getDoc(docRef);
                const dailyPicks = docSnap.exists() ? (docSnap.data().picks || []) : [];
                const savedMap = new Map();
                dailyPicks.forEach(p => savedMap.set(p.partita, p.strategy));

                // 3. Filter Process
                matchesToProcess = matchesToProcess.filter(m => {
                    // Always include if saved
                    if (savedMap.has(m.partita)) return true;

                    const normLega = (window.normalizeLega(m.lega) || "").toLowerCase();
                    return TOP_LEAGUES_30.some(top => normLega.includes(top.toLowerCase()));
                });

                if (matchesToProcess.length === 0) {
                    grid.innerHTML = `<div class="col-span-full py-10 text-center text-gray-500">Nessuna partita rilevante per oggi.</div>`;
                    return;
                }

                // 4. Transform matches - USE SAVED PICKS FROM FIRESTORE (they have strategy field!)
                // 4. Transform matches - Use matchesToProcess as base, merge with dailyPicks if present
                const opportunities = matchesToProcess.map(m => {
                    // Find saved pick if exists
                    const pick = dailyPicks.find(p => p.partita === m.partita);

                    // If pick exists, use it to override match data (it has strategy, confidence, calculatedStrategies, etc.)
                    // Otherwise use 'm' as is.
                    const finalMatch = pick ? { ...m, ...pick } : m;

                    return {
                        match: finalMatch,
                        magicStats: finalMatch.magicStats || m.magicStats || null,
                        aiStrategies: [],
                        // üî• Pass activeStrategy AND legacy strategy
                        activeStrategy: pick?.activeStrategy || finalMatch.activeStrategy || null,
                        strategy: pick?.strategy || finalMatch.strategy || null,
                        confidence: pick?.confidence || finalMatch.confidence || 0
                    };
                }).filter(o => o !== null);

                if (opportunities.length === 0) {
                    grid.innerHTML = `<div class="col-span-full py-10 text-center text-gray-500 italic">Nessuna opportunit√† rilevante trovata.</div>`;
                    return;
                }

                // Sort: Saved first, then by confidence
                opportunities.sort((a, b) => {
                    const savedA = savedMap.has(a.match.partita) ? 1 : 0;
                    const savedB = savedMap.has(b.match.partita) ? 1 : 0;
                    if (savedA !== savedB) return savedB - savedA; // Saved on top

                    const maxA = a.aiStrategies.length > 0 ? Math.max(...a.aiStrategies.map(s => s.confidence)) : 0;
                    const maxB = b.aiStrategies.length > 0 ? Math.max(...b.aiStrategies.map(s => s.confidence)) : 0;
                    return maxB - maxA;
                });

                // FORCE SINGLE COLUMN LAYOUT
                grid.className = "flex flex-col gap-8 w-full max-w-5xl mx-auto px-4";

                // üî• RENDER CARDS USING SHARED HELPER
                grid.innerHTML = opportunities.map(o => {
                    const m = o.match;
                    if (!m.magicStats && o.magicStats) m.magicStats = o.magicStats;
                    const savedStrat = savedMap.get(m.partita);
                    return window.renderTrading30Card(o, savedStrat, selectedDate);
                }).join('');

                /* OLD RENDER LOGIC (REPLACED)
                grid.innerHTML = opportunities.map(o => {
                    const m = o.match;
                    const matchId = (m.partita + m.data).replace(/[^a-zA-Z0-9]/g, '');
                    const savedStrat = savedMap.get(m.partita);
 
                    // Calc History Stats
                    const statsHome = calculateLast5Stats(m.casa, m.data, window.allMatches || []);
                    const statsAway = calculateLast5Stats(m.trasferta, m.data, window.allMatches || []);
 
                    // Check for API Odds placeholders
                    const api1 = m.quota1 || m.odds1 || '-';
                    const apiX = m.quotaX || m.oddsX || '-';
                    const api2 = m.quota2 || m.odds2 || '-';
 
                    // === STRATEGIES GENERATION (STAGE 1: STATISTICAL BASE) ===
                    // Use VALID data from Firestore (Night/Morning calculation)
                    // We will enhance this with Betfair Odds in Stage 2 (Async)
 
                    const strategydefs = [
                        { id: 'over25', backendId: 'BACK_OVER_25', name: 'Back Over 2.5', icon: '‚öΩ', defaultIn: '@2.1-2.4', defaultOut: '@1.70' },
                        { id: 'over25_2t', backendId: 'SECOND_HALF_SURGE', name: 'Gol nel 2¬∞ Tempo (Live)', icon: 'üî•', defaultIn: '@1.9-2.2', defaultOut: '@1.60' },
                        { id: 'ltd', backendId: 'LAY_THE_DRAW', name: 'Lay The Draw', icon: 'üé≤', defaultIn: '@3.2-4.0', defaultOut: '@2.20' },
                        { id: 'ht_sniper', backendId: 'HT_SNIPER', name: 'HT Sniper', icon: 'üéØ', defaultIn: '@1.7-2.0', defaultOut: '@1.40' },
                        { id: 'scalping', backendId: 'UNDER_35_SCALPING', name: 'Scalping U3.5', icon: '‚ö°', defaultIn: '@1.4-1.6', defaultOut: '@1.20' }
                    ];
 
                    const strategiesHtml = strategydefs.map(s => {
                        // 1. Logic Selection (Based on saved data)
                        // üî• Use activeStrategy as primary, fallback to strategy for legacy
                        const activeStrat = o.activeStrategy || o.strategy;
                        const isRecommended = activeStrat && activeStrat === s.backendId;
                        const isSaved = savedStrat === s.id || savedStrat === s.backendId;
 
                        // 2. Data Mapping - üî• FIRST check calculatedStrategies array (NEW)
                        let confidence = 0;
                        let reasoning = "Requisiti statistici non soddisfatti";
                        let entryRange = s.defaultIn;
                        let exitTarget = s.defaultOut;
 
                        // üî• NEW: Read from calculatedStrategies if available
                        if (o.match.calculatedStrategies && Array.isArray(o.match.calculatedStrategies)) {
                            const calcStrat = o.match.calculatedStrategies.find(cs => cs.type === s.backendId);
                            if (calcStrat) {
                                confidence = calcStrat.confidence || 0;
                                reasoning = calcStrat.reasoning || reasoning;
                                if (calcStrat.entryRange) entryRange = calcStrat.entryRange;
                                if (calcStrat.exitTarget) exitTarget = calcStrat.exitTarget;
                            }
                        }
                        
                        // Fallback: Legacy data without calculatedStrategies - use magicStats
                        if (confidence === 0) {
                            const stats = o.match.magicStats || {};
 
                            if (s.backendId === 'BACK_OVER_25') {
                                const p = stats.over25 || 0;
                                confidence = p;
                                if (p > 0) reasoning = `Prob. Statistica Over 2.5: ${p}%`;
                            } else if (s.backendId === 'LAY_THE_DRAW') {
                                const p = stats.draw || 0;
                                confidence = 100 - p;
                                if (p > 0) reasoning = `Prob. Statistica Pareggio: ${p}% (Bassa)`;
                            } else if (s.backendId === 'SECOND_HALF_SURGE') {
                                confidence = (isRecommended) ? (o.confidence || 75) : 0;
                                if (confidence > 0) reasoning = "Attesa gol nel 2¬∞ Tempo (Statistica)";
                            } else if (s.backendId === 'HT_SNIPER') {
                                // üî• FIX: Now HT_SNIPER has its own calculation path
                                confidence = (isRecommended) ? (o.confidence || 80) : 0;
                                if (confidence > 0) reasoning = "Strategia HT Sniper";
                            } else if (s.backendId === 'UNDER_35_SCALPING') {
                                confidence = (isRecommended) ? (o.confidence || 65) : 0;
                                if (confidence > 0) reasoning = "Scalping Under 3.5";
                            } else if (isRecommended) {
                                confidence = o.confidence || 80;
                                reasoning = "Strategia Raccomandata AI";
                            }
                        }
 
                        // Determine Esito for this strategy if it's the one chosen (or if we have all outcomes)
                        let pOutcome = null;
                        if (isRecommended && o.match.esito) {
                            pOutcome = o.match.esito;
                        } else if (o.match.allStrategiesOutcomes) {
                            const matchStrat = o.match.allStrategiesOutcomes.find(os => os.type === s.backendId);
                            if (matchStrat) pOutcome = matchStrat.esito;
                        }
 
                        // Costruisci le info di Entry/Exit (Statiche per ora)
                        let rangeIn = s.defaultIn;
                        let targetOut = s.defaultOut;
 
                        // Styling
                        let containerClass = "bg-white border-gray-100 hover:border-indigo-100";
                        let badgeHtml = "";
                        let opacityClass = "opacity-100";
                        let confidenceClass = confidence >= 70 ? "text-green-600" : (confidence >= 50 ? "text-yellow-600" : "text-gray-400");
 
                        if (isRecommended) {
                            containerClass = "bg-indigo-50 border-2 border-indigo-600 ring-2 ring-indigo-200 shadow-lg z-10 transform scale-[1.02]";
                            badgeHtml = `<span class="ml-auto flex items-center gap-1 px-3 py-1 bg-indigo-600 text-white text-[10px] rounded-full font-black tracking-wider uppercase shadow-md animate-pulse">
                                <i class="fa-solid fa-rocket"></i> AI PICK
                            </span>`;
                        } else if (confidence < 40) {
                            opacityClass = "opacity-70 grayscale-[30%]";
                        }
 
                        if (isSaved) {
                            containerClass = "bg-green-50 border-2 border-green-500 ring-2 ring-green-200 shadow-md z-20";
                            badgeHtml = `<span class="ml-auto flex items-center gap-1 px-3 py-1 bg-green-600 text-white text-[10px] rounded-full font-black tracking-wider uppercase shadow-md">
                                <i class="fa-solid fa-check"></i> SCELTA
                            </span>`;
                        }
 
                        // ID univoco per aggiornamento LIVE (Stage 2)
                        const strategyElemId = `strat-${matchId}-${s.id}`;
 
                        return `
                            <div id="${strategyElemId}" class="flex items-center p-2 rounded-lg border transition-all duration-150 group relative gap-3 ${containerClass} ${opacityClass}"
                                 data-strat-type="${s.backendId}" data-ai-prob="${confidence}">
                                <!-- Icon & Confidence -->
                                <div class="w-8 h-8 rounded-full flex flex-shrink-0 items-center justify-center bg-white text-lg shadow-sm border border-gray-100">
                                    ${s.icon}
                                </div>
                                
                                <!-- Main Info -->
                                <div class="flex-1 min-w-0">
                                    <div class="flex items-center gap-2">
                                        <div class="text-xs font-black text-gray-800 truncate">${s.name}</div>
                                        ${confidence > 0 ? `<div class="text-[9px] font-bold ${confidenceClass}">(${confidence}%)</div>` : ''}
                                        ${isRecommended ? badgeHtml : ''}
                                    </div>
                                    <div class="text-[9px] text-gray-400 truncate italic leading-tight max-w-[95%] reasoning-text">
                                        ${reasoning}
                                    </div>
                                </div>
 
                                <!-- Compact Entry/Exit -->
                                <div class="flex-col text-[10px] items-center justify-center flex min-w-[66px] leading-tight">
                                    ${pOutcome ? `<span class="px-2 py-0.5 rounded-full text-white font-black uppercase text-[8px] ${pOutcome.includes('Vint') ? 'bg-green-500' : pOutcome.includes('Pers') ? 'bg-red-500' : 'bg-yellow-500'}">${pOutcome}</span>` : `
                                    <span class="text-gray-400">In: <b class="text-gray-700">${rangeIn}</b></span>
                                    <span class="text-gray-400">Out: <b class="text-gray-700">${targetOut}</b></span>
                                    `}
                                </div>
 
                                <!-- Action Button -->
                                <button onclick="selectStrategy30('${matchId}', '${s.id}', this)" 
                                        class="h-8 px-3 rounded-md text-[10px] font-bold uppercase tracking-wider transition-all transform active:scale-95 shadow-sm whitespace-nowrap flex items-center gap-1 min-w-[60px] justify-center
                                        ${isSaved ? 'bg-green-600 text-white hover:bg-green-700' : 'bg-white border border-gray-200 text-gray-500 hover:bg-indigo-600 hover:text-white hover:border-indigo-600'}">
                                    ${isSaved ? '<i class="fa-solid fa-check"></i>' : 'USA'}
                                </button>
                            </div>
                        `;
                    }).join('');
 
                    // === FULL CARD HTML ===
                    return `
                        <div class="w-full bg-white rounded-2xl border border-gray-200 shadow-sm hover:shadow-md transition-all overflow-hidden flex flex-col mb-4">
                            
                            <!-- HEADER & BODY -->
                            <div class="flex flex-col md:flex-row divide-y md:divide-y-0 md:divide-x divide-gray-100">
                                <!-- LEFT: INFO & STATS (35%) -->
                                <div class="md:w-[35%] p-4 bg-slate-50/50 flex flex-col gap-4">
                                    <div>
                                        <div class="flex justify-between items-start mb-2">
                                            <span class="px-2 py-0.5 rounded-md bg-white border border-gray-200 text-[9px] font-black text-gray-400 uppercase tracking-wider">${m.lega}</span>
                                            <div class="flex items-center gap-1 text-[10px] font-bold text-gray-400 bg-white px-2 py-0.5 rounded-full border border-gray-100">
                                                <i class="fa-regular fa-clock text-indigo-400"></i> ${m.ora || '--:--'}
                                            </div>
                                        </div>
                                        <h3 class="text-lg font-black text-gray-800 leading-tight tracking-tight mb-3">${m.partita}</h3>
                                        
                                        <!-- COMPACT STATS ROW -->
                                        <div class="flex gap-2 mb-3">
                                            <div class="bg-white px-3 py-2 rounded-lg border border-gray-100 shadow-sm flex-1 text-center">
                                                <div class="text-[9px] text-gray-400 font-bold uppercase">HT | FT</div>
                                                <div class="text-lg font-black text-gray-900 leading-none mt-1">${m.risultatoHT || '0-0'} | ${m.risultato || '0-0'}</div>
                                            </div>
                                            <div class="bg-white px-3 py-2 rounded-lg border border-gray-100 shadow-sm flex-1 text-center">
                                                <div class="text-[9px] text-gray-400 font-bold uppercase">Valore AI</div>
                                                <div class="text-lg font-black text-emerald-500 leading-none mt-1">
                                                    ${o.magicStats?.over25Prob ? o.magicStats.over25Prob + '%' : '-'}
                                                </div>
                                            </div>
                                        </div>
 
                                        <!-- SAVED STRATEGY HIDDEN INPUT -->
                                        <input type="hidden" id="strat-val-${matchId}" value="${savedStrat || ''}">
                                        
                                        <button id="save-btn-${matchId}" onclick="confirmStrategy30('${matchId}', '${m.partita.replace(/'/g, "\\'")}', '${selectedDate}')" 
                                            class="w-full py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold text-xs transition-all shadow-md active:scale-95 ${savedStrat ? '' : 'hidden'}">
                                            <i class="fa-solid fa-save mr-1"></i> SALVA SCELTA
                                        </button>
                                    </div>
                                    
                                    <!-- 1X2 MATRIX COMPACT -->
                                     <div class="mt-auto bg-white rounded-lg border border-gray-100 p-2">
                                        <div class="flex justify-between items-center mb-2">
                                            <span class="text-[9px] text-gray-300 font-bold uppercase"><i class="fa-solid fa-table-cells"></i> 1X2</span>
                                            <div class="flex gap-2 text-[9px] font-bold text-gray-400">
                                                <span class="w-8 text-center">1</span>
                                                <span class="w-8 text-center">X</span>
                                                <span class="w-8 text-center">2</span>
                                            </div>
                                        </div>
                                        
                                        <!-- AI ROW -->
                                        <div class="flex justify-between items-center mb-1">
                                            <span class="text-[9px] text-purple-500 font-black">AI%</span>
                                            <div class="flex gap-2 text-[10px]">
                                                <span class="w-8 text-center bg-purple-50 text-purple-700 rounded py-0.5 font-bold">${o.magicStats?.winHome || 0}</span>
                                                <span class="w-8 text-center bg-purple-50 text-purple-700 rounded py-0.5 font-bold">${o.magicStats?.draw || 0}</span>
                                                <span class="w-8 text-center bg-purple-50 text-purple-700 rounded py-0.5 font-bold">${o.magicStats?.winAway || 0}</span>
                                            </div>
                                        </div>
                                        <!-- BF ROW -->
                                        <div class="flex justify-between items-center">
                                            <span class="text-[9px] text-green-500 font-black">BF</span>
                                            <div class="flex gap-2 text-[10px]">
                                                <span id="odds-1-${matchId}" class="w-8 text-center bg-green-50 text-green-700 rounded py-0.5 font-mono font-bold">${api1}</span>
                                                <span id="odds-x-${matchId}" class="w-8 text-center bg-green-50 text-green-700 rounded py-0.5 font-mono font-bold">${apiX}</span>
                                                <span id="odds-2-${matchId}" class="w-8 text-center bg-green-50 text-green-700 rounded py-0.5 font-mono font-bold">${api2}</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
 
                                <!-- RIGHT: COMPACT STRATEGIES (65%) -->
                                <div class="md:w-[65%] p-4 bg-white">
                                    <div class="flex items-center gap-2 mb-3">
                                        <span class="w-1.5 h-1.5 rounded-full bg-indigo-500"></span>
                                        <h4 class="text-[10px] font-black text-gray-400 uppercase tracking-widest">Strategie Operative</h4>
                                    </div>
                                    
                                    <div class="flex flex-col gap-1.5 js-strategies-container">
                                        ${strategiesHtml}
                                    </div>
                                </div>
                            </div>
 
                            <!-- FOOTER: EXTRA ODDS (CORRECTED GRID) -->
                            <div class="grid grid-cols-12 border-t border-gray-100 bg-slate-50/30 p-2 gap-2">
                                <!-- DC & GG (Col 1-5) -->
                                <div class="col-span-5 grid grid-cols-2 gap-2 border-r border-gray-200 pr-2">
                                    <div class="flex flex-col gap-1">
                                        <span class="text-[8px] font-black text-gray-400 uppercase tracking-widest">Doppia Chance</span>
                                        <div id="odds-dc-${matchId}" class="flex flex-wrap gap-1 text-[8px] font-mono">
                                            <span class="text-gray-300 italic">...</span>
                                        </div>
                                    </div>
                                    <div class="flex flex-col gap-1">
                                        <span class="text-[8px] font-black text-gray-400 uppercase tracking-widest">GG/NG</span>
                                        <div id="odds-gg-${matchId}" class="flex flex-wrap gap-1 text-[8px] font-mono">
                                            <span class="text-gray-300 italic">...</span>
                                        </div>
                                    </div>
                                </div>
 
                                <!-- O/U (Col 6-9) -->
                                <div class="col-span-4 flex flex-col gap-1 border-r border-gray-200 pr-2">
                                    <span class="text-[8px] font-black text-gray-400 uppercase tracking-widest">Over / Under</span>
                                    <div class="flex gap-2 text-[9px] font-mono text-gray-700" id="odds-ou-${matchId}">
                                        <span class="text-gray-300 italic">Loading...</span>
                                    </div>
                                </div>
 
                                <!-- CS (Col 10-12) -->
                                <div class="col-span-3 flex flex-col gap-1">
                                    <span class="text-[8px] font-black text-gray-400 uppercase tracking-widest">CS (LTD)</span>
                                    <div class="flex gap-2 text-[9px] font-mono text-gray-700" id="odds-cs-${matchId}">
                                        <span class="text-gray-300 italic">...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join(''); 
                */

                // POST-RENDER: Fetch Odds Logic with DEBUGGING
                setTimeout(() => {
                    opportunities.forEach(o => {
                        const m = o.match;
                        const matchId = (m.partita + m.data).replace(/[^a-zA-Z0-9]/g, '');

                        if (m.fixtureId) {
                            // Find cached full response if available or re-fetch logic handled by getOddsFromAPI
                            // But here we need to call it if we don't have stored odds

                            getOddsFromAPI(m.fixtureId).then(oddsData => {
                                if (oddsData) {
                                    const selectedBook = oddsData.find(b => b.name.includes('Betfair')) || oddsData[0];

                                    if (selectedBook && selectedBook.bets) {
                                        console.log(`[Odds Debug] ${m.partita}: Primary book ${selectedBook.name} has ${selectedBook.bets.length} markets`);

                                        // Helper to find a bet in ANY bookmaker if missing in selectedBook
                                        const findBet = (betName) => {
                                            // Try selected book first
                                            let bet = selectedBook.bets.find(b => b.name === betName || b.name.includes(betName));
                                            if (bet) return bet;

                                            // Fallback: search across all books
                                            for (const book of oddsData) {
                                                bet = book.bets.find(b => b.name === betName || b.name.includes(betName));
                                                if (bet) {
                                                    console.log(`[Odds Fallback] Found ${betName} via ${book.name} for ${m.partita}`);
                                                    return bet;
                                                }
                                            }
                                            return null;
                                        };

                                        // 1X2 Update
                                        const matchWinner = findBet('Match Winner');
                                        if (matchWinner) {
                                            const v = matchWinner.values;
                                            const o1 = v.find(x => x.value == 'Home')?.odd;
                                            const oX = v.find(x => x.value == 'Draw')?.odd;
                                            const o2 = v.find(x => x.value == 'Away')?.odd;
                                            if (o1) document.getElementById(`odds-1-${matchId}`).innerText = o1;
                                            if (oX) document.getElementById(`odds-x-${matchId}`).innerText = oX;
                                            if (o2) document.getElementById(`odds-2-${matchId}`).innerText = o2;
                                        }

                                        // Double Chance
                                        const dcBet = findBet('Double Chance');
                                        if (dcBet) {
                                            const dcHtml = dcBet.values.map(v => `<span class="px-1.5 py-0.5 bg-white rounded border border-gray-200 font-bold">${v.value}: ${v.odd}</span>`).join('');
                                            document.getElementById(`odds-dc-${matchId}`).innerHTML = dcHtml;
                                        }

                                        // Both Teams Score
                                        const ggBet = findBet('Both Teams Score');
                                        if (ggBet) {
                                            const ggHtml = ggBet.values.map(v => {
                                                const color = v.value === 'Yes' ? 'bg-green-100 text-green-700 border-green-200' : 'bg-red-50 text-red-700 border-red-100';
                                                return `<span class="px-2 py-0.5 rounded border ${color} font-bold">${v.value === 'Yes' ? 'Si' : 'No'}: ${v.odd}</span>`;
                                            }).join('');
                                            document.getElementById(`odds-gg-${matchId}`).innerHTML = ggHtml;
                                        }

                                        // Over/Under
                                        const ouBets = selectedBook.bets.filter(b => b.name.includes('Goals Over/Under'));
                                        if (ouBets.length > 0) {
                                            let ouHtml = '';
                                            ['1.5', '2.5', '3.5'].forEach(line => {
                                                const bet = ouBets.find(b => b.name.includes(line));
                                                if (bet) {
                                                    const over = bet.values.find(v => v.value.includes('Over'))?.odd;
                                                    const under = bet.values.find(v => v.value.includes('Under'))?.odd;
                                                    if (over && under) {
                                                        ouHtml += `
                                                            <div class="flex flex-col items-center bg-white border border-gray-200 rounded px-2 py-1 shadow-sm">
                                                                <span class="text-[8px] font-black text-gray-400 mb-0.5">${line}</span>
                                                                <div class="flex gap-2 text-[9px] font-mono font-bold">
                                                                    <span class="text-blue-600">O:${over}</span>
                                                                    <span class="text-red-500">U:${under}</span>
                                                                </div>
                                                            </div>
                                                        `;
                                                    }
                                                }
                                            });
                                            if (ouHtml) document.getElementById(`odds-ou-${matchId}`).innerHTML = ouHtml;
                                        }

                                        // Correct Score
                                        const csBet = findBet('Exact Score') || findBet('Correct Score');
                                        if (csBet) {
                                            const targets = ['1:0', '0:1', '1:1', '2:0', '0:2', '0:0'];
                                            let csHtml = '';
                                            targets.forEach(score => {
                                                const val = csBet.values.find(v => v.value === score || v.value === score.replace(':', '-'));
                                                if (val) {
                                                    csHtml += `<div class="flex flex-col items-center bg-indigo-50 border border-indigo-100 rounded px-2 py-1"><span class="text-[8px] font-bold text-indigo-400">${score}</span><span class="text-[10px] font-black text-indigo-700">@${val.odd}</span></div>`;
                                                }
                                            });
                                            if (csHtml) document.getElementById(`odds-cs-${matchId}`).innerHTML = `<div class="flex flex-wrap gap-1">${csHtml}</div>`;
                                        }
                                    }
                                }
                            });
                        }
                    });
                }, 100);

            } catch (e) {
                console.error('[Opportunities] Error:', e);
                grid.innerHTML = `<div class="col-span-full py-10 text-center text-red-500">Errore: ${e.message}</div>`;
            }
        }

        // Global functions for selection
        window.selectStrategy30 = function (matchId, stratId, btn) {
            // Update hidden input
            document.getElementById(`strat-val-${matchId}`).value = stratId;

            // FIX: Find closest JS container instead of wrong 'grid' class
            const container = btn.closest('.js-strategies-container');
            if (container) {
                // Reset all buttons visual state
                container.querySelectorAll('button').forEach(b => {
                    b.className = "w-full py-2 rounded-lg text-xs font-bold uppercase tracking-wider transition-all transform active:scale-95 shadow-sm flex items-center justify-center gap-2 bg-white border border-gray-300 text-gray-600 hover:bg-indigo-600 hover:text-white hover:border-indigo-600";
                    b.innerHTML = 'USA <i class="fa-solid fa-chevron-right text-[10px] opacity-60"></i>';

                    // Reset card style
                    const card = b.closest('.group');
                    if (card) {
                        card.className = card.className
                            .replace('bg-green-50', 'bg-white')
                            .replace('border-green-500', 'border-gray-100')
                            .replace('ring-2', '')
                            .replace('ring-green-200', '');
                    }
                });

                // Highlight selected button
                btn.className = "w-full py-2 rounded-lg text-xs font-bold uppercase tracking-wider transition-all transform active:scale-95 shadow-sm flex items-center justify-center gap-2 bg-green-600 text-white hover:bg-green-700 shadow-green-200";
                btn.innerHTML = '<i class="fa-solid fa-check"></i> SCELTA';

                // Highlight selected card
                const card = btn.closest('.group');
                if (card) {
                    card.classList.remove('bg-white', 'border-gray-100');
                    card.classList.add('bg-green-50', 'border-green-500', 'ring-2', 'ring-green-200');
                }
            }

            // Show Save Button
            const saveBtn = document.getElementById(`save-btn-${matchId}`);
            if (saveBtn) saveBtn.classList.remove('hidden');
        };

        window.selectStrategyCard30 = function (matchId, stratType, cardEl) { /* Deprecated but kept for safety */ };

        window.confirmStrategy30 = async function (matchId, partitaName, date) {
            const stratType = document.getElementById(`strat-val-${matchId}`).value;
            if (!stratType) {
                alert("Seleziona una strategia prima di confermare!");
                return;
            }

            try {
                const btn = event.currentTarget;
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Salvataggio...';

                const docRef = doc(db, "daily_trading_picks", date);
                const docSnap = await getDoc(docRef);
                let currentPicks = docSnap.exists() ? (docSnap.data().picks || []) : [];

                // üî• Find the existing pick - we will UPDATE it, not replace
                const existingPickIndex = currentPicks.findIndex(p => p.partita === partitaName);

                if (existingPickIndex === -1) {
                    throw new Error("Pick non trovato. Rigenera lo studio prima di salvare.");
                }

                const existingPick = currentPicks[existingPickIndex];

                // üî• Get confidence from the saved calculatedStrategies array
                let newConfidence = 0;
                if (existingPick.calculatedStrategies && Array.isArray(existingPick.calculatedStrategies)) {
                    const selectedStrat = existingPick.calculatedStrategies.find(s =>
                        s.type === stratType || s.type === stratType.toUpperCase()
                    );
                    if (selectedStrat) {
                        newConfidence = selectedStrat.confidence || 0;
                    }
                }

                // Fallback: if calculatedStrategies not present (legacy data), use old logic
                if (newConfidence === 0) {
                    const magicStats = existingPick.magicStats || {};
                    if (stratType === 'BACK_OVER_25' || stratType === 'over25') {
                        newConfidence = magicStats.over25 || 0;
                    } else if (stratType === 'LAY_THE_DRAW' || stratType === 'ltd') {
                        newConfidence = magicStats.draw ? (100 - magicStats.draw) : 0;
                    } else if (stratType === 'HT_SNIPER' || stratType === 'ht_sniper') {
                        newConfidence = 80;
                    } else if (stratType === 'SECOND_HALF_SURGE' || stratType === 'over25_2t') {
                        newConfidence = 75;
                    } else if (stratType === 'UNDER_35_SCALPING' || stratType === 'scalping') {
                        newConfidence = magicStats.under35 || 65;
                    }
                }

                // üî• UPDATE only the active selection fields - preserve everything else!

                // üîß ID MAPPING: Short ID (from UI button) -> Backend ID (in calculatedStrategies)
                const idMapping = {
                    'over25': 'BACK_OVER_25',
                    'over25_2t': 'SECOND_HALF_SURGE',
                    'ltd': 'LAY_THE_DRAW',
                    'ht_sniper': 'HT_SNIPER',
                    'scalping': 'UNDER_35_SCALPING'
                };
                const backendId = idMapping[stratType] || stratType.toUpperCase();

                const selectedStratData = existingPick.calculatedStrategies?.find(s => s.type === backendId);

                // üêû DEBUG: Log what we're about to save
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('[confirmStrategy30] üêû DEBUG SAVE (NEW TEMPLATE-BASED)');
                console.log('[confirmStrategy30] Match:', partitaName);
                console.log('[confirmStrategy30] Backend ID:', backendId);
                console.log('[confirmStrategy30] Found in calculatedStrategies?', !!selectedStratData);
                console.log('[confirmStrategy30] selectedStratData:', selectedStratData);

                // üêû DEBUG: Check which fields are undefined in existingPick
                const fieldsToCheck = ['partita', 'fixtureId', 'lega', 'ora', 'data', 'home', 'away', 'homeLogo', 'awayLogo', 'quota', 'quota1', 'quotaX', 'quota2', 'magicStats', 'calculatedStrategies'];
                const undefinedFields = fieldsToCheck.filter(f => existingPick[f] === undefined);
                if (undefinedFields.length > 0) {
                    console.warn('[confirmStrategy30] ‚ö†Ô∏è UNDEFINED FIELDS in existingPick:', undefinedFields);
                    console.log('[confirmStrategy30] Full existingPick object:', existingPick);
                } else {
                    console.log('[confirmStrategy30] ‚úÖ All fields present in existingPick');
                }

                // üì¶ SIMPLIFIED: Use only .strategy (single source of truth)
                currentPicks[existingPickIndex] = {
                    ...existingPick,  // Preserve ALL existing fields

                    // üî• SINGLE FIELD: User's choice overwrites Engine's choice
                    strategy: backendId,
                    confidence: newConfidence,
                    entryRange: selectedStratData?.entryRange || existingPick.entryRange || null,
                    exitTarget: selectedStratData?.exitTarget || existingPick.exitTarget || null,

                    // üîß FIX: Handle reasoning object properly - never undefined!
                    reasoning: (() => {
                        const r = selectedStratData?.reasoning;
                        if (!r) return existingPick.reasoning || null;
                        if (typeof r === 'string') return r;
                        if (typeof r === 'object') return r.text || r.summary || JSON.stringify(r);
                        return null;
                    })(),

                    // Remove old tradingInstruction to clean up (optional, can keep for legacy)
                    // tradingInstruction: undefined, // Don't do this - causes the error!

                    lastModified: new Date().toISOString()
                };

                console.log('[confirmStrategy30] üì¶ FINAL OBJECT (Template-Based):', currentPicks[existingPickIndex]);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // üêû DEEP DEBUG: Find ALL undefined values in the entire picks array
                const findUndefined = (obj, path = '') => {
                    const results = [];
                    for (const key in obj) {
                        const fullPath = path ? `${path}.${key}` : key;
                        if (obj[key] === undefined) {
                            results.push(fullPath);
                        } else if (obj[key] && typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
                            results.push(...findUndefined(obj[key], fullPath));
                        }
                    }
                    return results;
                };

                currentPicks.forEach((pick, idx) => {
                    const undefs = findUndefined(pick);
                    if (undefs.length > 0) {
                        console.error(`[confirmStrategy30] ‚ùå Pick #${idx} (${pick.partita}) has UNDEFINED values at:`, undefs);
                    }
                });

                await setDoc(docRef, {
                    lastUpdated: new Date().toISOString(),
                    picks: currentPicks
                }, { merge: true });

                btn.innerHTML = '<i class="fa-solid fa-check"></i> SALVATO!';
                btn.classList.replace('bg-indigo-600', 'bg-green-600');

                console.log(`[confirmStrategy30] ‚úÖ Salvato .strategy: ${stratType} ‚Üí ${backendId} (confidence: ${newConfidence})`);

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.classList.replace('bg-green-600', 'bg-indigo-600');

                    // üé® UI FIX: Immediate visual update without waiting for reload
                    const container = document.getElementById(`strategies-container-${matchId}`);
                    if (container) {
                        // 1. Remove 'selected' style from ALL cards
                        container.querySelectorAll('.border-green-500').forEach(el => {
                            el.classList.remove('border-green-500', 'bg-green-50');
                            el.classList.add('border-gray-200');
                        });

                        // 2. Remove checkmark icons
                        container.querySelectorAll('.fa-check-circle').forEach(el => el.remove());

                        // 3. Find the selected card (by mapping stratType to ID)
                        // stratType can be 'ltd' or 'LAY_THE_DRAW', cards have IDs like 'strat-card-matchId-ltd'
                        // Need to be robust with IDs
                        const cards = container.children;
                        for (let card of cards) {
                            // Simple heuristic: check if card text/data matches strategy
                            // OR better: use the mapping we already know
                            const cardIdStr = card.id || ''; // e.g. strat-card-123456-ltd
                            if (cardIdStr.includes(stratType.toLowerCase())) {
                                card.classList.remove('border-gray-200');
                                card.classList.add('border-green-500', 'bg-green-50');

                                // Add checkmark
                                const header = card.querySelector('.flex.justify-between');
                                if (header) {
                                    const icon = document.createElement('i');
                                    icon.className = 'fa-solid fa-check-circle text-green-500 text-lg';
                                    header.appendChild(icon);
                                }
                            }
                        }
                    }

                    // Refresh Generation view if visible (keeps data in sync)
                    const genSection = document.getElementById('trading-30-opportunities-section');
                    if (genSection && !genSection.classList.contains('hidden')) {
                        loadOpportunities30();
                    }
                }, 500);

            } catch (e) {
                console.error("Save error:", e);
                alert("Errore salvataggio: " + e.message);
            }
        };


        // NEW: Helper to add a specific strategy from the list
        window.selectAndAddStrategy = (optionId, date) => {
            const option = window.tradingOptionsMap?.[optionId];
            if (!option) {
                alert("Errore: Opzione non trovata.");
                return;
            }
            // Chiamiamo la funzione di aggiunta passando la strategia SPECIFICA
            // Nota: addTradingPickToDaily deve supportare il 3¬∞ parametro strategyOverride
            addTradingPickToDaily(option.match.partita, date, option.strategy);
        };

        window.addTradingPickToDaily = async function (partita, selectedDate, strategyOverride = null) {
            try {
                const docRef = doc(db, "daily_trading_picks", selectedDate);
                const docSnap = await getDoc(docRef);

                // Get the strategy from window.allMatches
                const matchObj = window.allMatches.find(m => m.partita === partita && m.data === selectedDate);
                if (!matchObj) throw new Error("Partita non trovata in locale.");

                let s = strategyOverride;

                if (!s) {
                    const magicStats = window.engine?.getMagiaStats?.(matchObj, window.allMatches) || null;
                    const enrichedMatch = { ...matchObj, magicStats };
                    s = window.engine?.transformToTradingStrategy?.(enrichedMatch, window.allMatches);
                }

                if (!s) throw new Error("Impossibile generare strategia per questo match.");

                // DEBUG: Cosa restituisce transformToTradingStrategy?
                console.log('[Admin-DEBUG] === addTradingPickToDaily ===');
                console.log('[Admin-DEBUG] s FULL OBJECT:', JSON.stringify(s, null, 2));
                console.log('[Admin-DEBUG] s.type:', s.type);
                console.log('[Admin-DEBUG] s.strategy:', s.strategy);
                console.log('[Admin-DEBUG] s.tradingInstruction:', s.tradingInstruction);
                console.log('[Admin-DEBUG] s.tradingInstruction?.action:', s.tradingInstruction?.action);

                let picks = [];
                if (docSnap.exists()) {
                    picks = docSnap.data().picks || [];
                }

                // Add to picks (Overwrite existing if present)
                // Filter out any existing pick for this match
                picks = picks.filter(p => p.partita !== matchObj.partita);

                picks.push({
                    id: Math.random().toString(36).substr(2, 9),
                    ...matchObj, // Spreading matchObj saves EVERYTHING including fixtureId
                    strategy: s.type || s.strategy, // Support both formats
                    strategyLabel: s.label || s.strategyLabel || s.strategy,
                    tradingInstruction: s.tradingInstruction,
                    confidence: s.confidence,
                    reasoning: s.reasoning,
                    status: 'pending',
                    addedAt: new Date().toISOString()
                });

                await setDoc(docRef, {
                    picks: picks,
                    updatedAt: new Date().toISOString(),
                    // Update stats if needed, though usually generated/count are set at generation time.
                    // We update them here just in case.
                    count: picks.length,
                    date: selectedDate,
                    isTrading30: true
                }, { merge: true });

                // Update local visual state mechanism
                // existingPartite.add(matchObj.partita); // REMOVED: existingPartite is not global. UI refresh below handles it.

                // Show feedback without full reload if possible, but reload is safer to sync UI state
                alert("Strategia salvata/aggiornata con successo!");

                // Refresh UI
                loadTradingLiveOpportunities();
                loadOpportunities30();

            } catch (e) {
                console.error('[Add Pick] Error:', e);
                alert('Errore: ' + e.message);
            }
        }

    </script>
    </div>

    <!-- ==================== RENAME STRATEGY MODAL ==================== -->
    <div id="rename-strategy-modal" class="hidden fixed inset-0 z-[9999] flex items-center justify-center">
        <!-- Overlay -->
        <div class="absolute inset-0 bg-black bg-opacity-50"
            onclick="document.getElementById('rename-strategy-modal').classList.add('hidden')"></div>

        <!-- Modal Content -->
        <div class="relative bg-white rounded-2xl p-8 max-w-md w-full mx-4 shadow-2xl">
            <button onclick="document.getElementById('rename-strategy-modal').classList.add('hidden')"
                class="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                <i class="fa-solid fa-times text-2xl"></i>
            </button>

            <h3 class="text-2xl font-bold text-gray-800 mb-4">
                <i class="fa-solid fa-pen mr-2 text-indigo-600"></i>
                Rinomina Strategia
            </h3>

            <div class="mb-4">
                <p class="text-sm text-gray-600 mb-2">
                    <strong>ID:</strong> <code id="rename-strategy-id"
                        class="bg-gray-100 px-2 py-1 rounded text-xs font-mono text-gray-700"></code>
                </p>
                <p class="text-xs text-gray-500">
                    L'ID √® immutabile e preserva lo storico della strategia
                </p>
            </div>

            <div class="mb-6">
                <label class="block text-sm font-semibold text-gray-700 mb-2">
                    Nome Visualizzato
                </label>
                <input type="text" id="rename-strategy-input"
                    class="w-full p-3 border-2 border-gray-300 rounded-lg focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 outline-none transition"
                    placeholder="Nuovo nome strategia">
            </div>

            <div class="flex gap-3">
                <button onclick="document.getElementById('rename-strategy-modal').classList.add('hidden')"
                    class="flex-1 bg-gray-300 text-gray-700 py-3 rounded-lg font-semibold hover:bg-gray-400 transition">
                    Annulla
                </button>
                <button id="rename-confirm-btn"
                    class="flex-1 bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 transition">
                    <i class="fa-solid fa-save mr-2"></i>
                    Salva Nome
                </button>
            </div>
        </div>
    </div>
    <!-- ==================== NEW 3-STEP WORKFLOW LOGIC ==================== -->
    <script>
        // GLOBAL STATE FOR STEP 1 -> STEP 2/3 HANDOFF
        window.CALCULATED_STATS = [];

        document.addEventListener('DOMContentLoaded', () => {
            // Bind Step 1 & 2 Buttons
            const btnStep1 = document.getElementById('btn-step1-calc');
            const btnStep2 = document.getElementById('btn-step2-dist');
            const btnStep3 = document.getElementById('trading-30-generate-btn');

            if (btnStep1) btnStep1.addEventListener('click', runStep1_MonteCarlo);
            if (btnStep2) btnStep2.addEventListener('click', runStep2_Distribution);

            // Re-bind Step 3 Button (Overwrite existing logic safely)
            if (btnStep3) {
                const newBtn3 = btnStep3.cloneNode(true);
                btnStep3.parentNode.replaceChild(newBtn3, btnStep3);
                newBtn3.addEventListener('click', runStep3_Trading);
            }

            // üî• UI HANDLERS FOR LEAGUE MAPPING
            window.confirmLeagueMapping = async (leagueLabel, id, name) => {
                if (!confirm(`Vuoi associare permanentemente "${leagueLabel}" a "${name}" (ID: ${id})?`)) return;
                await window.LocalDB.saveLeagueMapping(leagueLabel, id, { apiName: name });
                alert("Associazione salvata! Rianalizza il palinsesto per caricare le classifiche.");
                // Optional: trigger re-run Step 1 automatically? Maybe better to let user click again.
            };

            window.manualLeagueMapping = async (leagueLabel) => {
                const id = prompt(`Inserisci l'ID API-Football per la lega "${leagueLabel}":`);
                if (!id || isNaN(id)) return;
                await window.LocalDB.saveLeagueMapping(leagueLabel, parseInt(id));
                alert("Associazione manuale salvata!");
            };
        });


        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STEP 1: CALCOLA MONTECARLO (RAM ONLY)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function runStep1_MonteCarlo() {
            const btn = document.getElementById('btn-step1-calc');
            const originLabel = btn.innerHTML;
            const reportCtx = document.getElementById('step1-stats');
            const reportDiv = document.getElementById('step1-report');
            const btn2 = document.getElementById('btn-step2-dist');
            const dateInput = document.getElementById('pronostici-unified-date');

            try {
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-circle-notch fa-spin"></i> Calcolo...';

                const selectedDate = dateInput.value || new Date().toISOString().split('T')[0];

                // üî• SOLO Magia AI (Sandbox) nello Step 1 
                const matchesMagia = await window.LocalDB.loadMagiaMatches();
                const matchesRaw = matchesMagia.filter(m => m.data === selectedDate);

                // üïµÔ∏è‚Äç‚ôÇÔ∏è 0. EARLY FILTERING (Carica Blacklist & Filtra SUBITO)
                let matches = [];
                console.log(`[Step 1] Sandbox Calculation: Using all ${matchesRaw.length} matches (for statistics).`);
                matches = matchesRaw;
                // We load the blacklist just to display some info if needed, but we don't filter calculation
                const blacklistDoc = await getDoc(doc(db, "system", "blacklisted_leagues"));
                window.CURRENT_BLACKLIST = blacklistDoc.exists() ? (blacklistDoc.data().leagues || []) : [];

                console.log(`[Step 1] Loading Magia AI Sandbox for ${selectedDate}: ${matches.length} matches`);

                if (matches.length === 0) throw new Error("Nessuna partita trovata in Sandbox Magia AI per questa data.");

                console.time("MonteCarlo");
                const allMatchesHistory = await window.LocalDB.getAllMatches(); // üìö Carica lo STORICO REALE
                const results = [];
                const loadedStandingsNames = []; // üìã Track successfully loaded leagues

                // üî• NEW: PRE-FETCH STANDINGS & ELO (Dynamic & Selective)
                const uniqueLeagues = [...new Set(matches.map(m => m.lega))];
                const pendingLeagues = []; // Leghe da mappare/confermare
                // 0. RESET & PRE-LOAD HISTORICAL DATA (Fix ELO 1500)
                // 0. RESET & PRE-LOAD HISTORICAL DATA (Fix ELO 1500)
                // window.engine.reset(); // Method removed as it does not exist

                try {
                    btn.innerHTML = '<i class="fa-solid fa-history fa-spin"></i> Caricamento Storico...';
                    // Carica storico match passati per calcolo ELO corretto
                    if (!window.allMatchesHistory || window.allMatchesHistory.length === 0) {
                        window.allMatchesHistory = await window.LocalDB.loadMatches(); // O Fetch mirata se necessario
                        console.log(`[Step 1] Storico caricato: ${window.allMatchesHistory.length} match.`);
                    }

                    // Carica League Trust per pesare i campionati
                    if (!window.LEAGUE_TRUST || Object.keys(window.LEAGUE_TRUST).length === 0) {
                        try {
                            await window.databaseManager.loadLeagueTrust(db);
                        } catch (ltErr) { console.warn("Trust load fail", ltErr); }
                    }
                } catch (histErr) {
                    console.warn("[Step 1] Historical Data Warning:", histErr);
                }

                // 2. ELABORAZIONE MONTE CARLO
                btn.innerHTML = '<i class="fa-solid fa-microchip fa-bounce"></i> Analisi AI...';
                await new Promise(r => setTimeout(r, 100)); // UI Refresh

                console.time("MonteCarlo");




                const leagueIdMap = {};

                // Map league names to IDs efficiently
                for (const lega of uniqueLeagues) {
                    const leagueNorm = lega.toLowerCase();
                    let leagueId = null;

                    const mapping = await window.LocalDB.getLeagueMapping(lega);
                    if (mapping && mapping.leagueId) {
                        leagueId = mapping.leagueId;
                    } else {
                        const discovery = await autoDiscoverLeague(lega);
                        if (discovery && discovery.status === 'found') {
                            leagueId = discovery.id;
                        } else if (discovery && (discovery.status === 'ambiguous' || discovery.status === 'not_found')) {
                            pendingLeagues.push({ name: lega, status: discovery.status, options: discovery.options });
                            continue;
                        }
                    }

                    const cupIds = [1, 2, 3, 4, 6, 7, 9, 45, 48, 137, 143, 529, 66, 848];
                    const isCup = cupIds.includes(parseInt(leagueId)) || (STANDINGS_BLACKLIST_KEYWORDS.some(k => leagueNorm.includes(k)) && !leagueNorm.includes('league'));
                    if (isCup) continue;

                    if (leagueId) {
                        leagueIdMap[lega] = leagueId;
                        try {
                            btn.innerHTML = `<i class="fa-solid fa-ranking-star fa-bounce"></i> Carico: ${lega.substring(0, 15)}...`;
                            const standings = await window.getStandingsFromAPI(leagueId);
                            if (standings && window.standingsCache) {
                                if (typeof window.standingsCache.set === 'function') {
                                    window.standingsCache.set(leagueId, standings);
                                } else {
                                    window.standingsCache[leagueId] = standings;
                                }
                                loadedStandingsNames.push(lega);
                            }
                        } catch (e) { console.warn(`[Step 1] Errore classifica per ${lega}:`, e); }
                    }
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // STEP 1-BIS: RECUPERO QUOTE API (PRIMA DEL CALCOLO)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                btn.innerHTML = '<i class="fa-solid fa-cloud-download-alt fa-bounce"></i> Recupero Quote...';
                reportDiv.classList.remove('hidden');

                // UI Setup
                const loadedLeaguesCount = loadedStandingsNames.length;
                const sortedLeaguesHtml = loadedStandingsNames.sort().map(l => `
                    <div class="flex items-center gap-1.5 py-0.5 border-b border-blue-50/50 last:border-0">
                        <i class="fa-solid fa-check text-[8px] text-blue-400"></i>
                        <span>${l}</span>
                    </div>
                `).join('');

                reportCtx.innerHTML = `
                    <div class="space-y-3">
                        <div class="flex flex-col gap-1 bg-blue-50 border border-blue-100 rounded-lg p-3">
                            <div class="flex items-center gap-2 text-blue-700 font-bold mb-1">
                                <i class="fa-solid fa-ranking-star"></i> STEP 1: ANALISI & INTELLIGENCE (${loadedLeaguesCount} leghe)
                            </div>
                            <div class="grid grid-cols-2 gap-x-4 text-[10px] text-blue-600 max-h-32 overflow-y-auto pr-1">
                                ${sortedLeaguesHtml || '<div class="col-span-2 italic text-gray-400">Nessuna classifica nazionale trovata</div>'}
                            </div>
                        </div>
                        <div id="step1-fetch-progress" class="bg-indigo-50 border border-indigo-100 rounded-lg p-3">
                            <div class="flex justify-between items-center mb-1 text-xs font-bold text-indigo-800">
                                <span><i class="fa-solid fa-cloud-download-alt animate-pulse"></i> RECUPERO QUOTE API...</span>
                                <span id="progress-percent">0%</span>
                            </div>
                            <div class="w-full bg-indigo-200 rounded-full h-2">
                                <div id="progress-bar" class="bg-indigo-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                            <div id="progress-detail" class="text-[10px] text-indigo-600 mt-1 italic">Inizializzazione...</div>
                        </div>
                    </div>
                `;

                try {
                    const teamsList = matches.flatMap(m => window.parseTeams(m.partita) ? [window.parseTeams(m.partita).home, window.parseTeams(m.partita).away] : []);
                    const fixturesList = await window.loadDailyFixtures(selectedDate, teamsList);
                    const progressBar = document.getElementById('progress-bar');
                    const progressPercent = document.getElementById('progress-percent');
                    const progressDetail = document.getElementById('progress-detail');

                    for (let i = 0; i < matches.length; i++) {
                        const match = matches[i];



                        const progress = Math.round(((i + 1) / matches.length) * 100);
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (progressPercent) progressPercent.innerText = `${progress}%`;
                        if (progressDetail) progressDetail.innerText = `Elaborazione: ${match.partita}...`;

                        let targetFixtureId = match.fixtureId;
                        if (!targetFixtureId) {
                            const f = window.findMatchingFixture(match.partita, fixturesList, match.lega);
                            if (f && f.fixture) {
                                targetFixtureId = f.fixture.id;
                                match.fixtureId = targetFixtureId;
                            }
                        }

                        if (targetFixtureId && !(match.quota1 && match.quotaX && match.quota2)) {
                            await new Promise(r => setTimeout(r, 200));
                            try {
                                const bookmakers = await window.getOddsFromAPI(targetFixtureId);
                                if (bookmakers && bookmakers.length > 0) {
                                    const bookie = bookmakers.find(b => b.name === 'Bet365') || bookmakers[0];
                                    if (bookie && bookie.bets) {
                                        // 1Ô∏è‚É£ 1X2 (Match Winner)
                                        const bet1x2 = bookie.bets.find(b => b.name === 'Match Winner');
                                        if (bet1x2) {
                                            const h = bet1x2.values.find(v => v.value === 'Home');
                                            const d = bet1x2.values.find(v => v.value === 'Draw');
                                            const a = bet1x2.values.find(v => v.value === 'Away');
                                            if (h) match.quota1 = parseFloat(h.odd);
                                            if (d) match.quotaX = parseFloat(d.odd);
                                            if (a) match.quota2 = parseFloat(a.odd);
                                        }

                                        // 2Ô∏è‚É£ Doppia Chance
                                        const betDC = bookie.bets.find(b => b.name === 'Double Chance');
                                        if (betDC) {
                                            const dc1X = betDC.values.find(v => v.value === 'Home/Draw');
                                            const dcX2 = betDC.values.find(v => v.value === 'Draw/Away');
                                            const dc12 = betDC.values.find(v => v.value === 'Home/Away');
                                            if (dc1X) match.bookmaker1X = parseFloat(dc1X.odd);
                                            if (dcX2) match.bookmakerX2 = parseFloat(dcX2.odd);
                                            if (dc12) match.bookmaker12 = parseFloat(dc12.odd);
                                        }

                                        // 3Ô∏è‚É£ BTTS
                                        const betBtts = bookie.bets.find(b => b.name === 'Both Teams Score');
                                        if (betBtts) {
                                            const y = betBtts.values.find(v => v.value === 'Yes');
                                            const n = betBtts.values.find(v => v.value === 'No');
                                            if (y) match.bookmakerGG = parseFloat(y.odd);
                                            if (n) match.bookmakerNG = parseFloat(n.odd);
                                        }

                                        // 4Ô∏è‚É£ Goals Over/Under
                                        const betOu = bookie.bets.find(b => b.name === 'Goals Over/Under');
                                        if (betOu) {
                                            const extract = (val) => {
                                                const v = betOu.values.find(x => x.value === val);
                                                return v ? parseFloat(v.odd) : null;
                                            };
                                            match.bookmakerOver15 = extract('Over 1.5');
                                            match.bookmakerUnder15 = extract('Under 1.5');
                                            match.bookmakerOver25 = extract('Over 2.5');
                                            match.bookmakerUnder25 = extract('Under 2.5');
                                            match.bookmakerOver35 = extract('Over 3.5');
                                            match.bookmakerUnder35 = extract('Under 3.5');
                                        }

                                        // LOG DEBUG
                                        console.log(`[Odds PRE-Load] ${match.partita} -> DC: ${match.bookmaker1X}/${match.bookmakerX2} | 1X2: ${match.quota1}`);
                                    }
                                }
                            } catch (e) { console.warn(`[Odds] Skip ${match.partita}: ${e.message}`); }
                        }
                    }
                } catch (errApi) { console.error("Step 1 API PRE-LOAD Error:", errApi); }

                btn.innerHTML = '<i class="fa-solid fa-circle-notch fa-spin"></i> Simulazione Magia AI...';

                // ‚úÖ USA ID GI√Ä PRESENTI dalla Sandbox (salvati dal Pulsantone)
                // NO matching ridondante - fixtureId, teamIdHome, teamIdAway, leagueId gi√† corretti
                for (const match of matches) {
                    const teams = window.parseTeams(match.partita);
                    if (!teams) continue;

                    // Aggiorna leagueId solo se mancante (per pre-caricamento classifiche)
                    if (!match.leagueId && leagueIdMap[match.lega]) {
                        match.leagueId = leagueIdMap[match.lega];
                    }

                    // üî• COPY EXPLICIT BETMINES DATA (Snapshot Integrity)
                    // Se il match ha i dati originali (dal CSV o API), li copiamo in campi "originalDB..."
                    // cos√¨ lo storico potr√† leggerli anche tra un anno senza bisogno del DB globale.
                    if (match.tip) match.originalDBTip = match.tip;
                    if (match.quota) match.originalDBQuota = match.quota;
                    if (match.probabilita) match.originalDBProb = match.probabilita;

                    const magicStats = window.engine.getMagiaStats(match, window.allMatchesHistory);
                    if (!magicStats) continue;

                    results.push({
                        ...match,
                        magicStats: magicStats,
                        motivationBadges: magicStats.motivationBadges || [],
                        rankH: magicStats.rankH,
                        rankA: magicStats.rankA,
                        eloRatingH: magicStats.eloRatingH,
                        eloRatingA: magicStats.eloRatingA,
                        expertStats: magicStats.expertStats
                    });
                }
                console.timeEnd("MonteCarlo");

                // 3. SINCRONIZZAZIONE DATI (Local & Firebase)
                btn.innerHTML = '<i class="fa-solid fa-sync fa-spin"></i> Sincronizzazione...';

                for (const match of results) {
                    // üî• FIXED: SYNC TO RAM (allMatches) - Using fixtureId for universal matching
                    // ‚ö†Ô∏è AGGIORNA SOLO PARTITE CON magia === 'AI' (le altre hanno tip/odds da Betimens gestite dallo Step 2)
                    if (match.fixtureId) {
                        const target = window.allMatches.find(m => String(m.fixtureId) === String(match.fixtureId));
                        if (target && target.magia === 'AI') {
                            // console.log(`[Step 1] ‚úÖ Persisting to Oro (AI only): ${match.partita} (fixtureId: ${match.fixtureId})`);
                            Object.assign(target, {
                                magicStats: match.magicStats,
                                expertStats: match.expertStats,
                                rankH: match.rankH,
                                rankA: match.rankA,
                                motivationBadges: match.motivationBadges,
                                teamIdHome: match.teamIdHome,
                                teamIdAway: match.teamIdAway,
                                leagueId: match.leagueId,
                                fixtureId: match.fixtureId,
                                isMagiaEnriched: true,
                                tip: match.magicStats?.tipMagiaAI || target.tip,
                                quota: match.magicStats?.oddMagiaAI || target.quota,
                                probabilita: match.magicStats?.probMagiaAI || target.probabilita,
                                probMagiaAI: match.magicStats?.probMagiaAI, // üÜï SALVA PROB
                                smartScore: match.magicStats?.smartScore   // üÜï SALVA SCORE
                            });
                            if (match.quota1) target.quota1 = match.quota1;
                            if (match.quotaX) target.quotaX = match.quotaX;
                            if (match.quota2) target.quota2 = match.quota2;
                        } else if (target && target.magia !== 'AI') {
                            console.warn(`[Step 1] ‚è≠Ô∏è Skipper non-AI match: ${match.partita} (magia: ${target.magia}) - managed by Step 2`);
                        } else {
                            // Match non trovato in Oro? Warning
                            console.warn(`[Step 1] ‚ùå Match not found in Oro DB: ${match.partita} (fixtureId: ${match.fixtureId})`);
                        }
                    }
                }

                await window.LocalDB.saveMatches(window.allMatches);
                console.log(`[Step 1] Data synced locally.`);

                // üî• HYBRID SYNC: Push to Firebase for App visibility (Picks Magia AI)
                try {
                    console.log(`[Step 1] Sincronizzazione Cloud delle Picks Magia AI (Filter: Time >= 12:00 & Blacklist)...`);
                    const normBlacklist = (window.CURRENT_BLACKLIST || []).map(l => (l || "").toLowerCase().trim());

                    const matchesForPWA = results.filter(m => {
                        // 1. Time Filter
                        const [hh] = (m.ora || "00:00").split(':').map(Number);
                        const isDaytime = hh >= 12;

                        // 2. Blacklist Filter
                        const legaOrig = (m.lega || "").toLowerCase().trim();
                        const isBlacklisted = normBlacklist.includes(legaOrig);

                        return isDaytime && !isBlacklisted;
                    });

                    if (matchesForPWA.length > 0) {
                        await uploadMatchesToFirebase('tips', matchesForPWA, window.allMatches, window.db || db);
                        console.log(`[Step 1] ‚úÖ Caricate ${matchesForPWA.length} picks sulla PWA.`);
                    } else {
                        console.log(`[Step 1] ‚è≠Ô∏è Nessuna pick caricata sulla PWA (filtri attivi).`);
                    }
                } catch (fbErr) { console.warn("[Step 1] Firebase Sync Fail", fbErr); }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // POST-CALCOLO: ARRICCHIMENTO PRO CON DATI ORO (BETMINES)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                console.log("[Step 1] üíé Arricchimento Scheda PRO con dati Betmines (DB Oro)...");
                let enrichedCount = 0;

                for (const res of results) {
                    if (!res.fixtureId) continue;

                    // üî• STRICT MATCHING: SOLO FIXTURE ID
                    const oroMatch = window.allMatches.find(m => String(m.fixtureId) === String(res.fixtureId));

                    if (oroMatch && oroMatch.magia !== 'AI') {
                        // Trovato match corrispondente che NON √® 'AI' -> Sono i dati Betmines originali
                        res.originalDBTip = oroMatch.tip;
                        res.originalDBQuota = oroMatch.quota;
                        res.originalDBProb = oroMatch.probabilita;
                        enrichedCount++;
                    }
                }
                console.log(`[Step 1] ‚úÖ Arricchiti ${enrichedCount} match su ${results.length} con dati Betmines.`);

                window.CALCULATED_STATS = results;
                window.MAGIA_AI_PICKS = results; // ‚úÖ Salva per visualizzazione dettagliata

                // üî• PRO SNAPSHOT (Source of Truth for History)
                // Salviamo immediatamente il blocco PRO nello storico locale E SU FIREBASE.
                // Usiamo un ID specifico 'magia_ai_raw' che non confligge con lo Step 2.
                (async () => {
                    try {
                        // 1. Load Local Existing
                        const existingStrats = await window.LocalDB.loadStrategyHistory(selectedDate) || {};

                        // 2. Create/Update PRO Snapshot (APPLY FILTERS for App Visibility)
                        const normBlacklist = (window.CURRENT_BLACKLIST || []).map(l => (l || "").toLowerCase().trim());
                        const filteredResults = results.filter(m => {
                            const [hh] = (m.ora || "00:00").split(':').map(Number);
                            const legaOrig = (m.lega || "").toLowerCase().trim();
                            return hh >= 12 && !normBlacklist.includes(legaOrig);
                        });

                        existingStrats.magia_ai_raw = {
                            id: 'magia_ai_raw',
                            name: 'üîÆ MAGIA AI (PRO)',
                            matches: filteredResults,
                            totalMatches: filteredResults.length,
                            type: 'pro_snapshot',
                            lastUpdated: new Date().toISOString()
                        };

                        // 3. Save Local (Admin Priority)
                        await window.LocalDB.saveStrategyHistory(selectedDate, existingStrats);

                        // 4. Save Cloud (PWA Visibility - Daily Strategies)
                        // This allows Users to see "Magia AI PRO" on the App immediately after Step 1
                        await window.databaseManager.saveStrategyToHistory(db, selectedDate, existingStrats);

                        console.log(`[Step 1] üì∏ Snapshot 'magia_ai_raw' salvato (Local + Cloud)`);
                    } catch (errSnap) { console.warn("[Step 1] Snapshot Fail", errSnap); }
                })();

                // FINAL REPORT (Simplified)
                const finalTotal = results.length;
                const finalEnriched = results.filter(m => m.quota1).length;
                const finalMissing = results.filter(m => !m.quota1);

                reportCtx.innerHTML = `
                    <div class="space-y-4">
                        <div class="flex flex-wrap gap-2 text-[10px] font-bold">
                            <div class="px-3 py-1 bg-green-100 text-green-700 rounded-full border border-green-200">Monte Carlo OK (${finalTotal})</div>
                            <div class="px-3 py-1 bg-blue-100 text-blue-700 rounded-full border border-blue-200">Quote OK (${finalEnriched})</div>
                        </div>
                        <div class="grid grid-cols-3 gap-2 text-center text-xs">
                            <div class="bg-gray-100 p-2 rounded-lg">Analizzate: ${finalTotal}</div>
                            <div class="bg-green-600 text-white p-2 rounded-lg shadow-sm">Pronte: ${finalEnriched}</div>
                            <div class="bg-amber-100 p-2 rounded-lg">Senza Quote: ${finalMissing.length}</div>
                        </div>
                        ${finalMissing.length > 0 ? `<div class="p-3 bg-yellow-50 rounded text-[10px] text-yellow-700 italic">‚ö†Ô∏è Alcune partite senza quote API saranno escluse.</div>` : ''}
                        
                        <!-- üî• BOX PICK MAGIA AI -->
                        <div class="mt-4 border-t border-gray-200 pt-4">
                            <h4 class="text-lg font-bold text-purple-700 mb-3">üîÆ Pick Magia AI per ${selectedDate}</h4>
                            <div class="p-4 bg-gradient-to-br from-purple-50 to-indigo-50 border-2 border-purple-200 rounded-xl cursor-pointer hover:shadow-lg transition-all transform hover:scale-[1.02]" onclick="window.showMagiaAIPicksPreview()">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <div class="text-sm font-bold text-purple-900">Pick Magia AI</div>
                                        <div class="text-xs text-purple-600 mt-1">Clicca per vedere le partite calcolate</div>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <div class="text-4xl font-black text-purple-700">${finalEnriched}</div>
                                        <i class="fa-solid fa-chevron-right text-purple-400"></i>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                btn2.disabled = false;
                btn2.classList.replace('bg-gray-100', 'bg-green-600');
                btn2.classList.replace('text-gray-400', 'text-white');
                btn.innerHTML = `<i class="fa-solid fa-check"></i> Generati (${results.length})`;
                setTimeout(() => btn.innerHTML = originLabel, 2000);

            } catch (e) {
                console.error(e);
                alert("Errore Step 1: " + e.message);
                btn.innerHTML = '<i class="fa-solid fa-exclamation-triangle"></i> Errore';
            } finally {
                btn.disabled = false;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STEP 2: PUBBLICA STRATEGIE (DB ONLY)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function runStep2_Distribution() {
            const btn = document.getElementById('btn-step2-dist');
            const dateInput = document.getElementById('pronostici-unified-date');
            const reportCtx = document.getElementById('step1-report-area');

            try {
                if (!window.CALCULATED_STATS || window.CALCULATED_STATS.length === 0) {
                    const selectedDate = dateInput?.value || new Date().toISOString().split('T')[0];
                    const matchesForDate = window.allMatches.filter(m => m.data === selectedDate);
                    if (matchesForDate.length === 0) throw new Error("Nessuna partita trovata. Esegui Step 1.");
                    window.CALCULATED_STATS = matchesForDate;
                }

                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-cloud-upload-alt fa-bounce"></i> Pubblicazione...';

                const selectedDate = dateInput?.value || new Date().toISOString().split('T')[0];

                // 1. CARICAMENTO BLACKLIST & PRESETS (Real-Time Cloud)
                let blacklist = [];
                let presets = {};

                try {
                    btn.innerHTML = '<i class="fa-solid fa-sync fa-spin"></i> Caricamento Cloud...';

                    // Blacklist Manager Data
                    const blDoc = await getDoc(doc(db, "system", "blacklisted_leagues"));
                    if (blDoc.exists()) blacklist = blDoc.data().leagues || [];

                    // Dashboard Presets (System)
                    const prDoc = await getDoc(doc(db, "system", "client_presets"));
                    if (prDoc.exists()) presets = { ...presets, ...(prDoc.data() || {}) };

                    // Custom Strategies (Published by User) - üî• MISSING FIX
                    const stDoc = await getDoc(doc(db, "system", "client_strategies"));
                    if (stDoc.exists()) {
                        const customStrats = stDoc.data() || {};
                        // Ensure it doesn't overwrite system keys unless intended
                        presets = { ...presets, ...customStrats };
                    }

                    console.log(`[Step 2] Cloud Data Loaded: ${blacklist.length} blacklisted, presets + custom merged.`);
                } catch (cloudErr) {
                    console.warn("[Step 2] Errore caricamento cloud, uso fallback locali", cloudErr);
                }

                // 2. DISTRIBUZIONE DINAMICA (Database Oro Only)
                btn.innerHTML = '<i class="fa-solid fa-share-nodes fa-spin"></i> Distribuzione...';
                const strategiesMap = window.distributeStrategies(null, window.allMatches, selectedDate, {
                    blacklist: blacklist,
                    presets: presets
                });
                if (!strategiesMap || Object.keys(strategiesMap).length === 0) {
                    throw new Error('Errore: Nessuna strategia generata dopo il filtraggio.');
                }

                // 4. PERSISTENCE (Safe Merging - LEAN MODE)
                // Leggiamo cosa c'√® gi√† (es. la scheda PRO) e aggiungiamo le nostre
                const existingHistory = await window.LocalDB.loadStrategyHistory(selectedDate) || {};

                // Merge: Existing (PRO) + New (Step 2 Strategies)
                const finalMap = { ...existingHistory, ...strategiesMap };

                // Save Local (Master)
                await window.LocalDB.saveStrategyHistory(selectedDate, finalMap);

                // Save Cloud (PWA)
                // Step 2 overwrites Cloud BUT includes the PRO snapshot because we merged it!
                try {
                    console.log('[Step 2] üíæ Pubblicazione strategie su Firebase (Merged)...');
                    await saveStrategyToHistory(db, selectedDate, finalMap);
                } catch (fbErr) { console.warn("[Step 2] Firebase Publish Fail", fbErr); }

                // 5. PARLAYS
                btn.innerHTML = '<i class="fa-solid fa-dice fa-spin"></i> Generando Consigli...';
                const parlayResult = await window.generateDailyParlays(selectedDate, strategiesMap);
                window.LAST_PARLAYS = parlayResult;

                // 6. UI UPDATE
                if (reportCtx) {
                    const htmlReport = `
                        <div class="mb-4 bg-green-50 border-l-4 border-green-500 p-4 rounded-r-xl shadow-sm">
                            <p class="text-sm text-green-700">
                                <strong>Step 2 Completato:</strong> Strategie isolate e blacklist applicata (${blacklist.length} leghe filtrate).
                            </p>
                        </div>
                    `;

                    let html = `
                        <div class="mt-4 border-t border-gray-200 pt-4">
                            <h4 class="text-lg font-bold text-green-700 mb-3">‚úÖ Strategie Pubblicate per ${selectedDate}</h4>
                            <div class="grid grid-cols-2 md:grid-cols-3 gap-3">
                    `;
                    for (const [stratId, strat] of Object.entries(strategiesMap)) {
                        html += `
                            <div class="p-3 bg-white border border-gray-200 rounded-lg cursor-pointer hover:shadow-md transition" onclick="window.showStrategyPreview('${stratId}')">
                                <div class="text-xs font-bold text-gray-700">${strat.name || stratId}</div>
                                <div class="text-xl font-black text-gray-800">${strat.totalMatches || 0}</div>
                            </div>
                        `;
                    }
                    html += `</div></div>`;
                    reportCtx.innerHTML = alertHtml + html;
                    window.LAST_PUBLISHED_STRATEGIES = strategiesMap;
                }

                btn.innerHTML = '<i class="fa-solid fa-check-double"></i> Pubblicato';

                // Refresh Dashboards
                if (typeof window.loadOpportunities30 === 'function') await window.loadOpportunities30();
                if (typeof window.loadPronosticiLiveStrategies === 'function') await window.loadPronosticiLiveStrategies();

            } catch (e) {
                console.error(e);
                alert("Errore Step 2: " + e.message);
                btn.innerHTML = '<i class="fa-solid fa-exclamation"></i> Errore';
            } finally {
                btn.disabled = false;
            }
        }

        // üî• STORICO 3.0: Backup Strategie (ML Ready)
        async function backupStrategies() {
            const btn = document.getElementById('backup-strategie-btn');
            const originalHTML = '<i class="fa-solid fa-file-export"></i> Backup Strategie';

            try {
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Esportazione...';

                const data = await window.LocalDB.exportStrategiesHistory();

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');

                const timestamp = new Date().toISOString().split('T')[0];
                a.href = url;
                a.download = `Tipster_STRATEGIE_BACKUP_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Backup OK';
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.disabled = false;
                }, 3000);

            } catch (e) {
                console.error("[Backup] Errore:", e);
                alert("Errore durante il backup: " + e.message);
                btn.innerHTML = originalHTML;
                btn.disabled = false;
            }
        }

        // üî• STORICO 3.0: Restore Strategie
        async function restoreStrategies(event) {
            const file = event.target.files[0];
            if (!file) return;

            const btn = document.getElementById('restore-strategie-btn');
            const originalHTML = '<i class="fa-solid fa-file-import"></i> Restore Strategie';

            try {
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Ripristino...';

                const text = await file.text();
                const data = JSON.parse(text);

                if (data.type !== 'strategies_backup' && !data.history) {
                    throw new Error("Formato backup non valido. Assicurati di caricare un file 'Tipster_STRATEGIE_BACKUP'.");
                }

                const importedCount = await window.LocalDB.importStrategiesHistory(data);

                alert(`‚úÖ Ripristino completato! Caricate ${importedCount} giornate di strategie.`);

                btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Ripristino OK';
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.disabled = false;
                    // Reset input
                    event.target.value = '';
                }, 3000);

            } catch (e) {
                console.error("[Restore] Errore:", e);
                alert("Errore durante il ripristino: " + e.message);
                btn.innerHTML = originalHTML;
                btn.disabled = false;
                event.target.value = '';
            }
        }

        // Initializer for new buttons (Single Source of Truth)
        document.addEventListener('DOMContentLoaded', () => {
            const backupBtn = document.getElementById('backup-strategie-btn');
            // Remove any legacy inline onclick that might cause double triggers
            if (backupBtn) {
                backupBtn.onclick = null;
                backupBtn.addEventListener('click', backupStrategies);
            }

            const restoreBtn = document.getElementById('restore-strategie-btn');
            const restoreInput = document.getElementById('restore-strategie-input');
            if (restoreBtn && restoreInput) {
                restoreBtn.addEventListener('click', () => restoreInput.click());
                restoreInput.addEventListener('change', restoreStrategies);
            }
        });

        // üî• HELPER: Show strategy preview modal/popup
        window.showStrategyPreview = (stratId) => {
            const strat = window.LAST_PUBLISHED_STRATEGIES?.[stratId];
            if (!strat || !strat.matches || strat.matches.length === 0) {
                alert('Nessuna partita in questa strategia.');
                return;
            }

            const isMagia = stratId === 'magia_ai';
            const matches = strat.matches.slice(0, 50); // Show more matches (50) since it's compact

            let html = `
                <div style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:9999; overflow-y:auto; padding:10px;" onclick="this.remove()">
                    <div style="max-width:600px; margin:0 auto; background:white; border-radius:12px; padding:16px; max-height:95vh; overflow-y:auto;" onclick="event.stopPropagation()">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; border-bottom:1px solid #eee; padding-bottom:8px;">
                            <h2 style="font-size:18px; font-weight:bold; color:${isMagia ? '#7c3aed' : '#1f2937'}; margin:0;">${isMagia ? 'üîÆ' : 'üìä'} ${strat.name || stratId}</h2>
                            <button onclick="this.closest('div[style*=\'position:fixed\']').remove()" style="font-size:20px; color:#888; background:none; border:none; cursor:pointer;">‚úï</button>
                        </div>
                        <p style="color:#666; font-size:12px; margin-bottom:12px;">${strat.totalMatches} partite totali</p>
                        <div style="display:grid; gap:8px;">
            `;

            matches.forEach((m, idx) => {
                const isSimple = ['italia', 'all', '___magia_ai', 'top_eu', 'winrate_80'].includes(stratId);

                if (isSimple && typeof window.renderSimpleStrategyCard === 'function') {
                    html += window.renderSimpleStrategyCard(m, idx);
                } else if (isMagia && typeof window.renderMagiaAICard === 'function') {
                    // Use shared helper
                    html += window.renderMagiaAICard(m, idx, true);
                } else {
                    // Fallback / Standard Card for other strategies
                    html += `
                        <div style="border:1px solid #e5e7eb; border-radius:8px; padding:10px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.05);">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <div style="flex:1; min-width:0; margin-right:8px;">
                                    <div style="font-size:10px; color:#6b7280; text-transform:uppercase; font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${m.lega}</div>
                                    <div style="font-weight:bold; color:#1f2937; font-size:14px; line-height:1.2;">${m.partita}</div>
                                </div>
                                <div style="text-align:right; flex-shrink:0;">
                                    <div style="font-size:16px; font-weight:bold; color:#2563eb; display:flex; align-items:center; justify-content:flex-end;">
                                        ${m.tip}
                                    </div>
                                    <div style="font-size:11px; color:#6b7280; font-weight:bold;">@${m.quota || '-'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });

            html += `
                        </div>
                        <button onclick="this.closest('div[style*=\'position:fixed\']').remove()" style="margin-top:12px; width:100%; padding:10px; background:#f3f4f6; color:#374151; border:none; border-radius:8px; font-weight:bold; cursor:pointer; font-size:13px;">Chiudi</button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', html);
        };

        // üî• MAGIA AI: Visualizza Pick Magia AI (Step 1)
        window.showMagiaAIPicksPreview = () => {
            const picks = window.MAGIA_AI_PICKS;
            if (!picks || picks.length === 0) {
                alert('Nessuna pick Magia AI disponibile. Esegui prima Step 1.');
                return;
            }

            const matchesWithQuotes = picks.filter(m => m.quota1);
            const matches = matchesWithQuotes.slice(0, 50); // Show up to 50

            let html = `
                <div style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:9999; overflow-y:auto; padding:10px;" onclick="this.remove()">
                    <div style="max-width:600px; margin:0 auto; background:white; border-radius:12px; padding:16px; max-height:95vh; overflow-y:auto;" onclick="event.stopPropagation()">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; border-bottom:1px solid #eee; padding-bottom:8px;">
                            <h2 style="font-size:18px; font-weight:bold; color:#7c3aed; margin:0;">üîÆ Pick Magia AI</h2>
                            <button onclick="this.closest('div[style*=\\'position:fixed\\']').remove()" style="font-size:20px; color:#888; background:none; border:none; cursor:pointer;">‚úï</button>
                        </div>
                        <p style="color:#666; font-size:12px; margin-bottom:12px;">${matchesWithQuotes.length} partite con quote disponibili</p>
                        <div style="display:grid; gap:8px;">
            `;

            matches.forEach((m, idx) => {
                if (typeof window.renderMagiaAICard === 'function') {
                    html += window.renderMagiaAICard(m, idx, true);
                } else {
                    // Fallback rendering
                    html += `
                        <div style="border:1px solid #e5e7eb; border-radius:8px; padding:10px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.05);">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <div style="flex:1; min-width:0; margin-right:8px;">
                                    <div style="font-size:10px; color:#6b7280; text-transform:uppercase; font-weight:bold; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${m.lega}</div>
                                    <div style="font-weight:bold; color:#1f2937; font-size:14px; line-height:1.2;">${m.partita}</div>
                                </div>
                                <div style="text-align:right; flex-shrink:0;">
                                    <div style="font-size:16px; font-weight:bold; color:#7c3aed; display:flex; align-items:center; justify-content:flex-end;">
                                        ${m.magicStats?.tipMagiaAI || m.tip || '-'}
                                    </div>
                                    <div style="font-size:11px; color:#6b7280; font-weight:bold;">@${m.magicStats?.oddMagiaAI || m.quota || '-'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });

            html += `
                        </div>
                        <button onclick="this.closest('div[style*=\\'position:fixed\\']').remove()" style="margin-top:12px; width:100%; padding:10px; background:#f3f4f6; color:#374151; border:none; border-radius:8px; font-weight:bold; cursor:pointer; font-size:13px;">Chiudi</button>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', html);
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STEP 3: TRADING 3.0 (HYBRID RAM + API)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function runStep3_Trading() {
            const btn = document.getElementById('trading-30-generate-btn');
            const dateInput = document.getElementById('trading-30-date');

            try {
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-satellite-dish fa-spin"></i> Elaborazione Locale...';

                const selectedDate = dateInput.value || new Date().toISOString().split('T')[0];

                // üî• LOCAL DATA SOURCE (HYBRID RAM + DB ORO)
                // Usiamo i dati calcolati dallo Step 1 (RAM) o caricati dal Database Oro (Storico)
                let matches = (window.CALCULATED_STATS || []).filter(m => m.data === selectedDate);

                if (matches.length === 0) {
                    console.log("[Step 3] üîç Cercando snapshot Step 1 in Database Oro...");
                    const history = await window.LocalDB.loadStrategyHistory(selectedDate);
                    if (history && history.magia_ai_raw) {
                        matches = history.magia_ai_raw.matches || [];
                        window.CALCULATED_STATS = matches; // ‚úÖ Cache per usi futuri
                        console.log(`[Step 3] ‚úÖ Rehydrated ${matches.length} matches from Database Oro.`);
                    }
                }

                if (matches.length === 0) throw new Error("Nessuna partita elaborata dallo Step 1 trovata per questa data. Esegui prima lo Step 1.");

                // üî• DYNAMIC REGISTRY FILTERING
                const registry = await window.LocalDB.getAllLeagueMappings();
                const allowedLeaguesSet = new Set(
                    registry
                        .filter(r => r.trading === true)
                        .map(r => (r.name || r.label || "").toLowerCase().trim())
                );

                matches = matches.filter(m => {
                    const cleanLega = (m.lega || '').toLowerCase().trim();
                    return allowedLeaguesSet.has(cleanLega);
                });

                if (matches.length === 0) {
                    btn.innerHTML = '<i class="fa-solid fa-circle-info"></i> Nessun match TOP oggi';
                    btn.disabled = true;
                    setTimeout(() => {
                        btn.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles"></i> Step 3: Genera Trading 3.0';
                        btn.disabled = false;
                    }, 3000);
                    return;
                }

                btn.innerHTML = '<i class="fa-solid fa-brain fa-pulse"></i> Analisi Strategie...';
                const tradingPicks = [];

                for (const match of matches) {
                    const strategies = window.calculateAllTradingStrategies(match, window.allMatches);
                    if (strategies && strategies.length > 0) {
                        const calculatedStrategies = strategies.map(s => ({
                            type: s.type,
                            confidence: s.confidence || 0,
                            reasoning: s.reasoning || s.strategy?.tradingInstruction?.entry || 'Calcolato'
                        }));

                        const best = strategies[0];
                        tradingPicks.push({
                            ...match,
                            fixtureId: match.fixtureId || match.id, // üîê FORCE FIXTURE ID
                            calculatedStrategies,
                            activeStrategy: best.type,
                            strategy: best.type,
                            confidence: best.confidence,
                            tradingInstruction: best.strategy?.tradingInstruction
                        });
                    }
                }



                // üî• SAVE TO LOCAL DB (Oro)
                console.log('[Step 3] üíæ Salvataggio trading picks in LocalDB...');
                // Salviamo come sotto-chiave speciale nelle strategie del giorno
                const existingStrats = await window.LocalDB.loadStrategyHistory(selectedDate) || {};
                existingStrats.trading_picks = {
                    name: "Trading 3.0 Picks",
                    matches: tradingPicks,
                    totalMatches: tradingPicks.length,
                    lastUpdated: new Date().toISOString()
                };
                await window.LocalDB.saveStrategyHistory(selectedDate, existingStrats);

                // üî• HYBRID SYNC: Save to Firestore for PWA
                try {
                    const dataToSave = window.sanitizeForFirestore({
                        lastUpdated: new Date().toISOString(),
                        picks: tradingPicks,
                        count: tradingPicks.length
                    });
                    console.log('[Step 3] üíæ Publishing Trading Picks to Firebase...');
                    await setDoc(doc(db, "daily_trading_picks", selectedDate), dataToSave, { merge: true });
                } catch (fbErr) { console.warn("[Step 3] Firebase Publish Fail", fbErr); }

                alert(`Generati ${tradingPicks.length} segnali di trading locali (e caricati su App)!`);
                if (typeof window.loadOpportunities30 === 'function') await window.loadOpportunities30();

                btn.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles"></i> Step 3: Genera Trading 3.0';

            } catch (e) {
                console.error(e);
                alert("Errore Step 3: " + e.message);
                btn.innerHTML = '<i class="fa-solid fa-exclamation"></i> Errore';
            } finally {
                btn.disabled = false;
            }
        }

        // ==================== TRADING 3.0 HISTORY & VIEW MANAGER (RESTORED) ====================

        /**
        * Switches between the 3 main views of Trading 3.0
        * @param {string} mode - 'today' | 'history_list' | 'history_detail'
        * @param {string|null} contextDate - Optional date for detail view
        */
        window.switchTradingView30 = function (mode, contextDate = null) {
            const secGen = document.getElementById('trading-30-opportunities-section');
            const secHistList = document.getElementById('trading-30-history-section');
            const secDetail = document.getElementById('trading-live-section'); // Reused as Detail View

            // Reset visibility
            secGen?.classList.add('hidden');
            secHistList?.classList.add('hidden');
            secDetail?.classList.add('hidden');

            console.log(`[ViewManager] Switching to: ${mode} (${contextDate})`);

            if (mode === 'today') {
                secGen?.classList.remove('hidden');
                // Ensure date picker is today
                const dp = document.getElementById('trading-30-date');
                if (dp) dp.value = new Date().toISOString().split('T')[0];
                window.loadOpportunities30(); // Reload generation view
            }
            else if (mode === 'history_list') {
                secHistList?.classList.remove('hidden');
                loadTradingHistoryList(); // Load the list of dates
            }
            else if (mode === 'history_detail') {
                secDetail?.classList.remove('hidden');
                if (contextDate) {
                    // Update the detail header
                    const detailDateLabel = document.getElementById('trading-live-date');
                    if (detailDateLabel) detailDateLabel.textContent = contextDate;

                    const dp = document.getElementById('trading-30-date');
                    if (dp) dp.value = contextDate;
                    window.loadTradingLiveOpportunities();

                    // Add "Back" button functionality dynamically if not present
                    const headerTitle = secDetail.querySelector('h2');
                    if (headerTitle && !document.getElementById('trading-hist-back-btn')) {
                        const backBtn = document.createElement('button');
                        backBtn.id = 'trading-hist-back-btn';
                        backBtn.className = "mr-3 text-emerald-800 hover:text-emerald-600 transition bg-emerald-100 w-8 h-8 rounded-full flex items-center justify-center";
                        backBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                        backBtn.onclick = () => window.switchTradingView30('history_list');
                        headerTitle.prepend(backBtn);
                    }
                }
            }
        };

        const historyBtn = document.getElementById('trading-30-history-btn');
        // Close button on History List returns to Today view
        const historyCloseBtn = document.getElementById('trading-30-history-close');

        // Fix listener (overwrite placeholder)
        if (historyBtn) {
            historyBtn.onclick = () => window.switchTradingView30('history_list');
        }

        historyCloseBtn?.addEventListener('click', () => {
            window.switchTradingView30('today');
        });

        // Renamed to clarify it loads the LIST of dates
        async function loadTradingHistoryList() {
            const historyContent = document.getElementById('trading-30-history-content');
            if (!historyContent) return;

            historyContent.innerHTML = `
<div class="flex items-center justify-center py-12 text-gray-400">
    <i class="fas fa-spinner fa-spin text-2xl mr-3"></i>
    <span>Caricamento archivio...</span>
</div>`;

            try {
                // Query daily_trading_picks - fetch all, sort client-side by doc ID (which is the date)
                const snapshot = await getDocs(collection(db, "daily_trading_picks"));

                if (snapshot.empty) {
                    historyContent.innerHTML = `<div class="text-center py-12 text-gray-400">Nessuno storico disponibile.</div>`;
                    return;
                }

                // Convert to array, use doc.id as date, sort desc, limit to 20
                const docs = [];
                snapshot.forEach(doc => {
                    docs.push({ id: doc.id, ...doc.data() });
                });

                // Sort by ID (date format YYYY-MM-DD) descending
                docs.sort((a, b) => b.id.localeCompare(a.id));
                const recentDocs = docs.slice(0, 20);

                let html = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';

                recentDocs.forEach(data => {
                    const dateStr = data.id; // Document ID is the date
                    const picks = data.picks || [];
                    const winCount = picks.filter(p => (p.esito || '').toLowerCase().includes('vint')).length;
                    const total = picks.length;
                    const winRate = total > 0 ? Math.round((winCount / total) * 100) : 0;

                    html += `
    <div onclick="window.switchTradingView30('history_detail', '${dateStr}')"
        class="bg-gray-50 hover:bg-white border hover:border-purple-400 rounded-xl p-4 cursor-pointer transition-all hover:shadow-md group">

        <div class="flex items-center justify-between mb-3">
            <div class="font-black text-lg text-gray-800">${dateStr}</div>
            <i class="fa-solid fa-chevron-right text-gray-300 group-hover:text-purple-500 transition"></i>
        </div>

        <div class="flex items-center gap-4 text-sm">
            <div class="flex items-center gap-1.5">
                <span class="bg-gray-200 text-gray-700 px-2 py-0.5 rounded text-xs font-bold">${total} Studi</span>
            </div>
            <div class="flex items-center gap-1.5">
                <span
                    class="${winRate >= 70 ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'} px-2 py-0.5 rounded text-xs font-bold">
                    ${winRate}% WR
                </span>
            </div>
        </div>
    </div>
    `;
                });

                html += '</div>';
                historyContent.innerHTML = html;

            } catch (e) {
                console.error('[History] Error:', e);
                historyContent.innerHTML = `<div class="text-red-500 text-center py-12">Errore caricamento: ${e.message}</div>`;
            }
        }

        // üî• NEW v13.0: Magia AI World Domination Workflow
        async function loadMagiaAIWorkflow() {
            const btn = document.getElementById('load-magia-ai-btn');
            const originalHTML = btn.innerHTML;
            const dateInput = document.getElementById('tips-date');
            const selectedDate = dateInput.value;

            if (!selectedDate) {
                alert("Socio, seleziona una data per la Magia! üìÖ");
                return;
            }

            btn.disabled = true;
            btn.innerHTML = '<i class="fa-solid fa-wand-sparkles fa-spin mr-2"></i>Estrapolazione Mondiale...';

            try {
                // üî• STEP 1: Load League Registry FIRST
                const registry = await window.LocalDB.getAllLeagueMappings();
                if (!registry || registry.length === 0) {
                    throw new Error("Registro Leghe vuoto! Carica prima un CSV e completa Fase 1.");
                }

                const registryMap = new Map();
                const registryLeagueIds = [];
                registry.forEach(l => {
                    if (l.leagueId) {
                        const lid = parseInt(l.leagueId);
                        registryMap.set(lid, l);
                        registryLeagueIds.push(lid);
                    }
                });

                console.log(`[Postino] üîç Registro Leghe caricato: ${registryLeagueIds.length} leghe configurate`);
                console.log(`[Postino] IDs:`, registryLeagueIds);

                // üî• STEP 2: Fetch Fixtures ONLY for Registered Leagues (Hybrid Strategy)
                // First, try generic daily call
                btn.innerHTML = '<i class="fa-solid fa-wand-sparkles fa-spin mr-2"></i>Caricamento partite (strategia ibrida)...';
                let allFixtures = await window.loadDailyFixtures(selectedDate, null, false);

                if (!allFixtures || allFixtures.length === 0) {
                    throw new Error("Nessuna partita trovata su API-Football per questa data.");
                }

                console.log(`[Postino] üì• Scaricate ${allFixtures.length} fixtures totali dalla chiamata generica`);

                // Identify which registered leagues are MISSING in the generic response
                const leaguesInPool = new Set(allFixtures.map(f => f.league.id));
                const missingLeagueIds = registryLeagueIds.filter(id => !leaguesInPool.has(id));

                // Fetch missing leagues in parallel
                if (missingLeagueIds.length > 0) {
                    console.log(`[Postino] üîÑ ${missingLeagueIds.length} leghe mancanti, scaricando in parallelo...`);
                    btn.innerHTML = `<i class="fa-solid fa-wand-sparkles fa-spin mr-2"></i>Caricando ${missingLeagueIds.length} leghe mancanti...`;

                    const season = selectedDate.split('-')[0]; // Extract year
                    const fetchPromises = missingLeagueIds.map(async (leagueId) => {
                        try {
                            if (typeof window.getFootballData !== 'function') return [];
                            const result = await window.getFootballData({
                                endpoint: 'fixtures',
                                params: { league: leagueId, date: selectedDate, season: season }
                            });

                            const data = result.data;
                            if (data.response && data.response.length > 0) {
                                console.log(`[Postino] ‚úÖ League ${leagueId}: ${data.response.length} fixtures`);
                                return data.response.map(f => ({
                                    fixture: { id: f.fixture.id, date: f.fixture.date, status: f.fixture.status, timestamp: f.fixture.timestamp },
                                    teams: {
                                        home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
                                        away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo }
                                    },
                                    league: { id: f.league.id, name: f.league.name, country: f.league.country, logo: f.league.logo },
                                    score: f.score,
                                    goals: f.goals
                                }));
                            }
                            return [];
                        } catch (err) {
                            console.error(`[Postino] Error fetching league ${leagueId}:`, err);
                            return [];
                        }
                    });

                    const additionalFixtures = await Promise.all(fetchPromises);
                    const flatAdditional = additionalFixtures.flat();
                    allFixtures = [...allFixtures, ...flatAdditional];
                    console.log(`[Postino] ‚úÖ Totale fixtures dopo hybrid fetch: ${allFixtures.length}`);
                }

                // üî• STEP 3: Filter to ONLY Registered Leagues
                const fixtures = allFixtures.filter(f => registryLeagueIds.includes(f.league.id));
                console.log(`[Postino] ‚úÇÔ∏è Filtrate solo leghe del Registro: ${fixtures.length} partite (da ${allFixtures.length} totali)`);

                if (fixtures.length === 0) {
                    throw new Error(`Nessuna partita trovata per le leghe configurate il ${selectedDate}.`);
                }

                const magiaMatchesStored = [];
                fixtures.forEach(f => {
                    const apiId = parseInt(f.league.id);
                    const matchEntry = registryMap.get(apiId);

                    // üî• MATCHING RIGIDO: Solo leagueId esatti (NO fallback per nome)
                    if (matchEntry) {
                        // üî• NORMALIZZAZIONE NOME LEGA: ISO ‚Üí FIFA + Prefisso Continente
                        // üßº Professional Cleaner (v12.1): Use canonical name from Registry if matched by ID
                        const canonicalEntry = window.leaguesRegistryById?.get(parseInt(f.league.id));
                        let legaNormalized = canonicalEntry ? canonicalEntry.name.toLowerCase() : matchEntry.name.toLowerCase();

                        // Se NON √® nel registro, procediamo con la normalizzazione standard
                        if (!canonicalEntry) {

                            // STEP 1: Normalizza codice paese ISO ‚Üí FIFA (per consistenza con CSV Betmines)
                            // Supporta sia "iso rest" che "eu-iso rest"
                            const countryCodeMatch = legaNormalized.match(/(?:^|[a-z]{2}-)([a-z]{3})\s(.+)$/);
                            if (countryCodeMatch) {
                                const [fullMatch, isoCode, rest] = countryCodeMatch;

                                // Mapping ISO-3166 ‚Üí FIFA (casi problematici noti - in lowercase)
                                const isoToFifaMap = {
                                    'prt': 'por',  // Portogallo (ISO: PRT, FIFA: POR)
                                    'nld': 'ned',  // Olanda (ISO: NLD, FIFA: NED)
                                    'rou': 'rom',  // Romania (ISO: ROU, FIFA: ROM)
                                    'svn': 'slo',  // Slovenia (ISO: SVN, FIFA: SLO)
                                    'sau': 'ksa',  // Arabia Saudita (ISO: SAU, FIFA: KSA)
                                    'are': 'uae',  // Emirati Arabi (ISO: ARE, FIFA: UAE)
                                    'sui': 'sui',  // Svizzera
                                    'ger': 'ger',  // Germania
                                    'den': 'den',  // Danimarca
                                    'gre': 'gre',  // Grecia
                                    'cze': 'cze',  // Rep. Ceca
                                    'cro': 'cro',  // Croazia
                                    'eng': 'eng',  // Inghilterra
                                    'sco': 'sco',  // Scozia
                                    'wal': 'wal',  // Galles
                                    'nir': 'nir',  // Irlanda del Nord
                                    'esp': 'esp',  // Spagna
                                    'fra': 'fra',  // Francia
                                    'ita': 'ita',  // Italia
                                    'bel': 'bel',  // Belgio
                                    'aut': 'aut',  // Austria
                                    'pol': 'pol',  // Polonia
                                    'bra': 'bra',  // Brasile
                                    'arg': 'arg'   // Argentina
                                };

                                const fifaCode = isoToFifaMap[isoCode] || isoCode;
                                if (fifaCode !== isoCode) {
                                    // Se c'era un prefisso (es. eu-), lo manteniamo
                                    const prefixMatch = fullMatch.match(/^([a-z]{2}-)/);
                                    const prefix = prefixMatch ? prefixMatch[1] : '';

                                    legaNormalized = `${prefix}${fifaCode} ${rest}`;
                                    console.log(`[Pulsantone-FIFA] ‚úÖ iso‚Üífifa: ${isoCode} ‚Üí ${fifaCode} (Full: ${legaNormalized})`);
                                }
                            }

                            // STEP 2: Aggiunge prefisso continente se mancante
                            const countryCode = f.league.country?.toLowerCase() || '';
                            if (legaNormalized.match(/^[a-z]{3}\s/)) {
                                // Lega inizia con codice 3 lettere ‚Üí aggiungi continente
                                const continentMap = {
                                    'netherlands': 'eu-', 'england': 'eu-', 'germany': 'eu-', 'italy': 'eu-',
                                    'spain': 'eu-', 'france': 'eu-', 'portugal': 'eu-', 'belgium': 'eu-',
                                    'scotland': 'eu-', 'turkey': 'eu-', 'greece': 'eu-', 'poland': 'eu-',
                                    'romania': 'eu-', 'austria': 'eu-', 'switzerland': 'eu-', 'czech-republic': 'eu-',
                                    'denmark': 'eu-', 'norway': 'eu-', 'sweden': 'eu-', 'finland': 'eu-',
                                    'croatia': 'eu-', 'serbia': 'eu-', 'ukraine': 'eu-', 'russia': 'eu-',
                                    'northern-ireland': 'eu-', 'wales': 'eu-', 'ireland': 'eu-',
                                    'bulgaria': 'eu-', 'slovakia': 'eu-', 'hungary': 'eu-', 'slovenia': 'eu-',
                                    'bosnia': 'eu-', 'albania': 'eu-', 'macedonia': 'eu-', 'montenegro': 'eu-',
                                    'luxembourg': 'eu-', 'cyprus': 'eu-', 'malta': 'eu-', 'iceland': 'eu-',
                                    'estonia': 'eu-', 'latvia': 'eu-', 'lithuania': 'eu-', 'georgia': 'eu-',
                                    'brazil': 'sa-', 'argentina': 'sa-', 'chile': 'sa-', 'colombia': 'sa-',
                                    'uruguay': 'sa-', 'paraguay': 'sa-', 'bolivia': 'sa-', 'ecuador': 'sa-',
                                    'peru': 'sa-', 'venezuela': 'sa-',
                                    'usa': 'na-', 'mexico': 'na-', 'canada': 'na-', 'costa-rica': 'na-',
                                    'honduras': 'na-', 'panama': 'na-', 'jamaica': 'na-', 'guatemala': 'na-',
                                    'egypt': 'af-', 'morocco': 'af-', 'tunisia': 'af-', 'algeria': 'af-',
                                    'south-africa': 'af-', 'nigeria': 'af-', 'ghana': 'af-', 'kenya': 'af-',
                                    'uganda': 'af-', 'tanzania': 'af-', 'senegal': 'af-', 'cameroon': 'af-',
                                    'ivory-coast': 'af-', 'mali': 'af-', 'zambia': 'af-', 'zimbabwe': 'af-',
                                    'japan': 'as-', 'south-korea': 'as-', 'china': 'as-', 'australia': 'as-',
                                    'saudi-arabia': 'as-', 'uae': 'as-', 'qatar': 'as-', 'india': 'as-',
                                    'thailand': 'as-', 'vietnam': 'as-', 'malaysia': 'as-', 'singapore': 'as-',
                                    'indonesia': 'as-', 'philippines': 'as-', 'hong-kong': 'as-', 'uzbekistan': 'as-'
                                };

                                const prefix = continentMap[countryCode] || '';
                                if (prefix && !legaNormalized.startsWith(prefix)) {
                                    legaNormalized = prefix + legaNormalized;
                                    console.log(`[Pulsantone-Normalization] ‚úÖ ${matchEntry.name} ‚Üí ${legaNormalized}`);
                                }
                            }
                        } // Fine blocco if (!canonicalEntry)

                        // üî• SANDBOX PULITA: Solo dati strutturali per il calcolo AI
                        magiaMatchesStored.push({
                            id: f.fixture.id,                          // ID numerico puro (NO prefisso)
                            fixtureId: f.fixture.id,                   // ID partita API-Football
                            // Protocollo Timezone: Original UTC Timestamp
                            kickoffTimestamp: f.fixture.timestamp * 1000,
                            partita: `${f.teams.home.name} - ${f.teams.away.name}`,
                            home: f.teams.home.name,
                            away: f.teams.away.name,
                            lega: legaNormalized,
                            data: selectedDate,
                            // Protocollo Timezone: Italy Time for display
                            ora: new Intl.DateTimeFormat('it-IT', { timeZone: 'Europe/Rome', hour: '2-digit', minute: '2-digit', hour12: false }).format(new Date(f.fixture.date)).replace('.', ':'),
                            leagueId: f.league.id,                     // ID lega API-Football
                            teamIdHome: f.teams.home.id,               // ID squadra casa
                            teamIdAway: f.teams.away.id,               // ID squadra trasferta
                            magia: 'AI'                                // Tag obbligatorio per filtri Step 1/2
                            // üî• Campi vuoti per lo Step 1: tip, quota, probabilita, score, magicStats, etc.
                        });
                    }
                });

                // üî• PULISCE SANDBOX PRIMA DI SALVARE (evita duplicati e dati vecchi)
                await window.LocalDB.clearMagiaStore();
                await window.LocalDB.saveMagiaMatches(magiaMatchesStored);

                // üî• NEW: "Filling Gaps" - Inserimento silenzioso nel Database Oro
                let addedToOro = 0;
                try {
                    // Carica Database Oro aggiornato
                    const oroMatches = await window.LocalDB.getAllMatches();
                    const oroFixtureIds = new Set(oroMatches.map(m => m.fixtureId ? String(m.fixtureId) : null).filter(id => id));

                    const matchesToAddToOro = [];
                    console.log('[Magia-GapFill DEBUG] üîç Starting gap-fill...');
                    console.log('[Magia-GapFill DEBUG] Sandbox partite:', magiaMatchesStored.length);
                    console.log('[Magia-GapFill DEBUG] Oro partite:', oroMatches.length);
                    console.log('[Magia-GapFill DEBUG] Oro fixtureIds available:', oroFixtureIds.size);

                    magiaMatchesStored.forEach(m => {
                        const fixtureIdStr = String(m.fixtureId);
                        console.log(`[Magia-GapFill DEBUG] Checking: ${m.partita} | fixtureId: ${fixtureIdStr}`);

                        const existingMatch = oroMatches.find(om => String(om.fixtureId) === fixtureIdStr);

                        if (existingMatch) {
                            // üî• CONSENSO: Match presente in entrambe le fonti (CSV Betmines + Magia AI)
                            existingMatch.magia = 'OK';
                            console.log(`[Magia-GapFill DEBUG] ‚úÖ MATCH FOUND! ${m.partita} ‚Üí magia: 'OK'`);
                        } else {
                            console.log(`[Magia-GapFill DEBUG] ‚ùå NO MATCH for fixtureId ${fixtureIdStr} in Oro DB`);
                            // Partita mancante ‚Üí Aggiungi come record AI puro
                            matchesToAddToOro.push({
                                ...m
                                // ID e magia: 'AI' sono gi√† corretti dalla Sandbox
                            });
                            addedToOro++;
                        }
                    });

                    console.log('[Magia-GapFill DEBUG] Consenso partite:', magiaMatchesStored.length - addedToOro);
                    console.log('[Magia-GapFill DEBUG] Nuove partite da aggiungere:', addedToOro);

                    if (matchesToAddToOro.length > 0) {
                        const newOroList = [...oroMatches, ...matchesToAddToOro];
                        await window.LocalDB.saveMatches(newOroList);
                        // Aggiorna variabile globale se presente
                        if (window.allMatches) window.allMatches = newOroList;
                        console.log(`[Magia-GapFill] üöÄ Aggiunti ${addedToOro} match mancanti al Database Oro.`);
                    }
                } catch (e) {
                    console.error("[Magia-GapFill] Error during Oro integration", e);
                }

                // üî• POPOLA E MOSTRA TABELLA SANDBOX
                const sandboxContainer = document.getElementById('sandbox-preview-container');
                const sandboxTbody = document.getElementById('sandbox-preview-tbody');

                if (sandboxContainer && sandboxTbody) {
                    sandboxTbody.innerHTML = magiaMatchesStored.map((m, i) => `
                        <tr class="border-b border-purple-50 hover:bg-purple-50 transition-colors">
                            <td class="p-2 font-bold text-purple-600">${i + 1}</td>
                            <td class="p-2 font-semibold">${m.partita}</td>
                            <td class="p-2 text-purple-700">${m.lega}</td>
                            <td class="p-2 text-center">${m.data}</td>
                            <td class="p-2 text-center">${m.ora}</td>
                            <td class="p-2 text-center font-mono text-indigo-600">${m.id}</td>
                            <td class="p-2 text-center font-mono ${m.fixtureId ? 'text-green-600 font-bold' : 'text-red-500'}">${m.fixtureId || '‚ùå'}</td>
                            <td class="p-2 text-center font-mono">${m.leagueId || '-'}</td>
                            <td class="p-2 text-center font-mono text-xs">${m.teamIdHome || '-'}</td>
                            <td class="p-2 text-center font-mono text-xs">${m.teamIdAway || '-'}</td>
                            <td class="p-2 text-center"><span class="px-2 py-0.5 bg-purple-100 text-purple-700 rounded-full font-bold">${m.magia}</span></td>
                        </tr>
                    `).join('');

                    sandboxContainer.classList.remove('hidden');

                    // Scroll alla tabella
                    sandboxContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }

                // Alert sintetico
                alert(`‚úÖ SANDBOX PREPARATA: ${magiaMatchesStored.length} match pronti per il calcolo AI.
üì¶ DATABASE ORO: ${addedToOro} match AI aggiunti come gap-filling.

üî¨ Controlla la tabella qui sotto per verificare tutti i dati strutturali.`);

                // üî• REFRESH UI
                if (typeof loadMatchesFromDB === 'function') {
                    console.log("[Magia-GapFill] üîÑ Triggering UI Refresh...");
                    await loadMatchesFromDB();
                }
            } catch (err) {
                console.error("[Magia AI Postino Error]", err);
                alert("Errore Postino: " + err.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalHTML;
            }
        }

        async function viewMagiaAIResults() {
            try {
                const matches = await window.LocalDB.loadMagiaMatches();
                if (!matches || matches.length === 0) {
                    alert("Socio, non c'√® niente nella Sandbox! Carica prima le partite. üîÆ");
                    return;
                }

                const tableRows = matches.sort((a, b) => (b.smartScore || 0) - (a.smartScore || 0)).map(m => {
                    const trustColor = m.trust === 'TRUSTED_ELITE' || m.trust === 'TRUSTED_SAFEGUARD' ? 'text-green-600' : 'text-amber-500';

                    // üî• DEFENSE: Se il dato AI √® grezzo
                    const tipVal = m.tip || '<span class="italic text-gray-400">Da Calcolare</span>';
                    const probVal = m.probabilita ? `${m.probabilita}%` : '<span class="text-gray-400">...</span>';
                    const quotaVal = m.quota || (m.quota1 ? `@${m.quota1}` : '-');

                    return `
                    <tr class="hover:bg-purple-50 transition-colors border-b border-purple-100">
                        <td class="p-2 text-[10px] text-gray-500 font-mono">${m.ora}</td>
                        <td class="p-2">
                            <div class="text-xs font-bold text-gray-800">${m.partita}</div>
                            <div class="flex items-center gap-1">
                                <div class="text-[9px] text-purple-600 font-black uppercase tracking-tighter">${m.lega}</div>
                                <span class="text-[8px] font-bold ${trustColor}">[${m.trWR || 'WR?'}]</span>
                            </div>
                        </td>
                        <td class="p-2 text-center">
                            <span class="px-2 py-0.5 bg-purple-100 text-purple-700 rounded-full text-[10px] font-black">${tipVal}</span>
                        </td>
                        <td class="p-2 text-center text-xs font-bold">${probVal}</td>
                        <td class="p-2 text-center text-xs font-bold text-indigo-600">${quotaVal}</td>
                        <td class="p-2 text-center">
                            <span class="px-2 py-0.5 ${m.quotaType === 'REAL' ? 'bg-green-100 text-green-700' : 'bg-amber-100 text-amber-700'} rounded-full text-[9px] font-bold">
                                ${m.quotaType || 'N/A'}
                            </span>
                        </td>
                        <td class="p-2 text-center font-black text-xs text-purple-700">${m.smartScore || 0}</td>
                    </tr>`;
                }).join('');

                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-75 z-[10000] flex items-center justify-center p-4';
                modal.id = 'magia-view-modal';
                modal.innerHTML = `
                    <div class="bg-white rounded-3xl w-full max-w-4xl max-h-[90vh] overflow-hidden shadow-2xl flex flex-col animate-fade-in border-4 border-purple-100">
                        <header class="p-6 bg-gradient-to-r from-purple-600 to-indigo-600 text-white flex justify-between items-center shrink-0">
                            <div>
                                <h2 class="text-xl font-black flex items-center gap-2">
                                    <i class="fa-solid fa-wand-magic-sparkles"></i> 
                                    Elite Dashboard (${matches.length} Match)
                                </h2>
                                <p class="text-purple-100 text-[10px] font-bold uppercase tracking-widest mt-1">Filtro Trust 18.000 Match Attivo</p>
                            </div>
                            <button onclick="document.getElementById('magia-view-modal').remove()" class="bg-white/20 hover:bg-white/30 p-2 rounded-full transition-colors w-10 h-10 flex items-center justify-center">
                                <i class="fa-solid fa-xmark text-xl"></i>
                            </button>
                        </header>
                        <div class="overflow-y-auto flex-1 p-0">
                            <table class="w-full text-left border-collapse">
                                <thead class="sticky top-0 bg-gray-50 z-10 shadow-sm">
                                    <tr>
                                        <th class="p-3 text-[10px] text-gray-400 uppercase font-black">Ora</th>
                                        <th class="p-3 text-[10px] text-gray-400 uppercase font-black">Match / Lega / WR</th>
                                        <th class="p-3 text-[10px] text-gray-400 uppercase font-black text-center">AI Tip</th>
                                        <th class="p-3 text-[10px] text-gray-400 uppercase font-black text-center">Prob</th>
                                        <th class="p-3 text-[10px] text-gray-400 uppercase font-black text-center">Quota</th>
                                        <th class="p-3 text-[10px] text-gray-400 uppercase font-black text-center">Tipo</th>
                                        <th class="p-3 text-[10px] text-gray-400 uppercase font-black text-center text-purple-600">Smart Score</th>
                                    </tr>
                                </thead>
                                <tbody>${tableRows}</tbody>
                            </table>
                        </div>
                        <footer class="p-4 bg-gray-50 border-t flex justify-end gap-3 shrink-0">
                             <button onclick="document.getElementById('magia-view-modal').remove()" class="px-6 py-2 bg-gray-200 text-gray-700 rounded-xl font-bold hover:bg-gray-300 transition-colors">Chiudi</button>
                             <button onclick="window.downloadMagiaAICSV()" class="px-6 py-2 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700 transition-colors shadow-lg flex items-center gap-2">
                                <i class="fa-solid fa-download"></i> Scarica CSV
                             </button>
                        </footer>
                    </div>
                `;
                document.body.appendChild(modal);
            } catch (e) {
                console.error("[View Magia Error]", e);
                alert("Errore visualizzazione: " + e.message);
            }
        }

        async function downloadMagiaAICSV() {
            try {
                const matches = await window.LocalDB.loadMagiaMatches();
                if (!matches || matches.length === 0) {
                    alert("Nessun dato da scaricare. Socio, caricali prima!");
                    return;
                }

                // CSV Header compatible with Betmines + our stats
                let csv = "Lega,Ora,Partita,Risultato,Probabilit√†,Mercato,Tip,Quota,QuotaType,SmartScore\n";

                // Rows
                matches.forEach(m => {
                    let mercato = "1X2";
                    const tip = m.tip || '';
                    if (tip.match(/Over|Under/)) mercato = "Numero di gol";
                    else if (tip === 'Gol') mercato = "Entrambe segnano";
                    else if (tip.includes('X') || tip === '12') mercato = "Double Chance";

                    csv += `"${m.lega}","${m.ora}","${m.partita}","","${m.probabilita || 0}%","${mercato}","${m.tip || 'DA CALCOLARE'}","${m.quota || 0}","${m.quotaType || 'N/A'}","${m.smartScore || 0}"\n`;
                });

                // Download
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                const dateStr = new Date().toISOString().split('T')[0];
                link.setAttribute("href", url);
                link.setAttribute("download", `Magia_AI_Predictions_${dateStr}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                console.log(`[Magia AI] CSV scaricato con successo (${matches.length} match).`);
            } catch (e) {
                console.error("[Download Magia Error]", e);
            }
        }

        // Expose to window for inline onclick
        window.downloadMagiaAICSV = downloadMagiaAICSV;
    </script>
</body>

</html>