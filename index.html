<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-50">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öΩ Mpetaz Tips v3.3 - Magic Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css" rel="stylesheet">
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: 'Inter', sans-serif; }
        .noUi-connect { background: #3b82f6; }
        .noUi-handle { border-radius: 9999px; }
        .page { display: none; }
        .page.active { display: block; }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 4px; }
        .tip-button.active { background-color: #3b82f6; color: white; border-color: #3b82f6; font-weight: 600; }
        .sortable-header { cursor: pointer; transition: background-color 0.2s; }
        .sortable-header:hover { background-color: #e5e7eb; }
        .sort-icon { opacity: 0.5; transition: opacity 0.2s; }
        .sortable-header.active .sort-icon { opacity: 1; color: #3b82f6; }
        .favorite-star { cursor: pointer; color: #d1d5db; transition: color 0.2s, transform 0.2s; }
        .favorite-star.is-favorite { color: #f59e0b; }
        .favorite-star:hover { transform: scale(1.2); }
        .team-green { color: #10b981; font-weight: 600; }
        .team-yellow { color: #f59e0b; font-weight: 600; }
        .team-red { color: #ef4444; font-weight: 600; }
        .team-gray { color: #9ca3af; font-weight: 500; }
        .team-black { color: #374151; }
        .score-badge { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: bold;
        }
        .ht-badge-high { 
            background-color: #10b981; 
            color: white; 
            padding: 2px 8px; 
            border-radius: 8px; 
            font-size: 0.7rem; 
            font-weight: 600;
        }
        .ht-badge-medium { 
            background-color: #f59e0b; 
            color: white; 
            padding: 2px 8px; 
            border-radius: 8px; 
            font-size: 0.7rem; 
            font-weight: 600;
        }
        .ht-badge-low { 
            background-color: #9ca3af; 
            color: white; 
            padding: 2px 8px; 
            border-radius: 8px; 
            font-size: 0.7rem; 
            font-weight: 600;
        }
        .ht-badge-none { 
            color: #d1d5db; 
            font-size: 0.7rem;
        }
    </style>
</head>
<body class="h-full text-gray-800">
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center max-w-md px-4">
            <div id="loading-spinner" class="text-white text-xl font-semibold animate-pulse mb-2">Inizializzazione...</div>
            <div id="auth-status" class="text-blue-200 text-sm font-mono bg-gray-800 p-2 rounded border border-gray-700">Attesa connessione...</div>
            <button id="retry-auth-btn" class="hidden mt-4 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Riprova</button>
        </div>
    </div>
    
    <div class="min-h-full flex flex-col">
        <!-- Header -->
        <header class="bg-white shadow-sm">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center py-4">
                    <div class="flex items-center space-x-3">
                        <i class="fa-solid fa-chart-line text-2xl text-blue-600"></i>
                        <h1 class="text-xl font-bold text-gray-900">Mpetaz Tips v3.3</h1>
                    </div>
                    <nav class="flex space-x-2 flex-wrap">
                        <button data-page="page-dashboard" class="nav-button bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold shadow-sm hover:bg-blue-700 transition-colors text-sm">
                            <i class="fa-solid fa-chart-bar mr-1"></i>Dashboard
                        </button>
                        <button data-page="page-oggi" class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-calendar-day mr-1"></i>Oggi
                        </button>
                        <button data-page="page-risultati" class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-check-circle mr-1"></i>Risultati
                        </button>
                        <button data-page="page-ranking" class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-trophy mr-1"></i>Ranking
                        </button>
                    </nav>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-grow">
            
            <!-- PAGINA DASHBOARD -->
            <div id="page-dashboard" class="page active max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Sticky Stats -->
                <div id="stats-container" class="sticky top-0 z-10 bg-gray-50/80 backdrop-blur-sm py-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-8"></div>
                
                <!-- Filters -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-8">
                    <div class="flex flex-col md:flex-row gap-4 mb-4 items-center">
                        <div class="relative flex-grow w-full">
                            <input type="text" id="search-input" placeholder="Cerca lega o squadra..." class="w-full p-2 pl-10 border rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                            <i class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        </div>
                        <div class="flex items-center gap-2 w-full md:w-auto">
                            <label class="text-sm font-medium text-gray-700">Periodo:</label>
                            <input type="date" id="filter-date-start" class="p-2 border rounded-lg">
                            <input type="date" id="filter-date-end" class="p-2 border rounded-lg">
                        </div>
                    </div>
                    
                    <!-- Saved Filters Section -->
                    <div class="border-t border-b border-gray-200 my-4 py-4">
                        <h4 class="text-sm font-medium text-gray-700 mb-2">Filtri Personalizzati</h4>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                            <div>
                                <label for="saved-filters-select" class="block text-xs font-medium text-gray-600">Carica una strategia</label>
                                <div class="flex gap-2">
                                    <select id="saved-filters-select" class="w-full p-2 border rounded-lg text-sm bg-gray-50">
                                        <option value="">Seleziona...</option>
                                    </select>
                                    <button id="load-filter-btn" class="bg-blue-600 text-white px-3 py-2 rounded-lg font-semibold text-sm">Carica</button>
                                    <button id="delete-filter-btn" class="bg-red-500 text-white px-3 py-2 rounded-lg font-semibold text-sm"><i class="fa-solid fa-trash"></i></button>
                                </div>
                            </div>
                            <div>
                                <label for="new-filter-name" class="block text-xs font-medium text-gray-600">Salva strategia attuale</label>
                                <input type="text" id="new-filter-name" placeholder="Nome della strategia..." class="w-full p-2 border rounded-lg text-sm">
                            </div>
                            <div>
                                <button id="save-filter-btn" class="w-full bg-green-600 text-white px-4 py-2 rounded-lg font-semibold text-sm">Salva Strategia</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <!-- LEFT COLUMN: Leagues -->
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <label class="block text-sm font-medium text-gray-700">Leghe</label>
                                <div>
                                    <button id="update-favorites-btn" class="text-xs text-green-600 hover:underline font-semibold mr-4">Aggiorna Preferiti</button>
                                    <button id="reset-leagues-btn" class="text-xs text-blue-600 hover:underline font-semibold">Azzera Leghe</button>
                                </div>
                            </div>
                            <div id="league-filters-grid" class="grid grid-cols-1 sm:grid-cols-2 gap-2"></div>
                        </div>
                        
                        <!-- RIGHT COLUMN: Sliders & Tips -->
                        <div class="space-y-4">
                            <!-- Probabilit√† Slider + Inputs -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Probabilit√† (%)</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="prob-min-input" min="0" max="100" value="0" class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                    <div class="flex-1">
                                        <div id="probability-slider" class="mx-2"></div>
                                    </div>
                                    <input type="number" id="prob-max-input" min="0" max="100" value="100" class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                </div>
                            </div>
                            
                            <!-- Quota Slider + Inputs -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Quota</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="odds-min-input" min="1.0" max="10.0" step="0.01" value="1.0" class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                    <div class="flex-1">
                                        <div id="odds-slider" class="mx-2"></div>
                                    </div>
                                    <input type="number" id="odds-max-input" min="1.0" max="10.0" step="0.01" value="10.0" class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                </div>
                            </div>
                            
                            <!-- Tips -->
                            <div class="pt-2">
                                <div class="flex justify-between items-center mb-1">
                                    <label class="block text-sm font-medium text-gray-700">Tips</label>
                                    <button id="reset-tips-btn" class="text-xs text-blue-600 hover:underline font-semibold">Azzera Tips</button>
                                </div>
                                <div id="tip-filters-container" class="w-full p-2 border rounded-lg bg-gray-50 flex flex-wrap gap-2"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-6 flex justify-end space-x-4">
                        <button id="export-filtered-btn" class="bg-green-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-green-700 transition-colors">
                            <i class="fa-solid fa-file-csv mr-2"></i>Esporta Filtrati
                        </button>
                        <button id="reset-filters-btn" class="bg-gray-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-gray-600 transition-colors">
                            <i class="fa-solid fa-arrows-rotate mr-2"></i>Reset Tutti i Filtri
                        </button>
                    </div>
                </div>
                
                <!-- Match List -->
                <div id="match-list-container" class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h3 class="text-xl font-bold mb-4">Partite filtrate (<span id="filtered-count">0</span>)</h3>
                    <div class="max-h-[60vh] overflow-y-auto custom-scrollbar">
                        <table class="w-full text-sm text-left">
                            <thead class="bg-gray-100 text-xs uppercase sticky top-0">
                                <tr>
                                    <th class="p-3 font-semibold sortable-header" data-sort="data">Data <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="lega">Lega <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="partita">Partita <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="mercato">Mercato <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="tip">Tip <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center">Ris.</th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="probabilita">Prob. <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="quota">Quota <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center" title="Orario partita (ora italiana)">Ora</th>
                                    <th class="p-3 font-semibold text-center" title="Over 0.5 HT - Info primo tempo">HT</th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="esito">Esito <i class="fa-solid fa-sort sort-icon"></i></th>
                                </tr>
                            </thead>
                            <tbody id="match-list-body" class="divide-y"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- PAGINA OGGI -->
            <div id="page-oggi" class="page max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4 border-b pb-2">üì• Carica Tips del Giorno</h2>
                    
                    <!-- Info ordine caricamento -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 text-sm">
                        <i class="fa-solid fa-circle-info text-blue-500 mr-2"></i>
                        <strong>Ordine libero:</strong> Puoi caricare prima Tips e poi HT, o viceversa. Il sistema far√† il merge automaticamente.
                    </div>
                    
                    <div class="space-y-6">
                        <div>
                            <label for="tips-date" class="block text-sm font-medium text-gray-700 mb-1">Data Partite</label>
                            <input type="date" id="tips-date" class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        
                        <!-- STEP 1: Tips principale -->
                        <div class="border-2 border-blue-200 rounded-lg p-4 bg-blue-50/30">
                            <label for="tips-csv-file" class="block text-sm font-medium text-gray-700 mb-1">
                                <span class="bg-blue-600 text-white text-xs px-2 py-1 rounded mr-2">TIPS</span>
                                File CSV Tips (senza risultati)
                            </label>
                            <input type="file" id="tips-csv-file" accept=".csv" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                            <div id="tips-file-status" class="mt-2 text-xs text-gray-500 hidden">
                                <i class="fa-solid fa-check-circle text-green-500 mr-1"></i>
                                <span id="tips-file-name"></span>
                            </div>
                        </div>
                        
                        <!-- STEP 2: HT opzionale -->
                        <div class="border-2 border-purple-200 rounded-lg p-4 bg-purple-50/30">
                            <label for="tips-ht-file" class="block text-sm font-medium text-gray-700 mb-1 flex items-center gap-2">
                                <span class="bg-purple-600 text-white text-xs px-2 py-1 rounded mr-2">HT</span>
                                File CSV 0.5 HT (Opzionale - per boost ranking)
                                <span class="text-xs text-gray-500 font-normal cursor-help" title="Aggiungi dati Over 0.5 HT per timing gol e boost ranking">
                                    <i class="fa-solid fa-circle-info"></i>
                                </span>
                            </label>
                            <input type="file" id="tips-ht-file" accept=".csv" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100">
                            <div id="ht-file-status" class="mt-2 text-xs text-gray-500 hidden">
                                <i class="fa-solid fa-check-circle text-green-500 mr-1"></i>
                                <span id="ht-file-name"></span> - <span id="ht-match-count"></span> partite con HT
                            </div>
                        </div>
                        
                        <div id="tips-upload-preview" class="hidden bg-gray-50 p-4 rounded-lg border"></div>
                    </div>
                </div>
                
                <!-- Gestione Giornate Tips -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4">üóëÔ∏è Gestione Giornate Caricate</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="delete-tips-date" class="block text-sm font-medium text-gray-700 mb-1">Seleziona data da cancellare</label>
                            <select id="delete-tips-date" class="w-full p-2 border rounded-lg">
                                <option value="">Seleziona una data...</option>
                            </select>
                        </div>
                        <button id="delete-tips-day-btn" class="w-full bg-red-600 text-white py-2 rounded-lg font-semibold hover:bg-red-700">
                            <i class="fa-solid fa-trash mr-2"></i>Cancella Giornata Selezionata
                        </button>
                        <div id="tips-days-info" class="text-sm text-gray-600"></div>
                    </div>
                </div>
            </div>

            <!-- PAGINA RISULTATI -->
            <div id="page-risultati" class="page max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4 border-b pb-2">‚úÖ Aggiorna Risultati</h2>
                    <div class="space-y-6">
                        <div>
                            <label for="results-date" class="block text-sm font-medium text-gray-700 mb-1">Data Risultati</label>
                            <input type="date" id="results-date" class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div>
                            <label for="results-csv-file" class="block text-sm font-medium text-gray-700 mb-1">File CSV Risultati (con risultati finali)</label>
                            <input type="file" id="results-csv-file" accept=".csv" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100">
                        </div>
                        <div id="results-upload-preview" class="hidden bg-gray-50 p-4 rounded-lg border"></div>
                    </div>
                </div>
                
                <!-- Gestione Giornate Risultati -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4">üóëÔ∏è Gestione Giornate con Risultati</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="delete-results-date" class="block text-sm font-medium text-gray-700 mb-1">Seleziona data da cancellare</label>
                            <select id="delete-results-date" class="w-full p-2 border rounded-lg">
                                <option value="">Seleziona una data...</option>
                            </select>
                        </div>
                        <button id="delete-results-day-btn" class="w-full bg-red-600 text-white py-2 rounded-lg font-semibold hover:bg-red-700">
                            <i class="fa-solid fa-trash mr-2"></i>Cancella Risultati Giornata Selezionata
                        </button>
                        <div id="results-days-info" class="text-sm text-gray-600"></div>
                    </div>
                </div>
            </div>

            <!-- PAGINA RANKING -->
            <div id="page-ranking" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Filtri Ranking -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4">üèÜ Ranking Partite del Giorno</h2>
                    <p class="text-sm text-gray-600 mb-6">Seleziona un filtro salvato e genera il ranking delle migliori partite</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <!-- Prima riga -->
                        <div>
                            <label class="block text-sm font-medium mb-1">Data Partite</label>
                            <input type="date" id="ranking-date" class="w-full p-3 border rounded-lg">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1">Filtro Strategia</label>
                            <select id="ranking-filter-select" class="w-full p-3 border rounded-lg bg-white">
                                <option value="">Nessun filtro (tutte le partite)</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Terza riga: Tip Target Trading -->
                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-1">üéØ Tip Target Trading (opzionale)</label>
                        <select id="ranking-target-tip" class="w-full p-3 border rounded-lg bg-white">
                            <option value="">-- Stesso tip del filtro --</option>
                            <optgroup label="üìä Dati Reali (da file caricato)">
                                <option value="0.5HT">Over 0.5 HT (da file HT)</option>
                            </optgroup>
                            <optgroup label="üîÆ Stime Matematiche">
                                <option value="+2.5">Over 2.5 FT</option>
                                <option value="+3.5">Over 3.5 FT</option>
                                <option value="+4.5">Over 4.5 FT</option>
                                <option value="-2.5">Under 2.5 FT</option>
                                <option value="-3.5">Under 3.5 FT</option>
                            </optgroup>
                        </select>
                        <p class="text-xs text-gray-500 mt-2">
                            <strong>üìä Dati Reali:</strong> Odds precise dal file caricato (‚úÖ)<br>
                            <strong>üîÆ Stime:</strong> Range calcolato matematicamente da correlazioni storiche
                        </p>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <div>
                            <label class="block text-sm font-medium mb-1">Score Minimo</label>
                            <input type="number" id="ranking-score-min" value="45" class="w-full p-3 border rounded-lg">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1">Max Partite da Mostrare</label>
                            <input type="number" id="ranking-max-matches" value="20" class="w-full p-3 border rounded-lg">
                        </div>
                    </div>
                    
                    <button id="generate-ranking-btn" class="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-3 rounded-lg font-bold hover:opacity-90">
                        <i class="fa-solid fa-magic mr-2"></i>Applica e Genera Ranking
                    </button>
                    
                    <!-- MAGIC BUTTON -->
                    <div class="mt-4 p-4 bg-gradient-to-r from-amber-50 to-orange-50 rounded-xl border-2 border-amber-300">
                        <div class="text-center mb-3">
                            <span class="text-2xl">üîÆ</span>
                            <h3 class="text-lg font-bold text-amber-800 inline ml-2">MAGIC TOP 5</h3>
                            <p class="text-xs text-amber-700 mt-1">Selezione automatica delle migliori partite basata su 12,000+ match storici</p>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <button id="magic-singole-btn" class="bg-gradient-to-r from-green-500 to-emerald-600 text-white py-3 px-4 rounded-lg font-bold hover:opacity-90 shadow-lg">
                                <i class="fa-solid fa-bullseye mr-2"></i>TOP 5 SINGOLE/MULTIPLE
                                <span class="block text-xs font-normal mt-1">Alta probabilit√†, score elevato</span>
                            </button>
                            <button id="magic-trading-btn" class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-3 px-4 rounded-lg font-bold hover:opacity-90 shadow-lg">
                                <i class="fa-solid fa-chart-line mr-2"></i>TOP 5 TRADING
                                <span class="block text-xs font-normal mt-1">Tardo pomeriggio/sera, HT+Over</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Risultati Ranking -->
                <div id="ranking-results"></div>
                
                <!-- MAGIC RESULTS (separati) -->
                <div id="magic-results" class="hidden"></div>
            </div>

        </main>
    </div>

    <!-- Modal -->
    <div id="modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-2xl p-6 max-w-md mx-4">
            <h3 id="modal-title" class="text-xl font-bold mb-4"></h3>
            <p id="modal-message" class="mb-6"></p>
            <div class="flex justify-end space-x-4">
                <button id="modal-cancel" class="bg-gray-200 px-4 py-2 rounded-lg font-semibold">Annulla</button>
                <button id="modal-confirm" class="bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold">Conferma</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, writeBatch, query, where, doc, addDoc, deleteDoc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        
        // ==================== CONFIGURAZIONE FIREBASE CORRETTA ====================
        const firebaseConfig = {
            apiKey: "AIzaSyCwAy4QfYlbxj4yBLnho3ZnO2_NaxzbVRQ", // Chiave fornita dall'utente
            authDomain: "betmines-pronostici.firebaseapp.com",
            projectId: "betmines-pronostici",
            storageBucket: "betmines-pronostici.firebasestorage.app",
            messagingSenderId: "716119578109",
            appId: "1:716119578109:web:01e8b9dad7b17c91d63594"
        };
        
        let db;
        let auth;
        
        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (error) {
            console.error("Critical Firebase Init Error:", error);
            document.getElementById('auth-status').textContent = "Errore critico inizializzazione.";
            document.getElementById('auth-status').classList.add('text-red-400');
        }
        
        // ==================== GLOBAL STATE ====================
        let allMatches = [];
        let dataToUpload = [];
        let filteredMatches = [];
        let savedFilters = [];
        let favoriteLeagues = [];
        let stagedFavoriteLeagues = [];
        let sortState = { column: 'data', direction: 'desc' };
        let lastGeneratedRanking = null;
        
        // HT MERGE STATE
        let rawMainData = [];
        let rawHtData = [];
        
        // API FOOTBALL CONFIG
        const API_FOOTBALL_KEY = '62706d306e456ad02769b5bf985b8973';
        const API_FOOTBALL_URL = 'https://v3.api-football.com';
        
        // MATCH TIMES CACHE (Firebase - condiviso tutti utenti, 24h)
        const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 ore
        
        // Salva orario in Firebase cache temporanea
        async function saveTimeToCache(date, partita, ora) {
            if (!ora || ora.trim() === '') return;
            
            try {
                const key = `${date}_${partita.replace(/[^a-zA-Z0-9]/g, '_')}`;
                await setDoc(doc(db, "match_times_temp", key), {
                    data: date,
                    partita: partita,
                    ora: ora,
                    timestamp: Date.now()
                });
            } catch(e) {
                console.error('[CACHE] Error saving time:', e);
            }
        }
        
        // Ottieni orario da Firebase cache
        async function getTimeFromCache(date, partita) {
            try {
                const key = `${date}_${partita.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const docSnap = await getDoc(doc(db, "match_times_temp", key));
                
                if (!docSnap.exists()) return null;
                
                const data = docSnap.data();
                
                // Check se >24h
                if (Date.now() - data.timestamp > CACHE_DURATION) {
                    // Expired, cancella
                    await deleteDoc(doc(db, "match_times_temp", key));
                    return null;
                }
                
                return data.ora;
            } catch(e) {
                console.error('[CACHE] Error getting time:', e);
                return null;
            }
        }
        
        // Cleanup automatico cache >24h (batch)
        async function cleanupExpiredTimes() {
            try {
                const q = query(collection(db, "match_times_temp"));
                const snapshot = await getDocs(q);
                
                const batch = writeBatch(db);
                let cleanedCount = 0;
                const now = Date.now();
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (now - data.timestamp > CACHE_DURATION) {
                        batch.delete(doc.ref);
                        cleanedCount++;
                    }
                });
                
                if (cleanedCount > 0) {
                    await batch.commit();
                    console.log(`[CACHE] Cleaned ${cleanedCount} expired times (>24h)`);
                }
            } catch(e) {
                console.error('[CACHE] Cleanup error:', e);
            }
        }
        
        // Stats cache
        async function getCacheStats() {
            try {
                const q = query(collection(db, "match_times_temp"));
                const snapshot = await getDocs(q);
                return {
                    total: snapshot.size,
                    items: snapshot.docs.map(d => d.data())
                };
            } catch(e) {
                return { total: 0, items: [] };
            }
        }
        let dailyFixturesCache = null; // Bulk cache giornaliero
        
        // ==================== FUZZY MATCHING ====================
        
        // Levenshtein distance
        function levenshteinDistance(a, b) {
            const matrix = [];
            
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[b.length][a.length];
        }
        
        // Fuzzy match team name
        function fuzzyMatchTeam(csvTeam, apiTeams) {
            const csvNorm = csvTeam.toLowerCase().trim();
            let bestMatch = null;
            let bestScore = Infinity;
            
            for (let apiTeam of apiTeams) {
                const apiNorm = apiTeam.toLowerCase().trim();
                
                // Match esatto
                if (csvNorm === apiNorm) return apiTeam;
                
                // Contains
                if (csvNorm.includes(apiNorm) || apiNorm.includes(csvNorm)) {
                    const distance = levenshteinDistance(csvNorm, apiNorm);
                    if (distance < bestScore) {
                        bestScore = distance;
                        bestMatch = apiTeam;
                    }
                }
                
                // Levenshtein
                const distance = levenshteinDistance(csvNorm, apiNorm);
                if (distance < bestScore) {
                    bestScore = distance;
                    bestMatch = apiTeam;
                }
            }
            
            // Accetta solo se distance < 5
            return bestScore < 5 ? bestMatch : null;
        }
        
        // ==================== BULK API FOOTBALL ====================
        
        // Carica tutte le fixtures del giorno (1 chiamata bulk)
        async function loadDailyFixtures(date) {
            console.log(`[API DEBUG] Loading fixtures for ${date}...`);
            
            // Check localStorage
            const cacheKey = `fixtures_${date}`;
            const cached = localStorage.getItem(cacheKey);
            
            if (cached) {
                const data = JSON.parse(cached);
                // Valido per 6 ore
                if (Date.now() - data.timestamp < 6 * 60 * 60 * 1000) {
                    console.log(`[API DEBUG] Using cached fixtures for ${date} (${data.fixtures.length} matches)`);
                    dailyFixturesCache = data.fixtures;
                    return data.fixtures;
                }
            }
            
            // Fetch da API
            try {
                console.log(`[API DEBUG] Fetching from API-Football...`);
                const url = `${API_FOOTBALL_URL}/fixtures?date=${date}`;
                console.log(`[API DEBUG] URL: ${url}`);
                
                const response = await fetch(url, {
                    headers: {
                        'x-rapidapi-key': API_FOOTBALL_KEY,
                        'x-rapidapi-host': 'v3.api-football.com'
                    }
                });
                
                console.log(`[API DEBUG] Response status: ${response.status}`);
                
                if (!response.ok) {
                    console.error(`[API DEBUG] API error: ${response.status} ${response.statusText}`);
                    return [];
                }
                
                const data = await response.json();
                apiCallsToday++;
                
                console.log(`[API DEBUG] Response data:`, data);
                
                const fixtures = data.response || [];
                console.log(`[API DEBUG] Loaded ${fixtures.length} fixtures (API calls today: ${apiCallsToday})`);
                
                // Salva in localStorage
                localStorage.setItem(cacheKey, JSON.stringify({
                    fixtures: fixtures,
                    timestamp: Date.now()
                }));
                
                dailyFixturesCache = fixtures;
                
                return fixtures;
            } catch(e) {
                console.error('[API DEBUG] Error fetching fixtures:', e);
                return [];
            }
        }
        
        // Trova fixture matchante con fuzzy matching
        function findMatchingFixture(csvMatch, fixtures) {
            if (!fixtures || fixtures.length === 0) return null;
            
            const [csvHome, csvAway] = csvMatch.split(' - ').map(t => t.trim());
            
            // Estrai tutti i nomi team dall'API
            const apiTeams = fixtures.flatMap(f => [
                f.teams.home.name,
                f.teams.away.name
            ]);
            
            // Fuzzy match
            const homeMatch = fuzzyMatchTeam(csvHome, apiTeams);
            const awayMatch = fuzzyMatchTeam(csvAway, apiTeams);
            
            if (!homeMatch || !awayMatch) return null;
            
            // Trova fixture con entrambi i team
            const fixture = fixtures.find(f => 
                f.teams.home.name === homeMatch && 
                f.teams.away.name === awayMatch
            );
            
            return fixture;
        }
        
        // Ottieni orario da bulk cache
        function getTimeFromBulkCache(date, match) {
            if (!dailyFixturesCache) return null;
            
            const fixture = findMatchingFixture(match, dailyFixturesCache);
            if (!fixture || !fixture.fixture || !fixture.fixture.date) return null;
            
            // Converti UTC a ora italiana
            const utcDate = new Date(fixture.fixture.date);
            const italianTime = new Date(utcDate.getTime() + (1 * 60 * 60 * 1000)); // UTC+1
            
            const hours = String(italianTime.getHours()).padStart(2, '0');
            const minutes = String(italianTime.getMinutes()).padStart(2, '0');
            
            return `${hours}:${minutes}`;
        }
        
        // ODDS CORRELATIONS LOOKUP TABLE - CALIBRATE SU 12,414 MATCH REALI
        // Aggiornato v3.3 con dati storici effettivi
        const ODDS_CORRELATIONS = {
            "+1.5": {
                "+2.5": {
                    // Basato su analisi: Over1.5@1.00-1.15 ‚Üí 63.5% Over2.5 ‚Üí @1.65
                    "1.00-1.15": [1.58, 1.72],
                    "1.10-1.20": [1.60, 1.75],
                    // Over1.5@1.15-1.25 ‚Üí 56.5% Over2.5 ‚Üí @1.86
                    "1.15-1.25": [1.78, 1.95],
                    "1.20-1.30": [1.80, 2.00],
                    // Over1.5@1.25-1.35 ‚Üí 51.6% Over2.5 ‚Üí @2.03
                    "1.25-1.35": [1.95, 2.15],
                    "1.30-1.40": [2.00, 2.20],
                    // Over1.5@1.35-1.50 ‚Üí 42.6% Over2.5 ‚Üí @2.47
                    "1.35-1.50": [2.35, 2.60],
                    "1.40-1.50": [2.40, 2.65]
                },
                "+3.5": {
                    // Basato su: Over1.5@1.00-1.15 ‚Üí 43.1% Over3.5 ‚Üí @2.44
                    "1.00-1.15": [2.30, 2.55],
                    "1.10-1.20": [2.35, 2.60],
                    // Over1.5@1.15-1.25 ‚Üí 34.5% Over3.5 ‚Üí @3.04
                    "1.15-1.25": [2.90, 3.20],
                    "1.20-1.30": [2.95, 3.25],
                    // Over1.5@1.25-1.35 ‚Üí 29.7% Over3.5 ‚Üí @3.54
                    "1.25-1.35": [3.35, 3.75],
                    "1.30-1.40": [3.45, 3.85]
                },
                "-2.5": {
                    "1.10-1.20": [2.50, 3.00],
                    "1.20-1.30": [2.20, 2.70],
                    "1.30-1.40": [2.00, 2.40]
                }
            },
            "+2.5": {
                "+3.5": {
                    "1.10-1.20": [1.50, 1.75],
                    "1.20-1.30": [1.70, 2.00],
                    "1.30-1.40": [1.90, 2.30],
                    "1.40-1.60": [2.10, 2.60]
                },
                "+4.5": {
                    "1.10-1.20": [2.30, 2.80],
                    "1.20-1.30": [2.50, 3.00],
                    "1.30-1.40": [2.70, 3.30]
                },
                "-3.5": {
                    "1.10-1.20": [2.00, 2.40],
                    "1.20-1.30": [1.80, 2.20],
                    "1.30-1.40": [1.60, 2.00]
                }
            }
        };
        
        // TOP LEGHE PER OVER (dalla nostra analisi)
        const TOP_OVER_LEAGUES = [
            'EU-FIN Kakkonen', 'EU-TUR Turkish Cup', 'EU-SVK Slovakia Cup',
            'EU-NOR Eliteserien', 'EU-NOR Obos-Ligaen', 'EU-FIN Veikkausliiga',
            'EU-NLD Eredivisie', 'EU-Champions League', 'NA-USA Major League Soccer',
            'EU-EST Meistriliiga', 'EU-SWE Ettan: North', 'EU-WAL Premier League',
            'EU-DEU 3. Liga', 'EU-SWE Ettan: South', 'EU-POL 1. Liga'
        ];
        
        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', async () => {
            const loadingOverlay = document.getElementById('loading-overlay');
            const authStatus = document.getElementById('auth-status');
            const retryBtn = document.getElementById('retry-auth-btn');
            
            // --- GESTIONE AUTH ---
            async function authenticate() {
                authStatus.textContent = "Connessione a Firebase...";
                authStatus.className = "text-blue-200 text-sm font-mono bg-gray-800 p-2 rounded border border-gray-700";
                retryBtn.classList.add('hidden');
                
                try {
                    await signInAnonymously(auth);
                    // Non nascondiamo ancora l'overlay, aspettiamo il caricamento dati
                    authStatus.textContent = "Autenticato. Caricamento dati...";
                    authStatus.className = "text-green-400 text-sm font-mono bg-gray-800 p-2 rounded border border-green-700";
                    
                    // Avvia l'app vera e propria
                    await startApp();
                    
                } catch (error) {
                    console.error("Auth Error:", error);
                    let msg = "Errore sconosciuto.";
                    if(error.code === 'auth/api-key-not-valid') {
                        msg = "CHIAVE API NON VALIDA. Controlla il codice HTML.";
                    } else if(error.code === 'auth/operation-not-allowed') {
                        msg = "AUTH ANONIMA NON ABILITATA in Firebase Console.";
                    } else {
                        msg = error.message;
                    }
                    
                    authStatus.innerHTML = `<strong class="text-red-500">ERRORE:</strong><br>${msg}`;
                    authStatus.className = "text-red-300 text-xs font-mono bg-red-900/50 p-2 rounded border border-red-700 text-left break-words";
                    document.getElementById('loading-spinner').textContent = "‚ö†Ô∏è Connessione Fallita";
                    document.getElementById('loading-spinner').classList.remove('animate-pulse');
                    retryBtn.classList.remove('hidden');
                }
            }
            
            retryBtn.addEventListener('click', authenticate);
            
            // --- START APP LOGIC ---
            async function startApp() {
                try {
                    await loadAllMatches();
                    await loadFavorites();
                    setupFilters();
                    populateFilters();
                    applyFiltersAndRender();
                    await loadSavedFilters();
                    
                    showPage('page-dashboard');
                    loadingOverlay.classList.add('hidden');
                } catch (e) {
                    console.error("Data Load Error:", e);
                    authStatus.textContent = "Errore caricamento dati Firestore.";
                    authStatus.classList.add('text-red-400');
                }
            }

            // Avvia flusso auth
            authenticate();
            
            // UI Elements
            const pages = document.querySelectorAll('.page');
            const navButtons = document.querySelectorAll('.nav-button');
            const filterDateStart = document.getElementById('filter-date-start');
            const filterDateEnd = document.getElementById('filter-date-end');
            const leagueFiltersGrid = document.getElementById('league-filters-grid');
            const tipFiltersContainer = document.getElementById('tip-filters-container');
            const probabilitySliderEl = document.getElementById('probability-slider');
            const oddsSliderEl = document.getElementById('odds-slider');
            const probMinInput = document.getElementById('prob-min-input');
            const probMaxInput = document.getElementById('prob-max-input');
            const oddsMinInput = document.getElementById('odds-min-input');
            const oddsMaxInput = document.getElementById('odds-max-input');
            const searchInput = document.getElementById('search-input');
            const sortableHeaders = document.querySelectorAll('.sortable-header');
            
            // Sliders Dashboard
            noUiSlider.create(probabilitySliderEl, {
                start: [0, 100],
                connect: true,
                range: { min: 0, max: 100 },
                step: 1,
                tooltips: false
            });
            
            noUiSlider.create(oddsSliderEl, {
                start: [1.0, 10.0],
                connect: true,
                range: { min: 1.0, max: 10.0 },
                step: 0.01,
                tooltips: false
            });
            
            // Sincronizzazione SLIDER ‚Üí INPUT (Probabilit√†)
            probabilitySliderEl.noUiSlider.on('update', (values) => {
                probMinInput.value = parseInt(values[0]);
                probMaxInput.value = parseInt(values[1]);
            });
            
            probabilitySliderEl.noUiSlider.on('set', () => {
                applyFiltersAndRender();
            });
            
            // Sincronizzazione INPUT ‚Üí SLIDER (Probabilit√†)
            probMinInput.addEventListener('change', () => {
                const min = parseInt(probMinInput.value) || 0;
                const max = parseInt(probMaxInput.value) || 100;
                if (min <= max) {
                    probabilitySliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });
            
            probMaxInput.addEventListener('change', () => {
                const min = parseInt(probMinInput.value) || 0;
                const max = parseInt(probMaxInput.value) || 100;
                if (min <= max) {
                    probabilitySliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });
            
            // Sincronizzazione SLIDER ‚Üí INPUT (Quota)
            oddsSliderEl.noUiSlider.on('update', (values) => {
                oddsMinInput.value = parseFloat(values[0]).toFixed(2);
                oddsMaxInput.value = parseFloat(values[1]).toFixed(2);
            });
            
            oddsSliderEl.noUiSlider.on('set', () => {
                applyFiltersAndRender();
            });
            
            // Sincronizzazione INPUT ‚Üí SLIDER (Quota)
            oddsMinInput.addEventListener('change', () => {
                const min = parseFloat(oddsMinInput.value) || 1.0;
                const max = parseFloat(oddsMaxInput.value) || 10.0;
                if (min <= max) {
                    oddsSliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });
            
            oddsMaxInput.addEventListener('change', () => {
                const min = parseFloat(oddsMinInput.value) || 1.0;
                const max = parseFloat(oddsMaxInput.value) || 10.0;
                if (min <= max) {
                    oddsSliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });
            
            // Buttons
            const resetFiltersBtn = document.getElementById('reset-filters-btn');
            const resetLeaguesBtn = document.getElementById('reset-leagues-btn');
            const resetTipsBtn = document.getElementById('reset-tips-btn');
            const exportFilteredBtn = document.getElementById('export-filtered-btn');
            const saveFilterBtn = document.getElementById('save-filter-btn');
            const loadFilterBtn = document.getElementById('load-filter-btn');
            const deleteFilterBtn = document.getElementById('delete-filter-btn');
            const updateFavoritesBtn = document.getElementById('update-favorites-btn');
            
            // Dates
            const today = new Date();
            filterDateEnd.value = today.toISOString().split('T')[0];
            const threeMonthsAgo = new Date(today);
            threeMonthsAgo.setMonth(today.getMonth() - 3);
            filterDateStart.value = threeMonthsAgo.toISOString().split('T')[0];
            
            document.getElementById('tips-date').value = today.toISOString().split('T')[0];
            document.getElementById('results-date').value = today.toISOString().split('T')[0];
            document.getElementById('ranking-date').value = today.toISOString().split('T')[0];
            
            // ==================== NAVIGATION ====================
            function showPage(pageId) {
                pages.forEach(p => p.classList.remove('active'));
                document.getElementById(pageId).classList.add('active');
                
                navButtons.forEach(btn => {
                    if (btn.dataset.page === pageId) {
                        btn.classList.remove('bg-gray-200', 'text-gray-700');
                        btn.classList.add('bg-blue-600', 'text-white');
                    } else {
                        btn.classList.remove('bg-blue-600', 'text-white');
                        btn.classList.add('bg-gray-200', 'text-gray-700');
                    }
                });
                
                if (pageId === 'page-oggi') updateTipsDaysList();
                if (pageId === 'page-risultati') updateResultsDaysList();
            }
            
            navButtons.forEach(btn => btn.addEventListener('click', (e) => showPage(e.currentTarget.dataset.page)));
            
            // ==================== LOAD DATA ====================
            async function loadAllMatches() {
                try {
                    const matchesCol = collection(db, "matches");
                    const snapshot = await getDocs(matchesCol);
                    allMatches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    allMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                } catch (e) {
                    console.error('Error loading matches:', e);
                    allMatches = [];
                }
            }
            
            function normalizeLega(lega) {
                return lega.replace(/\s+/g, ' ').trim();
            }
            
            // ==================== FILTERS ====================
            function setupFilters() {
                searchInput.addEventListener('input', applyFiltersAndRender);
                filterDateStart.addEventListener('change', applyFiltersAndRender);
                filterDateEnd.addEventListener('change', applyFiltersAndRender);
            }
            
            function categorizeLeague(leagueName) {
                if (favoriteLeagues.includes(leagueName)) return '‚≠ê Preferiti';
                if (leagueName.startsWith('EU-Champions League') || leagueName.startsWith('EU-Europa League') || leagueName.startsWith('EU-Europa Conference League')) return 'Coppe Europee';
                if (leagueName.includes('WCQ') || leagueName.endsWith('-NAZ')) return 'Competizioni Nazionali';
                if (/(Cup|Coppa|Copa|Beker|Ta√ßa)/i.test(leagueName)) return 'Coppe Nazionali';
                
                const continentMatch = leagueName.match(/^(AS|AF|NA|SA|OC)-/);
                if (continentMatch) return 'Resto del Mondo';
                
                const europeanPrefixes = ['EU-'];
                if (europeanPrefixes.some(prefix => leagueName.startsWith(prefix))) return 'Europa';
                
                return 'Non Classificati';
            }
            
            function populateFilters() {
                // Leagues categorizzate
                const leagues = [...new Set(allMatches.map(m => m.lega))];
                const categorized = leagues.reduce((acc, league) => {
                    const category = categorizeLeague(league);
                    if (!acc[category]) acc[category] = [];
                    acc[category].push(league);
                    return acc;
                }, {});
                
                const categoryOrder = ['‚≠ê Preferiti', 'Europa', 'Resto del Mondo', 'Coppe Europee', 'Competizioni Nazionali', 'Coppe Nazionali', 'Non Classificati'];
                leagueFiltersGrid.innerHTML = '';
                
                categoryOrder.forEach(category => {
                    if (!categorized[category] || categorized[category].length === 0) return;
                    
                    const box = document.createElement('div');
                    box.className = 'league-category-box bg-gray-50 border rounded-lg p-2 flex flex-col h-56';
                    
                    const leaguesInCategory = categorized[category].sort().map(league => `
                        <div class="flex items-center justify-between p-1 rounded hover:bg-blue-50 group">
                            <label class="flex items-center space-x-2 cursor-pointer flex-grow truncate">
                                <input type="checkbox" value="${league}" class="league-checkbox form-checkbox h-4 w-4 rounded text-blue-600 border-gray-300 focus:ring-blue-500">
                                <span class="text-sm text-gray-700 truncate" title="${league}">${league}</span>
                            </label>
                            <i class="fa-solid fa-star favorite-star ${stagedFavoriteLeagues.includes(league) ? 'is-favorite' : ''}" data-league="${league}"></i>
                        </div>`).join('');
                    
                    box.innerHTML = `
                        <h4 class="font-semibold text-xs uppercase text-gray-500 mb-1 sticky top-0 bg-gray-50 py-1">
                            <label class="flex items-center space-x-2 cursor-pointer">
                                <input type="checkbox" class="category-select-all form-checkbox h-4 w-4 rounded text-blue-600 border-gray-300 focus:ring-blue-500">
                                <span>${category}</span>
                            </label>
                        </h4>
                        <div class="flex-grow custom-scrollbar overflow-y-auto space-y-1 pl-2">${leaguesInCategory}</div>`;
                    
                    leagueFiltersGrid.appendChild(box);
                });
                
                leagueFiltersGrid.querySelectorAll('.league-checkbox').forEach(cb => {
                    cb.addEventListener('change', applyFiltersAndRender);
                });
                
                leagueFiltersGrid.querySelectorAll('.category-select-all').forEach(masterCb => {
                    masterCb.addEventListener('change', (e) => {
                        const isChecked = e.target.checked;
                        const categoryDiv = e.target.closest('.league-category-box');
                        categoryDiv.querySelectorAll('.league-checkbox').forEach(leagueCb => {
                            leagueCb.checked = isChecked;
                        });
                        applyFiltersAndRender();
                    });
                });
                
                leagueFiltersGrid.querySelectorAll('.favorite-star').forEach(star => {
                    star.addEventListener('click', handleFavoriteToggle);
                });
                
                // Predefined Tips by Market
                const predefinedTips = {
                    '1X2': ['1', 'X', '2'],
                    'Doppia Chance': ['1X', '12', 'X2'],
                    'Under/Over': ['-1.5', '+1.5', '-2.5', '+2.5', '-3.5', '+3.5'],
                    'Gol/No Gol': ['S√¨', 'No']
                };
                
                tipFiltersContainer.innerHTML = `<div class="grid grid-cols-2 md:grid-cols-4 gap-4">${Object.entries(predefinedTips).map(([market, tips]) => {
                    const tipButtons = tips.map(tip => `
                        <button data-tip="${tip}" class="tip-button w-full px-2 py-1 text-xs rounded-full border border-gray-300 bg-white hover:bg-gray-100 transition-colors">${tip}</button>
                    `).join('');
                    return `
                        <div>
                            <h4 class="font-semibold text-xs uppercase text-gray-500 mb-2">${market}</h4>
                            <div class="flex flex-wrap gap-2">${tipButtons}</div>
                        </div>
                    `;
                }).join('')}</div>`;
                
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('active');
                        applyFiltersAndRender();
                    });
                });
            }
            
            function applyFiltersAndRender() {
                const selectedLeagues = Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value);
                const selectedTips = Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip);
                const [probMin, probMax] = probabilitySliderEl.noUiSlider.get().map(v => parseInt(v));
                const [oddsMin, oddsMax] = oddsSliderEl.noUiSlider.get().map(v => parseFloat(v));
                const searchTerm = searchInput.value.toLowerCase().trim();
                const dateStart = filterDateStart.value ? new Date(filterDateStart.value) : null;
                const dateEnd = filterDateEnd.value ? new Date(filterDateEnd.value) : null;
                
                filteredMatches = allMatches.filter(m => {
                    if (selectedLeagues.length > 0 && !selectedLeagues.includes(m.lega)) return false;
                    if (selectedTips.length > 0 && !selectedTips.includes(m.tip)) return false;
                    if (m.probabilita < probMin || m.probabilita > probMax) return false;
                    if (m.quota < oddsMin || m.quota > oddsMax) return false;
                    
                    if (searchTerm) {
                        const matchText = `${m.lega} ${m.partita}`.toLowerCase();
                        if (!matchText.includes(searchTerm)) return false;
                    }
                    
                    if (dateStart || dateEnd) {
                        const matchDate = new Date(m.data || '2000-01-01');
                        if (dateStart && matchDate < dateStart) return false;
                        if (dateEnd && matchDate > dateEnd) return false;
                    }
                    
                    return true;
                });
                
                sortAndRenderMatches();
                updateStatsDisplay(filteredMatches);
            }
            
            function updateStatsDisplay(matches) {
                // SOLO partite con esito (vinte o perse)
                const matchesWithOutcome = matches.filter(m => m.esito === 'Vinto' || m.esito === 'Perso');
                const won = matchesWithOutcome.filter(m => m.esito === 'Vinto').length;
                const lost = matchesWithOutcome.filter(m => m.esito === 'Perso').length;
                const winRate = matchesWithOutcome.length > 0 ? (won / matchesWithOutcome.length) * 100 : 0;
                const totalStake = matchesWithOutcome.length;
                const profit = matchesWithOutcome.reduce((acc, m) => acc + (m.esito === 'Vinto' ? m.quota - 1 : -1), 0);
                const roi = totalStake > 0 ? (profit / totalStake * 100) : 0;
                
                const statsContainer = document.getElementById('stats-container');
                statsContainer.innerHTML = `
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-blue-600">${matchesWithOutcome.length}</div><div class="text-xs text-gray-600">Totale</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-green-600">${won}</div><div class="text-xs text-gray-600">Vinte</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-red-600">${lost}</div><div class="text-xs text-gray-600">Perse</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold ${winRate >= 70 ? 'text-green-600' : 'text-red-600'}">${winRate.toFixed(1)}%</div><div class="text-xs text-gray-600">Winrate</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold ${roi >= 0 ? 'text-green-600' : 'text-red-600'}">${roi.toFixed(1)}%</div><div class="text-xs text-gray-600">ROI</div></div>
                `;
            }
            
            function sortAndRenderMatches() {
                const { column, direction } = sortState;
                const sorted = [...filteredMatches].sort((a, b) => {
                    const valA = a[column];
                    const valB = b[column];
                    let comparison = 0;
                    if (typeof valA === 'string') comparison = valA.localeCompare(valB);
                    else comparison = valA - valB;
                    return direction === 'asc' ? comparison : -comparison;
                });
                renderMatchList(sorted);
                updateSortIcons();
            }
            
            function renderMatchList(matches) {
                const tbody = document.getElementById('match-list-body');
                document.getElementById('filtered-count').textContent = matches.length;
                
                const displayMatches = matches.slice(0, 200);
                const now = new Date();
                
                tbody.innerHTML = displayMatches.map(m => {
                    const esitoClass = m.esito === 'Vinto' ? 'text-green-600 font-bold' : m.esito === 'Perso' ? 'text-red-600 font-bold' : '';
                    
                    // Processo info HT
                    let htDisplay = '<span class="ht-badge-none">-</span>';
                    if (m.info_ht && m.info_ht.trim() !== '') {
                        // Estraggo prob da "76% (@1.33)"
                        const probMatch = m.info_ht.match(/(\d+)%/);
                        if (probMatch) {
                            const htProb = parseInt(probMatch[1]);
                            let badgeClass = 'ht-badge-low';
                            if (htProb >= 75) badgeClass = 'ht-badge-high';
                            else if (htProb >= 60) badgeClass = 'ht-badge-medium';
                            
                            htDisplay = `<span class="${badgeClass}">${m.info_ht}</span>`;
                        }
                    }
                    
                    // Processo ORA con badge smart
                    let timeDisplay = '<span class="text-gray-400">-</span>';
                    if (m.time && m.time.trim() !== '') {
                        const matchTime = m.time;
                        const [hours, minutes] = matchTime.split(':').map(n => parseInt(n));
                        
                        // Crea date per confronto (oggi con orario partita)
                        const matchDate = new Date();
                        matchDate.setHours(hours, minutes, 0, 0);
                        
                        const diffMinutes = (matchDate - now) / (1000 * 60);
                        
                        // Badge logica
                        if (Math.abs(diffMinutes) <= 15) {
                            // LIVE (¬±15 min)
                            timeDisplay = `<span class="text-red-600 font-bold">üî¥ ${matchTime}</span>`;
                        } else if (diffMinutes > 0 && diffMinutes <= 60) {
                            // IMMINENTE (<60 min)
                            timeDisplay = `<span class="text-orange-600 font-bold">‚è∞ ${matchTime}</span>`;
                        } else {
                            // Normale
                            timeDisplay = `<span class="text-gray-700">${matchTime}</span>`;
                        }
                    }
                    
                    return `
                        <tr class="hover:bg-gray-50">
                            <td class="p-3 text-xs">${m.data}</td>
                            <td class="p-3 text-xs">${m.lega}</td>
                            <td class="p-3 text-xs font-medium">${m.partita}</td>
                            <td class="p-3 text-xs">${m.mercato}</td>
                            <td class="p-3 text-xs font-semibold">${m.tip}</td>
                            <td class="p-3 text-xs text-center">${m.risultato || '-'}</td>
                            <td class="p-3 text-xs text-center">${m.probabilita}%</td>
                            <td class="p-3 text-xs text-center font-bold">${m.quota}</td>
                            <td class="p-3 text-xs text-center">${timeDisplay}</td>
                            <td class="p-3 text-xs text-center">${htDisplay}</td>
                            <td class="p-3 text-xs text-center ${esitoClass}">${m.esito || '-'}</td>
                        </tr>
                    `;
                }).join('');
                
                if (matches.length > 200) {
                    tbody.innerHTML += `<tr><td colspan="11" class="p-3 text-center text-sm text-gray-500">Mostrati primi 200 di ${matches.length}</td></tr>`;
                }
            }
            
            function updateSortIcons() {
                document.querySelectorAll('.sortable-header').forEach(header => {
                    const icon = header.querySelector('.sort-icon');
                    if (header.dataset.sort === sortState.column) {
                        header.classList.add('active');
                        if (sortState.direction === 'asc') {
                            icon.classList.remove('fa-sort', 'fa-sort-down');
                            icon.classList.add('fa-sort-up');
                        } else {
                            icon.classList.remove('fa-sort', 'fa-sort-up');
                            icon.classList.add('fa-sort-down');
                        }
                    } else {
                        header.classList.remove('active');
                        icon.classList.remove('fa-sort-up', 'fa-sort-down');
                        icon.classList.add('fa-sort');
                    }
                });
            }
            
            sortableHeaders.forEach(header => header.addEventListener('click', (e) => {
                const newColumn = e.currentTarget.dataset.sort;
                if (sortState.column === newColumn) {
                    sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.column = newColumn;
                    sortState.direction = ['data', 'probabilita', 'quota'].includes(newColumn) ? 'desc' : 'asc';
                }
                sortAndRenderMatches();
            }));
            
            // ==================== FAVORITES ====================
            const loadFavorites = async () => {
                try {
                    const favDocRef = doc(db, "preferences", "favoriteLeagues");
                    const docSnap = await getDoc(favDocRef);
                    if (docSnap.exists()) {
                        favoriteLeagues = docSnap.data().leagues || [];
                        stagedFavoriteLeagues = [...favoriteLeagues];
                    }
                } catch(e) { console.error("Error:", e); }
            };
            
            const handleUpdateFavorites = async () => {
                favoriteLeagues = [...stagedFavoriteLeagues];
                try {
                    await setDoc(doc(db, "preferences", "favoriteLeagues"), { leagues: favoriteLeagues });
                    populateFilters();
                    applyFiltersAndRender();
                    showModal("Successo", "Preferiti aggiornati!", () => {});
                } catch (e) {
                    showModal("Errore", `Errore: ${e.message}`, () => {});
                }
            };
            
            const handleFavoriteToggle = (e) => {
                const leagueName = e.target.dataset.league;
                if (stagedFavoriteLeagues.includes(leagueName)) {
                    stagedFavoriteLeagues = stagedFavoriteLeagues.filter(l => l !== leagueName);
                } else {
                    stagedFavoriteLeagues.push(leagueName);
                }
                e.target.classList.toggle('is-favorite');
            };
            
            updateFavoritesBtn.addEventListener('click', handleUpdateFavorites);
            
            // ==================== SAVED FILTERS ====================
            const loadSavedFilters = async () => {
                const presetsCollection = collection(db, "presets");
                const snapshot = await getDocs(presetsCollection);
                savedFilters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Popola dropdown Dashboard
                const select = document.getElementById('saved-filters-select');
                select.innerHTML = '<option value="">Seleziona...</option>' + savedFilters.map(f => `<option value="${f.id}">${f.name}</option>`).join('');
                
                // Popola dropdown Ranking
                const rankingSelect = document.getElementById('ranking-filter-select');
                rankingSelect.innerHTML = '<option value="">Nessun filtro (tutte le partite)</option>' + savedFilters.map(f => `<option value="${f.id}">${f.name}</option>`).join('');
            };
            
            const handleSaveFilter = async () => {
                const filterName = document.getElementById('new-filter-name').value.trim();
                if (!filterName) {
                    showModal("Errore", "Inserisci nome strategia.", () => {});
                    return;
                }
                const filterState = {
                    leagues: Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value),
                    tips: Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip),
                    prob: probabilitySliderEl.noUiSlider.get(),
                    odds: oddsSliderEl.noUiSlider.get(),
                    startDate: filterDateStart.value,
                    endDate: filterDateEnd.value
                };
                try {
                    await addDoc(collection(db, "presets"), { name: filterName, state: filterState });
                    showModal("Successo", `Strategia "${filterName}" salvata!`, () => {});
                    document.getElementById('new-filter-name').value = '';
                    await loadSavedFilters();
                } catch(e) {
                    showModal("Errore", `Errore: ${e.message}`, () => {});
                }
            };
            
            const handleLoadFilter = () => {
                const selectedId = document.getElementById('saved-filters-select').value;
                if (!selectedId) return;
                const selectedFilter = savedFilters.find(f => f.id === selectedId);
                if (!selectedFilter) return;
                
                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));
                
                selectedFilter.state.leagues.forEach(league => {
                    const cb = leagueFiltersGrid.querySelector(`input.league-checkbox[value="${league}"]`);
                    if (cb) cb.checked = true;
                });
                selectedFilter.state.tips.forEach(tip => {
                    const btn = tipFiltersContainer.querySelector(`.tip-button[data-tip="${tip}"]`);
                    if (btn) btn.classList.add('active');
                });
                
                probabilitySliderEl.noUiSlider.set(selectedFilter.state.prob);
                oddsSliderEl.noUiSlider.set(selectedFilter.state.odds);
                filterDateStart.value = selectedFilter.state.startDate;
                filterDateEnd.value = selectedFilter.state.endDate;
                
                applyFiltersAndRender();
            };
            
            const handleDeleteFilter = async () => {
                const selectedId = document.getElementById('saved-filters-select').value;
                if (!selectedId) return;
                if (!confirm('Eliminare questa strategia?')) return;
                try {
                    await deleteDoc(doc(db, "presets", selectedId));
                    showModal("Successo", "Strategia eliminata!", () => {});
                    await loadSavedFilters();
                } catch(e) {
                    showModal("Errore", `Errore: ${e.message}`, () => {});
                }
            };
            
            saveFilterBtn.addEventListener('click', handleSaveFilter);
            loadFilterBtn.addEventListener('click', handleLoadFilter);
            deleteFilterBtn.addEventListener('click', handleDeleteFilter);
            
            // ==================== RESET FILTERS ====================
            resetLeaguesBtn.addEventListener('click', () => {
                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                applyFiltersAndRender();
            });
            
            resetTipsBtn.addEventListener('click', () => {
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));
                applyFiltersAndRender();
            });
            
            resetFiltersBtn.addEventListener('click', () => {
                filterDateStart.value = '';
                filterDateEnd.value = '';
                searchInput.value = '';
                resetLeaguesBtn.click();
                resetTipsBtn.click();
                const probRange = probabilitySliderEl.noUiSlider.options.range;
                const oddsRange = oddsSliderEl.noUiSlider.options.range;
                probabilitySliderEl.noUiSlider.set([probRange.min, probRange.max]);
                oddsSliderEl.noUiSlider.set([oddsRange.min, oddsRange.max]);
                applyFiltersAndRender();
            });
            
            // ==================== EXPORT ====================
            exportFilteredBtn.addEventListener('click', () => {
                if (filteredMatches.length === 0) {
                    showModal("Errore", "Nessun dato da esportare.", () => {});
                    return;
                }
                const headers = ['data', 'lega', 'partita', 'risultato', 'probabilita', 'mercato', 'tip', 'quota', 'esito'];
                const csv = Papa.unparse(filteredMatches.map(d => ({...d, quota: String(d.quota).replace('.',',')})), { columns: headers });
                const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = 'tipster_filtrati.csv';
                link.click();
            });
            
            // ==================== TARGET ODDS SYSTEM ====================
            
            // Estrai odds da info_ht
            function extractHtOdds(infoHt) {
                if (!infoHt || infoHt.trim() === '') return null;
                
                const oddsMatch = infoHt.match(/@([\d.]+)/);
                if (oddsMatch) {
                    return parseFloat(oddsMatch[1]);
                }
                return null;
            }
            
            // Stima range odds basato su correlazioni
            function estimateOddsRange(tipAttuale, oddsAttuale, tipTarget) {
                // Trova range nella lookup table
                const correlations = ODDS_CORRELATIONS[tipAttuale]?.[tipTarget];
                if (!correlations) {
                    // Fallback: calcolo matematico
                    const probAttuale = 1 / oddsAttuale;
                    const probTarget = probAttuale * 0.70; // Stima conservativa
                    const oddsTarget = 1 / probTarget;
                    
                    return {
                        min: Math.round((oddsTarget * 0.90) * 100) / 100,
                        max: Math.round((oddsTarget * 1.10) * 100) / 100,
                        avg: oddsTarget
                    };
                }
                
                // Cerca range corretto
                for (let range in correlations) {
                    const [minRange, maxRange] = range.split('-').map(Number);
                    if (oddsAttuale >= minRange && oddsAttuale <= maxRange) {
                        const [minOdds, maxOdds] = correlations[range];
                        return {
                            min: minOdds,
                            max: maxOdds,
                            avg: (minOdds + maxOdds) / 2
                        };
                    }
                }
                
                // Fallback se non trovato range esatto
                const probAttuale = 1 / oddsAttuale;
                const probTarget = probAttuale * 0.70;
                const oddsTarget = 1 / probTarget;
                
                return {
                    min: Math.round((oddsTarget * 0.90) * 100) / 100,
                    max: Math.round((oddsTarget * 1.10) * 100) / 100,
                    avg: oddsTarget
                };
            }
            
            // Ottieni odds target (reale o stimato)
            function getTargetOdds(match, tipTarget) {
                if (!tipTarget || tipTarget === '') {
                    // Nessun target specificato, usa tip attuale
                    return {
                        source: 'data',
                        odds: match.quota,
                        min: match.quota,
                        max: match.quota,
                        display: `@${match.quota.toFixed(2)}`,
                        isEstimate: false
                    };
                }
                
                // CASO 1: Target √® 0.5 HT - abbiamo dato reale!
                if (tipTarget === '0.5HT') {
                    const htOdds = extractHtOdds(match.info_ht);
                    if (htOdds) {
                        return {
                            source: 'data',
                            odds: htOdds,
                            min: htOdds,
                            max: htOdds,
                            display: `@${htOdds.toFixed(2)}`,
                            isEstimate: false
                        };
                    }
                    return null; // HT non disponibile
                }
                
                // CASO 2: Target √® stesso tip - abbiamo dato reale!
                if (tipTarget === match.tip) {
                    return {
                        source: 'data',
                        odds: match.quota,
                        min: match.quota,
                        max: match.quota,
                        display: `@${match.quota.toFixed(2)}`,
                        isEstimate: false
                    };
                }
                
                // CASO 3: Target diverso - usa lookup table (pi√π accurato)
                const estimate = estimateOddsRange(match.tip, match.quota, tipTarget);
                return {
                    source: 'estimate',
                    odds: estimate.avg,
                    min: estimate.min,
                    max: estimate.max,
                    display: `@${estimate.min.toFixed(2)}-${estimate.max.toFixed(2)}`,
                    isEstimate: true
                };
            }
            
            // Calcola green con odds precise
            function calculateGreen(backStake, backOdds, layOdds) {
                const liability = backStake * (layOdds - 1);
                const backProfit = backStake * (backOdds - 1);
                
                // Green se lay vince (back perde)
                const greenLay = liability;
                // Green se back vince (lay perde) 
                const greenBack = backProfit - liability;
                
                // Usa il minore per essere conservativi
                return Math.min(greenLay, greenBack);
            }
            
            // Calcola green range con odds stimate
            function calculateGreenRange(backStake, backOdds, layOddsMin, layOddsMax) {
                const greenMin = calculateGreen(backStake, backOdds, layOddsMin);
                const greenMax = calculateGreen(backStake, backOdds, layOddsMax);
                
                return {
                    min: greenMin,
                    max: greenMax,
                    avg: (greenMin + greenMax) / 2
                };
            }
            
            // ==================== MATCH TIMES SYSTEM ====================
            
            // Carica cache orari da Firebase
            // Ottieni orario da API Football
            async function getTimeFromAPIFootball(date, teamHome, teamAway) {
                if (apiCallsToday >= 90) {
                    console.warn("API call limit reached today");
                    return null;
                }
                
                try {
                    const response = await fetch(`${API_FOOTBALL_URL}/fixtures?date=${date}&team=${teamHome}`, {
                        headers: {
                            'x-rapidapi-key': API_FOOTBALL_KEY,
                            'x-rapidapi-host': 'v3.api-football.com'
                        }
                    });
                    
                    if (!response.ok) {
                        console.error("API Football error:", response.status);
                        return null;
                    }
                    
                    const data = await response.json();
                    apiCallsToday++;
                    
                    if (data.response && data.response.length > 0) {
                        // Cerca match che contiene entrambe le squadre
                        const match = data.response.find(m => {
                            const home = normalizeKey(m.teams.home.name);
                            const away = normalizeKey(m.teams.away.name);
                            const searchHome = normalizeKey(teamHome);
                            const searchAway = normalizeKey(teamAway);
                            
                            return (home.includes(searchHome) || searchHome.includes(home)) &&
                                   (away.includes(searchAway) || searchAway.includes(away));
                        });
                        
                        if (match && match.fixture && match.fixture.date) {
                            // Converti UTC a ora italiana (UTC+1 o UTC+2)
                            const utcDate = new Date(match.fixture.date);
                            const italianTime = new Date(utcDate.getTime() + (2 * 60 * 60 * 1000)); // UTC+2 per ora solare
                            
                            const hours = String(italianTime.getHours()).padStart(2, '0');
                            const minutes = String(italianTime.getMinutes()).padStart(2, '0');
                            
                            return `${hours}:${minutes}`;
                        }
                    }
                    
                    return null;
                } catch(e) {
                    console.error("API Football fetch error:", e);
                    return null;
                }
            }
            
            // Ottieni orario match (usa cache -> API)
            async function getMatchTime(date, match) {
                // 1. Prova cache Firebase
                const cached = getTimeFromCache(date, match);
                if (cached) return cached;
                
                // 2. Prova bulk cache (localStorage)
                const bulkTime = getTimeFromBulkCache(date, match);
                if (bulkTime) {
                    // Salva in cache Firebase per prossime volte
                    await saveTimeToCache(date, match, bulkTime);
                    return bulkTime;
                }
                
                // 3. Fallback: chiamata API singola (non dovrebbe servire)
                const teams = match.split(' - ');
                if (teams.length !== 2) return null;
                
                const teamHome = teams[0].trim();
                const teamAway = teams[1].trim();
                
                const time = await getTimeFromAPIFootball(date, teamHome, teamAway);
                
                if (time) {
                    await saveTimeToCache(date, match, time);
                }
                
                return time;
            }
            
            // ==================== POISSON ODDS CALCULATOR ====================
            
            // Calcola probabilit√† Poisson
            function poissonProbability(lambda, k) {
                let prob = Math.exp(-lambda);
                for (let i = 1; i <= k; i++) {
                    prob *= lambda / i;
                }
                return prob;
            }
            
            // Stima lambda da quota esistente
            function estimateLambda(tip, quota, prob) {
                // Usa probabilit√† reale per calcolo accurato
                const impliedProb = prob / 100;
                
                // Calcolo matematico basato su distribuzione Poisson
                if (tip === '+0.5') {
                    // P(X >= 1) = impliedProb
                    // Lambda = -ln(1 - impliedProb)
                    return -Math.log(1 - impliedProb);
                } else if (tip === '+1.5') {
                    // P(X >= 2) = impliedProb
                    // Approssimazione: lambda ‚âà 1.5 + (impliedProb - 0.5) * 3
                    const baseLambda = 2.0;
                    const adjustment = (impliedProb - 0.75) * 2;
                    return Math.max(1.5, Math.min(4.0, baseLambda + adjustment));
                } else if (tip === '+2.5') {
                    const baseLambda = 3.0;
                    const adjustment = (impliedProb - 0.60) * 2;
                    return Math.max(2.5, Math.min(5.0, baseLambda + adjustment));
                } else if (tip === '+3.5') {
                    const baseLambda = 4.0;
                    const adjustment = (impliedProb - 0.45) * 2;
                    return Math.max(3.5, Math.min(6.0, baseLambda + adjustment));
                }
                
                // Default fallback
                return 2.5;
            }
            
            // Calcola quota target con Poisson
            function calculatePoissonOdds(tipCurrent, quotaCurrent, probCurrent, tipTarget) {
                const lambda = estimateLambda(tipCurrent, quotaCurrent, probCurrent);
                
                let targetProb = 0;
                
                if (tipTarget === '+0.5') {
                    // P(X >= 1) = 1 - P(X = 0)
                    targetProb = 1 - poissonProbability(lambda, 0);
                } else if (tipTarget === '+1.5') {
                    // P(X >= 2) = 1 - P(X=0) - P(X=1)
                    targetProb = 1 - poissonProbability(lambda, 0) - poissonProbability(lambda, 1);
                } else if (tipTarget === '+2.5') {
                    // P(X >= 3)
                    targetProb = 1 - poissonProbability(lambda, 0) - poissonProbability(lambda, 1) - poissonProbability(lambda, 2);
                } else if (tipTarget === '+3.5') {
                    // P(X >= 4)
                    let sum = 0;
                    for (let k = 0; k <= 3; k++) {
                        sum += poissonProbability(lambda, k);
                    }
                    targetProb = 1 - sum;
                } else if (tipTarget === '-2.5') {
                    // P(X < 3) = P(X=0) + P(X=1) + P(X=2)
                    targetProb = poissonProbability(lambda, 0) + poissonProbability(lambda, 1) + poissonProbability(lambda, 2);
                }
                
                if (targetProb <= 0 || targetProb >= 1) return null;
                
                const targetOdds = 1 / targetProb;
                
                return {
                    odds: targetOdds,
                    prob: Math.round(targetProb * 100),
                    source: 'poisson'
                };
            }
            
            // ==================== AI TRADING ADVISOR ====================
            
            function generateTradingAdvice(match, tipTarget = null) {
                const score = match.score || 0;
                const tip = (match.tip || '').trim().toUpperCase();
                const prob = match.probabilita || 0;
                const quota = match.quota || 0;
                
                // Normalizza tipTarget
                const tipTargetNorm = tipTarget ? tipTarget.trim().toUpperCase() : null;
                
                // Estrai HT prob se disponibile
                let htProb = 0;
                if (match.info_ht && match.info_ht.trim() !== '') {
                    const htMatch = match.info_ht.match(/(\d+)%/);
                    if (htMatch) htProb = parseInt(htMatch[1]);
                }
                
                // Ottieni odds target
                const targetOdds = getTargetOdds(match, tipTarget);
                if (!targetOdds) {
                    tipTarget = null;
                }
                
                // Usa tip target per i calcoli se specificato E diverso da vuoto
                const hasValidTarget = tipTargetNorm && tipTargetNorm !== '' && tipTargetNorm !== tip;
                const effectiveTip = hasValidTarget ? tipTargetNorm : tip;
                const effectiveQuota = targetOdds ? targetOdds.odds : quota;
                const effectiveProb = targetOdds && targetOdds.prob ? targetOdds.prob : prob;
                
                // Bonus confidence se odds reale
                const confidenceBonus = (targetOdds && !targetOdds.isEstimate) ? 5 : 0;
                const adjustedScore = score + confidenceBonus;
                
                let advice = {
                    confidence: '',
                    confidenceIcon: '',
                    confidenceColor: '',
                    entry: '',
                    timing: '',
                    plan: '',
                    stopLoss: '',
                    reason: '',
                    riskLevel: '',
                    targetTip: effectiveTip,
                    targetOdds: targetOdds,
                    greenInfo: ''
                };
                
                // Logica rivista: HT √® bonus, non requisito
                // Se HT disponibile e alto ‚Üí boost confidence
                // Se HT non disponibile ‚Üí basa su score
                
                const hasHtData = htProb > 0;
                const htBoost = hasHtData && htProb >= 70;
                const htGood = hasHtData && htProb >= 55;
                
                if (adjustedScore >= 60 || (adjustedScore >= 50 && htBoost)) {
                    advice.confidence = 'MOLTO ALTA';
                    advice.confidenceIcon = 'üî•';
                    advice.confidenceColor = 'text-green-700 bg-green-50';
                    advice.riskLevel = 'BASSO';
                    
                    if (tipTargetNorm === '0.5HT' && hasHtData) {
                        advice.entry = `Back ${tip} @${quota.toFixed(2)} pre-match`;
                        advice.timing = `Primo tempo KEY (HT ${htProb}%)`;
                        advice.plan = `Lay 0.5 HT ${targetOdds.display} se gol primi 20' ${targetOdds.isEstimate ? '(stima)' : '‚úÖ'}`;
                        advice.stopLoss = `Se 0-0 a 30' ‚Üí Lay comunque (HT alto!)`;
                        advice.reason = `HT ${htProb}% = Gol HT quasi certo. Green ${targetOdds.isEstimate ? 'stimato' : 'garantito'}!`;
                        
                        const green = calculateGreen(100, quota, targetOdds.odds);
                        advice.greenInfo = `‚Ç¨${green.toFixed(2)} su stake ‚Ç¨100`;
                    } else {
                        // Entry SEMPRE sul tip target
                        advice.entry = `Back ${effectiveTip} ${targetOdds ? targetOdds.display : '@' + quota.toFixed(2)} pre-match`;
                        advice.timing = hasHtData ? `Gol probabile primi 15' (HT ${htProb}%)` : `Score alto, buone probabilit√†`;
                        
                        advice.plan = `Se gol ‚Üí Lay ${effectiveTip} a quote inferiori per green`;
                        advice.reason = hasHtData ? 
                            `Score ${adjustedScore} + HT ${htProb}%. Target ${effectiveTip}` :
                            `Score ${adjustedScore} alto. Target ${effectiveTip}`;
                        
                        advice.stopLoss = `Se 0-0 a 70' ‚Üí Cash out con -5%`;
                        
                        if (targetOdds && targetOdds.isEstimate) {
                            const greenRange = calculateGreenRange(100, quota, targetOdds.min, targetOdds.max);
                            advice.greenInfo = `‚Ç¨${greenRange.min.toFixed(2)}-‚Ç¨${greenRange.max.toFixed(2)} su stake ‚Ç¨100`;
                        } else if (targetOdds) {
                            const green = calculateGreen(100, quota, targetOdds.odds);
                            advice.greenInfo = `‚Ç¨${green.toFixed(2)} su stake ‚Ç¨100`;
                        }
                    }
                    
                } else if (adjustedScore >= 45 || (adjustedScore >= 35 && htGood)) {
                    advice.confidence = 'ALTA';
                    advice.confidenceIcon = '‚ö°';
                    advice.confidenceColor = 'text-green-600 bg-green-50';
                    advice.riskLevel = 'MEDIO-BASSO';
                    
                    advice.entry = `Back ${effectiveTip} ${targetOdds ? targetOdds.display : '@' + quota.toFixed(2)} pre-match`;
                    advice.timing = hasHtData ? `Gol atteso primi 20' (HT ${htProb}%)` : `Score buono`;
                    
                    advice.plan = `Monitor primi 20', se gol ‚Üí Lay ${effectiveTip} a quote inferiori`;
                    advice.reason = hasHtData ?
                        `Score ${adjustedScore} + HT ${htProb}%. Target ${effectiveTip}` :
                        `Score ${adjustedScore}. Target ${effectiveTip}`;
                    
                    advice.stopLoss = `Se 0-0 a 65' ‚Üí Cash out con -8%`;
                    
                    if (targetOdds && targetOdds.isEstimate) {
                        const greenRange = calculateGreenRange(100, quota, targetOdds.min, targetOdds.max);
                        advice.greenInfo = `‚Ç¨${greenRange.min.toFixed(2)}-‚Ç¨${greenRange.max.toFixed(2)} su stake ‚Ç¨100`;
                    } else if (targetOdds) {
                        const green = calculateGreen(100, quota, targetOdds.odds);
                        advice.greenInfo = `‚Ç¨${green.toFixed(2)} su stake ‚Ç¨100`;
                    }
                    
                } else if (adjustedScore >= 30) {
                    advice.confidence = 'MEDIA';
                    advice.confidenceIcon = 'üí°';
                    advice.confidenceColor = 'text-yellow-600 bg-yellow-50';
                    advice.riskLevel = 'MEDIO';
                    
                    advice.entry = `Back ${effectiveTip} ${targetOdds ? targetOdds.display : '@' + quota.toFixed(2)} pre-match con cautela`;
                    advice.timing = hasHtData ? `Gol possibile HT (${htProb}%), monitor` : `Score medio`;
                    
                    advice.plan = `Entry cauta, se gol valuta Lay ${effectiveTip}`;
                    advice.reason = hasHtData ?
                        `Score ${adjustedScore} medio, HT ${htProb}%. Target ${effectiveTip}` :
                        `Score ${adjustedScore} medio. Target ${effectiveTip}`;
                    
                    advice.stopLoss = `Se 0-0 a 60' ‚Üí Exit con -10%`;
                    
                    if (targetOdds && targetOdds.isEstimate) {
                        const greenRange = calculateGreenRange(100, quota, targetOdds.min, targetOdds.max);
                        advice.greenInfo = `‚Ç¨${greenRange.min.toFixed(2)}-‚Ç¨${greenRange.max.toFixed(2)} possibili`;
                    } else if (targetOdds) {
                        const green = calculateGreen(100, quota, targetOdds.odds);
                        advice.greenInfo = `‚Ç¨${green.toFixed(2)} possibili`;
                    }
                    
                } else if (adjustedScore >= 30 && adjustedScore < 40) {
                    advice.confidence = 'BASSA';
                    advice.confidenceIcon = '‚ö†Ô∏è';
                    advice.confidenceColor = 'text-orange-600 bg-orange-50';
                    advice.riskLevel = 'ALTO';
                    
                    advice.entry = `Skip o stake minimo (0.5% bankroll)`;
                    advice.timing = `Confidence insufficiente per entry sicura`;
                    advice.plan = `Solo per esperti: entry live dopo 30' se 0-0`;
                    advice.stopLoss = `Exit immediato se andamento negativo`;
                    advice.reason = `Score ${adjustedScore} limite, rischio elevato`;
                    advice.greenInfo = `N/A`;
                    
                } else {
                    advice.confidence = 'MOLTO BASSA';
                    advice.confidenceIcon = '‚ùå';
                    advice.confidenceColor = 'text-red-600 bg-red-50';
                    advice.riskLevel = 'MOLTO ALTO';
                    
                    advice.entry = `SKIP - Non consigliato`;
                    advice.timing = `Score troppo basso per betting sicuro`;
                    advice.plan = `Evita questa partita`;
                    advice.stopLoss = `N/A`;
                    advice.reason = `Score ${adjustedScore} insufficiente, rischio eccessivo`;
                    advice.greenInfo = `N/A`;
                }
                
                return advice;
            }
            
            // ==================== TOOLTIP SYSTEM ====================
            
            function generateScoreTooltip(match, scoreDetails) {
                return `
                    <div class="text-left">
                        <div class="font-bold mb-2 text-center">SCORE BREAKDOWN</div>
                        <div class="text-sm space-y-1">
                            <div>Lega: <span class="font-semibold">+${scoreDetails.legaScore || 0}</span></div>
                            <div>Tip: <span class="font-semibold">+${scoreDetails.tipScore || 0}</span></div>
                            <div>Prob: <span class="font-semibold">+${scoreDetails.probScore || 0}</span> (${match.probabilita}%)</div>
                            ${scoreDetails.htBonus ? `<div>HT Boost: <span class="font-semibold text-green-600">+${scoreDetails.htBonus}</span></div>` : ''}
                            <div class="border-t pt-1 mt-1">Totale: <span class="font-bold text-lg">${scoreDetails.totalScore || 0}</span></div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t text-gray-600">
                            <div>80+ = ECCELLENTE üî•</div>
                            <div>60-79 = BUONO ‚ö°</div>
                            <div>40-59 = MEDIO üí°</div>
                            <div>&lt;40 = BASSO ‚ö†Ô∏è</div>
                        </div>
                    </div>
                `;
            }
            
            function generateStatsTooltip(homeWins, awayWins) {
                const homeColor = homeWins >= 7 ? 'üü¢' : homeWins >= 4 ? 'üü°' : 'üî¥';
                const awayColor = awayWins >= 7 ? 'üü¢' : awayWins >= 4 ? 'üü°' : 'üî¥';
                
                return `
                    <div class="text-left">
                        <div class="font-bold mb-2 text-center">FORM SQUADRE</div>
                        <div class="text-sm space-y-1">
                            <div>${homeColor} Casa: <span class="font-semibold">${homeWins} W</span> ultimi 10</div>
                            <div>${awayColor} Trasferta: <span class="font-semibold">${awayWins} W</span> ultimi 10</div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t text-gray-600">
                            <div>üü¢ 7+ = OTTIMA</div>
                            <div>üü° 4-6 = MEDIA</div>
                            <div>üî¥ 0-3 = SCARSA</div>
                        </div>
                    </div>
                `;
            }
            
            // ==================== HT MERGE FUNCTIONS ====================
            function normalizeKey(str) {
                // Normalizza stringa per matching squadre (rimuove accenti, lowercase, solo alfanumerici)
                return str.normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "")
                    .toLowerCase()
                    .replace(/[^a-z0-9]/g, "");
            }
            
            function mergeMainWithHT() {
                // Se non ho dati main, non posso fare merge
                if (rawMainData.length === 0) return rawMainData;
                
                // Se non ho dati HT, ritorno main senza modifiche
                if (rawHtData.length === 0) return rawMainData;
                
                // Creo mappa HT: chiave = squadre normalizzate
                const htMap = {};
                rawHtData.forEach(htRow => {
                    const partita = String(htRow.Partita || '').trim();
                    if (!partita) return;
                    
                    // Normalizzo nome partita (Home + Away senza spazi/accenti)
                    const normalized = normalizeKey(partita);
                    
                    // Salvo prob e quota HT
                    const probHT = parseInt(String(htRow['Probabilit√†'] || htRow.Probabilit√† || '0').replace('%', '').trim()) || 0;
                    const quotaHT = parseFloat(String(htRow.Quota || '0').replace(',', '.').trim()) || 0;
                    
                    if (probHT > 0 && quotaHT > 0) {
                        htMap[normalized] = { prob: probHT, quota: quotaHT.toFixed(2) };
                    }
                });
                
                // Arricchisco Main con info HT
                return rawMainData.map(mainRow => {
                    const partita = String(mainRow.Partita || '').trim();
                    const normalized = normalizeKey(partita);
                    
                    // Cerco match in HT map
                    if (htMap[normalized]) {
                        const htInfo = htMap[normalized];
                        mainRow.info_ht = `${htInfo.prob}% (@${htInfo.quota})`;
                    } else {
                        mainRow.info_ht = '';
                    }
                    
                    return mainRow;
                });
            }
            
            // ==================== UPLOAD TIPS ====================
            document.getElementById('tips-csv-file').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // Mostra feedback visivo
                const statusEl = document.getElementById('tips-file-status');
                const nameEl = document.getElementById('tips-file-name');
                statusEl.classList.remove('hidden');
                nameEl.textContent = file.name;
                
                const reader = new FileReader();
                reader.onload = async function(event) {
                    const parsed = parseCSV(event.target.result);
                    const matchDate = document.getElementById('tips-date').value;
                    if (!matchDate) {
                        alert('Seleziona data!');
                        return;
                    }
                    
                    // Salvo in rawMainData
                    rawMainData = parsed;
                    
                    // Faccio merge con HT se disponibile
                    const mergedData = mergeMainWithHT();
                    
                    // Conta quante partite hanno HT dopo merge
                    const htCount = mergedData.filter(m => m.info_ht && m.info_ht.trim() !== '').length;
                    if (htCount > 0) {
                        const htStatusEl = document.getElementById('ht-file-status');
                        const htCountEl = document.getElementById('ht-match-count');
                        htStatusEl.classList.remove('hidden');
                        htCountEl.textContent = htCount;
                    }
                    
                    // Processo i dati merged
                    await processAndPreviewCSV(mergedData, matchDate, 'tips');
                };
                reader.readAsText(file);
            });
            
            // ==================== UPLOAD HT ====================
            document.getElementById('tips-ht-file').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) {
                    // Se rimuovo file HT, resetto
                    rawHtData = [];
                    document.getElementById('ht-file-status').classList.add('hidden');
                    return;
                }
                
                // Mostra feedback visivo
                const statusEl = document.getElementById('ht-file-status');
                const nameEl = document.getElementById('ht-file-name');
                const countEl = document.getElementById('ht-match-count');
                statusEl.classList.remove('hidden');
                nameEl.textContent = file.name;
                
                const reader = new FileReader();
                reader.onload = async function(event) {
                    const parsed = parseCSV(event.target.result);
                    
                    // Salvo in rawHtData
                    rawHtData = parsed;
                    countEl.textContent = parsed.length;
                    
                    // Se ho gi√† caricato Main, rifaccio merge
                    if (rawMainData.length > 0) {
                        const matchDate = document.getElementById('tips-date').value;
                        if (matchDate) {
                            const mergedData = mergeMainWithHT();
                            
                            // Conta quante partite hanno HT dopo merge
                            const htCount = mergedData.filter(m => m.info_ht && m.info_ht.trim() !== '').length;
                            countEl.textContent = htCount;
                            
                            await processAndPreviewCSV(mergedData, matchDate, 'tips');
                        }
                    }
                };
                reader.readAsText(file);
            });
            
            // ==================== UPLOAD RISULTATI ====================
            document.getElementById('results-csv-file').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async function(event) {
                    const parsed = parseCSV(event.target.result);
                    const matchDate = document.getElementById('results-date').value;
                    if (!matchDate) {
                        alert('Seleziona data!');
                        return;
                    }
                    await processAndPreviewCSV(parsed, matchDate, 'results');
                };
                reader.readAsText(file);
            });
            
            function parseCSV(text) {
                const lines = text.split('\n');
                const headers = lines[0].split(',').map(h => h.trim().replace(/['"]/g, ''));
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    const values = lines[i].split(',').map(v => v.trim().replace(/['"]/g, ''));
                    const row = {};
                    headers.forEach((h, idx) => row[h] = values[idx]);
                    data.push(row);
                }
                return data;
            }
            
            async function processAndPreviewCSV(parsedData, matchDate, type) {
                const requiredFields = ['Lega', 'Partita', 'Probabilit√†', 'Mercato', 'Tip', 'Quota'];
                let potentialMatches = [];
                let incomplete = 0;
                let duplicates = 0;
                let updates = 0;
                
                for (const row of parsedData) {
                    // VALIDAZIONE MIGLIORATA: scarta se campo mancante o "-"
                    if (!requiredFields.every(f => {
                        const value = String(row[f] || '').trim();
                        return value !== '' && value !== '-';
                    })) {
                        incomplete++;
                        continue;
                    }
                    
                    // Parse dati
                    const probabilita = parseInt(String(row['Probabilit√†']).replace('%', '').trim()) || 0;
                    const quota = parseFloat(String(row.Quota).replace(',', '.').trim()) || 0;
                    
                    // VALIDAZIONE NUMERICA: scarta se prob o quota = 0
                    if (probabilita === 0 || quota === 0) {
                        incomplete++;
                        continue;
                    }
                    
                    // Parse ora dal CSV
                    const ora = String(row.Ora || row.Time || '').trim();
                    
                    const matchData = {
                        data: matchDate,
                        lega: normalizeLega(String(row.Lega).trim()),
                        partita: String(row.Partita).trim(),
                        risultato: type === 'results' ? (String(row.Risultato || '').trim()) : '',
                        probabilita: probabilita,
                        mercato: String(row.Mercato).trim(),
                        tip: String(row.Tip).trim(),
                        quota: quota,
                        info_ht: String(row.info_ht || '').trim()
                    };
                    
                    // Se c'√® ora nel CSV ‚Üí salva in cache Firebase temporanea
                    if (ora && ora !== '' && type === 'tips') {
                        // Salva in cache (non nel DB principale!)
                        await saveTimeToCache(matchData.data, matchData.partita, ora);
                    }
                    
                    // Calcola esito se risultati
                    if (type === 'results' && matchData.risultato) {
                        matchData.esito = calculateOutcome(matchData);
                    }
                    
                    // CONTROLLO DUPLICATI
                    const exists = allMatches.find(m => 
                        m.data === matchData.data &&
                        m.partita === matchData.partita &&
                        m.tip === matchData.tip
                    );
                    
                    if (exists) {
                        if (type === 'results' && matchData.risultato) {
                            // Se partita esiste GI√Ä CON risultato ‚Üí duplicato vero
                            if (exists.risultato && exists.risultato.trim() !== '') {
                                duplicates++;
                            } else {
                                // Partita esiste senza risultato ‚Üí UPDATE
                                matchData.id = exists.id;
                                updates++;
                                potentialMatches.push(matchData);
                            }
                        } else {
                            // Duplicato vero (tips duplicati o altro)
                            duplicates++;
                        }
                    } else {
                        // Nuova partita
                        potentialMatches.push(matchData);
                    }
                }
                
                dataToUpload = potentialMatches;
                const previewId = type === 'tips' ? 'tips-upload-preview' : 'results-upload-preview';
                const uploadPreview = document.getElementById(previewId);
                
                uploadPreview.classList.remove('hidden');
                uploadPreview.innerHTML = `
                    <p><strong>Riepilogo:</strong></p>
                    <ul class="list-disc list-inside text-sm mt-2">
                        <li>Partite totali file: ${parsedData.length}</li>
                        <li>Scartate (incomplete): ${incomplete}</li>
                        ${type === 'results' ? `<li class="text-green-600">Da aggiornare (esistenti): ${updates}</li>` : ''}
                        ${duplicates > 0 ? `<li class="text-orange-600">Duplicate (ignorate): ${duplicates}</li>` : ''}
                        <li class="font-bold text-blue-600">Da caricare (nuove): ${dataToUpload.length - updates}</li>
                        <li class="font-bold text-purple-600">Totale operazioni: ${dataToUpload.length}</li>
                    </ul>
                    <button id="confirm-${type}-upload-btn" class="mt-4 w-full bg-green-600 text-white font-semibold py-2 rounded-lg hover:bg-green-700">
                        Conferma e Carica
                    </button>
                `;
                
                document.getElementById(`confirm-${type}-upload-btn`).addEventListener('click', () => handleUploadConfirmed(type));
            }
            
            async function handleUploadConfirmed(type) {
                if (dataToUpload.length === 0) return;
                
                const matchesCollection = collection(db, "matches");
                let deletedCount = 0;
                
                try {
                    // CARICA ORARI AUTOMATICAMENTE per tips (non per results)
                    if (type === 'tips') {
                        console.log('[INFO] Caricamento orari disabilitato. Aggiungi colonna "Ora" al CSV per includerli.');
                        // API Football disabilitata - non raggiungibile
                        // Usa CSV con colonna "Ora" oppure lascia vuoto
                    }
                    
                    // Carica/aggiorna partite
                    const batch = writeBatch(db);
                    dataToUpload.forEach(match => {
                        if (match.id) {
                            // Update esistente - usa set con merge per evitare errori
                            batch.set(doc(matchesCollection, match.id), match, { merge: true });
                        } else {
                            // Nuovo
                            const docRef = doc(matchesCollection);
                            batch.set(docRef, match);
                        }
                    });
                    
                    await batch.commit();
                    
                    // SE RISULTATI: aggiorna ranking salvati con esiti
                    let performanceReport = null;
                    if (type === 'results' && dataToUpload.length > 0) {
                        const uploadDate = dataToUpload[0].data;
                        performanceReport = await updateRankingResults(uploadDate, dataToUpload);
                    }
                    
                    let successMsg = type === 'results' && deletedCount > 0
                        ? `${dataToUpload.length} partite caricate! (${deletedCount} vecchie senza risultato eliminate)`
                        : `${dataToUpload.length} partite caricate/aggiornate!`;
                    
                    // Aggiungi report performance se disponibile
                    if (performanceReport && performanceReport.updated > 0) {
                        successMsg += `\n\nüìä TRACKING ML AGGIORNATO:\n`;
                        successMsg += `‚úÖ ${performanceReport.updated} partite aggiornate nei ranking salvati\n\n`;
                        
                        Object.keys(performanceReport.performance).forEach(filterName => {
                            const perf = performanceReport.performance[filterName];
                            const emoji = perf.winrate >= 70 ? 'üî•' : perf.winrate >= 60 ? '‚úÖ' : '‚ö†Ô∏è';
                            successMsg += `${emoji} ${filterName}:\n`;
                            successMsg += `   ${perf.vinte}/${perf.totale} vinte (${perf.winrate}%)\n`;
                        });
                    }
                    
                    showModal("Successo", successMsg, () => {});
                    
                    const previewId = type === 'tips' ? 'tips-upload-preview' : 'results-upload-preview';
                    document.getElementById(previewId).classList.add('hidden');
                    
                    if (type === 'tips') document.getElementById('tips-csv-file').value = '';
                    else document.getElementById('results-csv-file').value = '';
                    
                    await loadAllMatches();
                    populateFilters();
                    applyFiltersAndRender();
                    
                    if (type === 'tips') updateTipsDaysList();
                    else updateResultsDaysList();
                } catch(e) {
                    showModal("Errore", `Errore: ${e.message}`, () => {});
                }
            }
            
            function calculateOutcome(match) {
                const { mercato, tip, risultato } = match;
                if (!risultato || !mercato || !tip) return '';
                const scores = risultato.split('-').map(s => parseInt(s.trim()));
                if (scores.length !== 2 || isNaN(scores[0]) || isNaN(scores[1])) return '';
                
                const [homeScore, awayScore] = scores;
                const totalGoals = homeScore + awayScore;
                const normalizedTip = tip.toUpperCase().replace(/\s/g, '');
                
                try {
                    switch (mercato.toLowerCase().trim()) {
                        case '1x2':
                            if (normalizedTip === '1' && homeScore > awayScore) return 'Vinto';
                            if (normalizedTip === 'X' && homeScore === awayScore) return 'Vinto';
                            if (normalizedTip === '2' && homeScore < awayScore) return 'Vinto';
                            return 'Perso';
                        case 'doppia chance':
                            if (normalizedTip === '1X' && homeScore >= awayScore) return 'Vinto';
                            if (normalizedTip === 'X2' && homeScore <= awayScore) return 'Vinto';
                            if (normalizedTip === '12' && homeScore !== awayScore) return 'Vinto';
                            return 'Perso';
                        case 'numero di gol':
                            const goalValue = parseFloat(normalizedTip.replace(/[+-]/, '').trim());
                            if (normalizedTip.startsWith('+') && totalGoals > goalValue) return 'Vinto';
                            if (normalizedTip.startsWith('-') && totalGoals < goalValue) return 'Vinto';
                            return 'Perso';
                        case 'gol/no gol':
                            if ((normalizedTip === 'GOL' || normalizedTip === 'SI' || normalizedTip === 'S√å') && (homeScore > 0 && awayScore > 0)) return 'Vinto';
                            if ((normalizedTip === 'NOGOL' || normalizedTip === 'NO') && (homeScore === 0 || awayScore === 0)) return 'Vinto';
                            return 'Perso';
                        default: return '';
                    }
                } catch (e) {
                    console.error('Error:', e);
                    return '';
                }
            }
            
            // ==================== CANCELLAZIONE GIORNATE ====================
            function updateTipsDaysList() {
                const tipsDates = [...new Set(allMatches.filter(m => !m.risultato).map(m => m.data))].sort().reverse();
                const select = document.getElementById('delete-tips-date');
                select.innerHTML = '<option value="">Seleziona una data...</option>' + 
                    tipsDates.map(d => {
                        const count = allMatches.filter(m => m.data === d && !m.risultato).length;
                        return `<option value="${d}">${d} (${count} partite)</option>`;
                    }).join('');
                
                document.getElementById('tips-days-info').textContent = `Giornate disponibili: ${tipsDates.length}`;
            }
            
            function updateResultsDaysList() {
                const resultsDates = [...new Set(allMatches.filter(m => m.risultato).map(m => m.data))].sort().reverse();
                const select = document.getElementById('delete-results-date');
                select.innerHTML = '<option value="">Seleziona una data...</option>' + 
                    resultsDates.map(d => {
                        const count = allMatches.filter(m => m.data === d && m.risultato).length;
                        return `<option value="${d}">${d} (${count} risultati)</option>`;
                    }).join('');
                
                document.getElementById('results-days-info').textContent = `Giornate con risultati: ${resultsDates.length}`;
            }
            
            document.getElementById('delete-tips-day-btn').addEventListener('click', async () => {
                const selectedDate = document.getElementById('delete-tips-date').value;
                if (!selectedDate) {
                    showModal("Errore", "Seleziona una data!", () => {});
                    return;
                }
                
                const toDelete = allMatches.filter(m => m.data === selectedDate && !m.risultato);
                
                showModal(
                    "Conferma Cancellazione",
                    `Eliminare ${toDelete.length} partite del ${selectedDate} senza risultati?`,
                    async () => {
                        const batch = writeBatch(db);
                        toDelete.forEach(m => {
                            batch.delete(doc(db, "matches", m.id));
                        });
                        
                        try {
                            await batch.commit();
                            showModal("Successo", `${toDelete.length} partite eliminate!`, () => {});
                            await loadAllMatches();
                            populateFilters();
                            applyFiltersAndRender();
                            updateTipsDaysList();
                        } catch(e) {
                            showModal("Errore", `Errore: ${e.message}`, () => {});
                        }
                    }
                );
            });
            
            document.getElementById('delete-results-day-btn').addEventListener('click', async () => {
                const selectedDate = document.getElementById('delete-results-date').value;
                if (!selectedDate) {
                    showModal("Errore", "Seleziona una data!", () => {});
                    return;
                }
                
                const toDelete = allMatches.filter(m => m.data === selectedDate && m.risultato);
                
                showModal(
                    "Conferma Cancellazione",
                    `Eliminare ${toDelete.length} risultati del ${selectedDate}? Le partite torneranno senza risultato.`,
                    async () => {
                        const batch = writeBatch(db);
                        toDelete.forEach(m => {
                            batch.update(doc(db, "matches", m.id), { risultato: '', esito: '' });
                        });
                        
                        try {
                            await batch.commit();
                            showModal("Successo", `${toDelete.length} risultati eliminati!`, () => {});
                            await loadAllMatches();
                            populateFilters();
                            applyFiltersAndRender();
                            updateResultsDaysList();
                        } catch(e) {
                            showModal("Errore", `Errore: ${e.message}`, () => {});
                        }
                    }
                );
            });
            
            // ==================== RANKING ====================
            document.getElementById('generate-ranking-btn').addEventListener('click', async () => {
                const rankingDate = document.getElementById('ranking-date').value;
                const scoreMin = parseInt(document.getElementById('ranking-score-min').value);
                const maxMatches = parseInt(document.getElementById('ranking-max-matches').value);
                const selectedFilterId = document.getElementById('ranking-filter-select').value;
                const tipTarget = document.getElementById('ranking-target-tip').value || null;
                
                if (!rankingDate) {
                    alert('Seleziona data!');
                    return;
                }
                
                const resultsContainer = document.getElementById('ranking-results');
                resultsContainer.innerHTML = '<div class="bg-white p-6 rounded-xl shadow text-center"><div class="animate-pulse text-lg">üîÑ Generazione ranking... <br><span class="text-sm text-gray-500">(Recupero orari in corso...)</span></div></div>';
                
                try {
                    // Partite del giorno senza risultato
                    let todayMatches = allMatches.filter(m => m.data === rankingDate && !m.risultato);
                    
                    // APPLICA FILTRO SE SELEZIONATO
                    let filterName = "Tutte le partite";
                    if (selectedFilterId) {
                        const selectedFilter = savedFilters.find(f => f.id === selectedFilterId);
                        if (selectedFilter) {
                            filterName = selectedFilter.name;
                            const filterState = selectedFilter.state;
                            
                            // Applica filtri
                            todayMatches = todayMatches.filter(m => {
                                // Filtro leghe
                                if (filterState.leagues && filterState.leagues.length > 0) {
                                    if (!filterState.leagues.includes(m.lega)) return false;
                                }
                                
                                // Filtro tips
                                if (filterState.tips && filterState.tips.length > 0) {
                                    if (!filterState.tips.includes(m.tip)) return false;
                                }
                                
                                // Filtro probabilit√†
                                if (filterState.prob) {
                                    const [minProb, maxProb] = filterState.prob.map(v => parseInt(v));
                                    if (m.probabilita < minProb || m.probabilita > maxProb) return false;
                                }
                                
                                // Filtro odds
                                if (filterState.odds) {
                                    const [minOdds, maxOdds] = filterState.odds.map(v => parseFloat(v));
                                    if (m.quota < minOdds || m.quota > maxOdds) return false;
                                }
                                
                                return true;
                            });
                        }
                    }
                    
                    if (todayMatches.length === 0) {
                        resultsContainer.innerHTML = '<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita per quella data con i filtri selezionati!</div>';
                        return;
                    }
                    
                    const leaguePerformance = analyzeLeaguePerformance(allMatches);
                    
                    // Calcola score per tutte le partite
                    const rankedMatches = todayMatches.map(m => {
                        const score = calculateScore(m, new Set([m.lega.toLowerCase()]), new Set([m.tip]), leaguePerformance, allMatches);
                        return {
                            ...m,
                            score: score.totalScore,
                            scoreDetails: score // Salva dettagli per tooltip
                        };
                    }).filter(m => m.score >= scoreMin);
                    
                    if (rankedMatches.length === 0) {
                        resultsContainer.innerHTML = `<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessun match supera score ${scoreMin} con filtri selezionati</div>`;
                        return;
                    }
                    
                    // Raggruppa per tip
                    const byTip = {};
                    rankedMatches.forEach(m => {
                        if (!byTip[m.tip]) byTip[m.tip] = [];
                        byTip[m.tip].push(m);
                    });
                    
                    // Ordina ogni gruppo per score
                    Object.keys(byTip).forEach(tip => {
                        byTip[tip].sort((a, b) => b.score - a.score);
                        byTip[tip] = byTip[tip].slice(0, maxMatches);
                    });
                    
                    // CARICA ORARI da Firebase cache temporanea
                    const allRankedMatches = Object.values(byTip).flat();
                    let loadedTimes = 0;
                    
                    for (let match of allRankedMatches) {
                        const ora = await getTimeFromCache(match.data, match.partita);
                        if (ora) {
                            match.time = ora;
                            loadedTimes++;
                        }
                    }
                    
                    console.log(`[CACHE] Orari recuperati: ${loadedTimes}/${allRankedMatches.length}`);
                    
                    if (loadedTimes === 0) {
                        console.log('[INFO] Nessun orario in cache. Carica CSV con colonna "Ora".');
                    }
                    if (loadedTimes > 0) {
                        console.log(`Loaded ${loadedTimes} match times for ranking`);
                    }
                    
                    // Render ranking per tip
                    const tipBlocks = Object.keys(byTip).sort().map(tip => {
                        const matches = byTip[tip];
                        
                        return `
                            <div class="bg-white p-6 rounded-xl shadow mb-6">
                                <h3 class="text-2xl font-bold mb-3">üìä ${tip}</h3>
                                <div class="text-sm text-gray-600 mb-4">
                                    ${matches.length} partite (max ${maxMatches} per tip)
                                </div>
                                <div class="space-y-3">
                                    ${matches.map((m, idx) => {
                                        const [team1, team2] = m.partita.split(' - ');
                                        const team1Stats = analyzeTeamStats(team1, true, m.tip, allMatches);
                                        const team2Stats = analyzeTeamStats(team2, false, m.tip, allMatches);
                                        
                                        // HT indicator
                                        let htIndicator = '';
                                        if (m.info_ht && m.info_ht.trim() !== '') {
                                            const probMatch = m.info_ht.match(/(\d+)%/);
                                            if (probMatch) {
                                                const htProb = parseInt(probMatch[1]);
                                                if (htProb >= 70) {
                                                    htIndicator = `<div class="text-xs mt-1"><span class="bg-green-100 text-green-700 px-2 py-1 rounded font-bold">‚ö° HT: ${m.info_ht}</span></div>`;
                                                } else if (htProb >= 55) {
                                                    htIndicator = `<div class="text-xs mt-1"><span class="bg-yellow-100 text-yellow-700 px-2 py-1 rounded">üí° HT: ${m.info_ht}</span></div>`;
                                                } else {
                                                    htIndicator = `<div class="text-xs mt-1"><span class="bg-gray-100 text-gray-600 px-2 py-1 rounded">üìä HT: ${m.info_ht}</span></div>`;
                                                }
                                            } else {
                                                // Se info_ht presente ma formato diverso
                                                htIndicator = `<div class="text-xs mt-1"><span class="bg-gray-100 text-gray-600 px-2 py-1 rounded">üìä HT: ${m.info_ht}</span></div>`;
                                            }
                                        }
                                        
                                        // Orario display
                                        let timeDisplay = '';
                                        if (m.time && m.time.trim() !== '') {
                                            timeDisplay = `<div class="text-xs mt-1"><span class="text-gray-600 font-bold">‚è∞ ${m.time}</span></div>`;
                                        }
                                        
                                        // AI Trading Advice
                                        const advice = generateTradingAdvice(m, tipTarget);
                                        
                                        // Target display
                                        let targetDisplay = '';
                                        if (tipTarget && advice.targetOdds) {
                                            const targetLabel = tipTarget === '0.5HT' ? 'Over 0.5 HT' : tipTarget;
                                            const sourceIcon = advice.targetOdds.isEstimate ? 'üîÆ' : '‚úÖ';
                                            targetDisplay = `<div class="text-xs mt-1 font-semibold text-blue-600">üéØ Target: ${targetLabel} ${advice.targetOdds.display} ${sourceIcon}</div>`;
                                        }
                                        
                                        return `
                                            <div class="border rounded-lg p-4 hover:bg-gray-50">
                                                <div class="flex justify-between items-start mb-3">
                                                    <div class="flex-1">
                                                        <div class="flex justify-between items-start">
                                                            <div class="font-bold text-lg">
                                                                ${idx + 1}. 
                                                                <span class="team-${team1Stats.color}">${team1}</span>
                                                                - 
                                                                <span class="team-${team2Stats.color}">${team2}</span>
                                                            </div>
                                                        </div>
                                                        <div class="text-sm text-gray-600 flex items-center gap-2">
                                                            ${m.time && m.time.trim() !== '' ? `<span class="text-gray-900 font-bold">‚è∞ ${m.time}</span> | ` : ''}
                                                            ${m.lega}
                                                        </div>
                                                        <div class="text-sm mt-1">
                                                            <span class="bg-blue-100 px-2 py-1 rounded text-xs">${m.mercato}</span>
                                                            <span class="ml-2">@${m.quota.toFixed(2)}</span>
                                                            <span class="ml-2 text-gray-500">${m.probabilita}%</span>
                                                        </div>
                                                        ${htIndicator}
                                                        ${targetDisplay}
                                                    </div>
                                                    <div class="text-right">
                                                        <div class="relative inline-block">
                                                            <span class="score-badge cursor-help tooltip-trigger" 
                                                                  data-tooltip-type="score"
                                                                  data-score="${m.score || 0}"
                                                                  data-lega-score="${m.scoreDetails?.legaScore || 0}"
                                                                  data-tip-score="${m.scoreDetails?.tipScore || 0}"
                                                                  data-prob-score="${m.scoreDetails?.probScore || 0}"
                                                                  data-team-bonus="${m.scoreDetails?.teamBonus || 0}"
                                                                  data-ht-bonus="${m.scoreDetails?.htBonus || 0}">
                                                                ${m.score || 0}
                                                            </span>
                                                            <span class="ml-1 text-blue-500 text-xs cursor-help tooltip-trigger"
                                                                  data-tooltip-type="score"
                                                                  data-score="${m.score || 0}"
                                                                  data-lega-score="${m.scoreDetails?.legaScore || 0}"
                                                                  data-tip-score="${m.scoreDetails?.tipScore || 0}"
                                                                  data-prob-score="${m.scoreDetails?.probScore || 0}"
                                                                  data-team-bonus="${m.scoreDetails?.teamBonus || 0}"
                                                                  data-ht-bonus="${m.scoreDetails?.htBonus || 0}"
                                                                  title="Hover per dettagli score">
                                                                ‚ÑπÔ∏è
                                                            </span>
                                                        </div>
                                                        <div class="text-xs text-gray-500 mt-1 relative inline-block">
                                                            <span class="tooltip-trigger cursor-help"
                                                                  data-tooltip-type="stats"
                                                                  data-mercato="${m.mercato || ''}"
                                                                  data-tip="${m.tip || ''}"
                                                                  data-home-count="${team1Stats.count || 0}"
                                                                  data-home-total="${team1Stats.total || 0}"
                                                                  data-away-count="${team2Stats.count || 0}"
                                                                  data-away-total="${team2Stats.total || 0}">
                                                                ${team1Stats.stats} | ${team2Stats.stats}
                                                            </span>
                                                            <span class="ml-1 text-blue-500 cursor-help tooltip-trigger"
                                                                  data-tooltip-type="stats"
                                                                  data-mercato="${m.mercato || ''}"
                                                                  data-tip="${m.tip || ''}"
                                                                  data-home-count="${team1Stats.count || 0}"
                                                                  data-home-total="${team1Stats.total || 0}"
                                                                  data-away-count="${team2Stats.count || 0}"
                                                                  data-away-total="${team2Stats.total || 0}"
                                                                  title="Hover per dettagli">
                                                                ‚ÑπÔ∏è
                                                            </span>
                                                        </div>
                                                    </div>
                                                </div>
                                                
                                                <!-- AI TRADING ADVICE -->
                                                <div class="mt-3 p-3 rounded-lg ${advice.confidenceColor} border-l-4 ${advice.confidence === 'MOLTO ALTA' || advice.confidence === 'ALTA' ? 'border-green-500' : advice.confidence === 'MEDIA' ? 'border-yellow-500' : 'border-red-500'}">
                                                    <div class="font-bold text-sm mb-2">
                                                        üéØ STRATEGIA ${advice.confidenceIcon}
                                                        <span class="float-right">${advice.confidence}</span>
                                                    </div>
                                                    <div class="text-xs space-y-1">
                                                        <div><strong>üí∞ Entry:</strong> ${advice.entry}</div>
                                                        ${advice.timing ? `<div><strong>‚ö° Timing:</strong> ${advice.timing}</div>` : ''}
                                                        ${advice.plan ? `<div><strong>üéØ Plan:</strong> ${advice.plan}</div>` : ''}
                                                        ${advice.greenInfo && advice.greenInfo !== 'N/A' ? `<div><strong>üíö Green:</strong> ${advice.greenInfo}</div>` : ''}
                                                        ${advice.stopLoss ? `<div><strong>‚õî Stop:</strong> ${advice.stopLoss}</div>` : ''}
                                                        <div class="pt-1 mt-1 border-t border-gray-300"><strong>üìà Perch√©:</strong> ${advice.reason}</div>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    // SALVA DATI PER TRACKING
                    lastGeneratedRanking = {
                        timestamp: new Date().toISOString(),
                        data_partite: rankingDate,
                        filtro_nome: filterName,
                        filtro_id: selectedFilterId || null,
                        partite_by_tip: {},
                        stats: {
                            totale_partite: rankedMatches.length,
                            score_minimo: scoreMin,
                            tips_count: Object.keys(byTip).length
                        }
                    };
                    
                    // Organizza partite per tip
                    Object.keys(byTip).forEach(tip => {
                        lastGeneratedRanking.partite_by_tip[tip] = byTip[tip].map(m => ({
                            partita: m.partita,
                            lega: m.lega,
                            tip: m.tip,
                            mercato: m.mercato,
                            quota: m.quota,
                            probabilita: m.probabilita,
                            score: m.score,
                            esito: null // Verr√† aggiornato quando carichi risultati
                        }));
                    });
                    
                    resultsContainer.innerHTML = `
                        <div class="mb-6 bg-gradient-to-r from-purple-500 to-blue-500 text-white p-6 rounded-xl shadow">
                            <h2 class="text-3xl font-bold mb-2">üèÜ Ranking ${rankingDate}</h2>
                            <div class="text-lg mb-1">üìä Filtro: <span class="font-bold">${filterName}</span></div>
                            <div class="text-sm opacity-90 mb-3">
                                ‚úÖ ${rankedMatches.length} partite totali su ${todayMatches.length} filtrate ‚Ä¢ 
                                Score minimo: ${scoreMin} ‚Ä¢ 
                                ${Object.keys(byTip).length} tip diverse
                            </div>
                            <button id="save-ranking-btn" class="bg-white text-purple-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                                <i class="fa-solid fa-save mr-2"></i>Salva Ranking per Tracking ML
                            </button>
                            <button id="export-csv-btn" class="bg-white text-blue-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md">
                                <i class="fa-solid fa-download mr-2"></i>Esporta CSV Strategie
                            </button>
                        </div>
                        ${tipBlocks}
                    `;
                    
                    // Event listener per salva ranking
                    document.getElementById('save-ranking-btn').addEventListener('click', saveRankingForTracking);
                    
                    // Event listener per export CSV
                    document.getElementById('export-csv-btn').addEventListener('click', () => {
                        const csvData = [];
                        csvData.push(['Data', 'Lega', 'Partita', 'Tip', 'Quota', 'Prob%', 'HT', 'Ora', 'Score', 'Confidence', 'Entry', 'Green'].join(','));
                        
                        Object.keys(byTip).forEach(tip => {
                            byTip[tip].forEach(m => {
                                const advice = generateTradingAdvice(m, tipTarget);
                                const htInfo = m.info_ht || '-';
                                const time = m.time || '-';
                                
                                csvData.push([
                                    m.data,
                                    `"${m.lega}"`,
                                    `"${m.partita}"`,
                                    m.tip,
                                    m.quota.toFixed(2),
                                    m.probabilita,
                                    `"${htInfo}"`,
                                    time,
                                    m.score,
                                    advice.confidence,
                                    `"${advice.entry}"`,
                                    `"${advice.greenInfo || 'N/A'}"`
                                ].join(','));
                            });
                        });
                        
                        const csvContent = csvData.join('\n');
                        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = `strategie_${rankingDate}_${filterName.replace(/\s+/g, '_')}.csv`;
                        link.click();
                    });
                } catch(e) {
                    console.error('Error:', e);
                    resultsContainer.innerHTML = `<div class="bg-red-50 p-6 rounded-xl text-center">‚ùå Errore: ${e.message}</div>`;
                }
            });
            
            // ==================== MAGIC TOP 5 FUNCTIONS ====================
            
            // MAGIC: Calcola score speciale per singole/multiple (alta affidabilit√†)
            function calculateMagicSingoleScore(match, leaguePerformance, dbCompleto) {
                const baseScore = calculateScore(match, new Set([match.lega.toLowerCase()]), new Set([match.tip]), leaguePerformance, dbCompleto);
                let magicScore = baseScore.totalScore;
                
                // BONUS per probabilit√† molto alta (>80%)
                if (match.probabilita >= 85) magicScore += 15;
                else if (match.probabilita >= 80) magicScore += 10;
                
                // BONUS per leghe top Over (se tip √® Over)
                if (match.tip.startsWith('+')) {
                    const isTopLeague = TOP_OVER_LEAGUES.some(l => match.lega.toLowerCase().includes(l.toLowerCase().replace('EU-', '').replace('NA-', '')));
                    if (isTopLeague) magicScore += 10;
                }
                
                // BONUS per quote sicure (1.15-1.35 sweet spot)
                if (match.quota >= 1.15 && match.quota <= 1.35) magicScore += 8;
                else if (match.quota >= 1.10 && match.quota <= 1.45) magicScore += 5;
                
                // PENALIT√Ä per quote troppo basse (poco valore)
                if (match.quota < 1.10) magicScore -= 15;
                
                // BONUS HT forte (correlato a partite con gol)
                if (match.info_ht) {
                    const htMatch = match.info_ht.match(/(\d+)%/);
                    if (htMatch) {
                        const htProb = parseInt(htMatch[1]);
                        if (htProb >= 75) magicScore += 12;
                        else if (htProb >= 65) magicScore += 6;
                    }
                }
                
                return { ...baseScore, magicScore, type: 'singola' };
            }
            
            // MAGIC: Calcola score speciale per trading (tardo pomeriggio + HT + Over)
            function calculateMagicTradingScore(match, leaguePerformance, dbCompleto) {
                const baseScore = calculateScore(match, new Set([match.lega.toLowerCase()]), new Set([match.tip]), leaguePerformance, dbCompleto);
                let magicScore = baseScore.totalScore;
                
                // BONUS ORARIO: preferisci 17:00-22:00 per trading italiano
                if (match.time) {
                    const [hours] = match.time.split(':').map(Number);
                    if (hours >= 17 && hours <= 22) magicScore += 20;
                    else if (hours >= 15 && hours <= 23) magicScore += 10;
                    else if (hours < 14) magicScore -= 10; // Penalizza mattina
                }
                
                // BONUS HT FORTE (critico per trading)
                if (match.info_ht) {
                    const htMatch = match.info_ht.match(/(\d+)%/);
                    if (htMatch) {
                        const htProb = parseInt(htMatch[1]);
                        if (htProb >= 78) magicScore += 25;
                        else if (htProb >= 70) magicScore += 15;
                        else if (htProb >= 60) magicScore += 8;
                    }
                } else {
                    magicScore -= 10; // Penalit√† senza HT
                }
                
                // BONUS per tip Over (ideali per trading)
                if (match.tip === '+1.5') magicScore += 10;
                else if (match.tip === '+2.5') magicScore += 5;
                
                // BONUS quota ragionevole per green decente
                if (match.quota >= 1.15 && match.quota <= 1.30) magicScore += 8;
                
                // BONUS leghe top Over
                const isTopLeague = TOP_OVER_LEAGUES.some(l => match.lega.toLowerCase().includes(l.toLowerCase().replace('EU-', '').replace('NA-', '')));
                if (isTopLeague) magicScore += 8;
                
                return { ...baseScore, magicScore, type: 'trading' };
            }
            
            // MAGIC: Genera selezione automatica
            async function generateMagicSelection(type) {
                const rankingDate = document.getElementById('ranking-date').value;
                
                if (!rankingDate) {
                    alert('Seleziona prima una data!');
                    return;
                }
                
                const magicResults = document.getElementById('magic-results');
                const rankingResults = document.getElementById('ranking-results');
                rankingResults.innerHTML = '';
                magicResults.classList.remove('hidden');
                magicResults.innerHTML = '<div class="bg-white p-6 rounded-xl shadow text-center"><div class="animate-pulse text-lg">üîÆ Magia in corso... <br><span class="text-sm text-gray-500">(Analisi di 12,000+ match storici)</span></div></div>';
                
                try {
                    // Carica partite del giorno senza risultato
                    let todayMatches = allMatches.filter(m => m.data === rankingDate && !m.risultato);
                    
                    if (todayMatches.length === 0) {
                        magicResults.innerHTML = '<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita trovata per questa data!</div>';
                        return;
                    }
                    
                    const leaguePerformance = analyzeLeaguePerformance(allMatches);
                    
                    // Carica orari per le partite
                    for (let match of todayMatches) {
                        const ora = await getTimeFromCache(match.data, match.partita);
                        if (ora) match.time = ora;
                    }
                    
                    let rankedMatches = [];
                    let title = '';
                    let subtitle = '';
                    let icon = '';
                    let gradientClass = '';
                    
                    if (type === 'singole') {
                        // TOP 5 SINGOLE: alta probabilit√†, score elevato
                        rankedMatches = todayMatches
                            .filter(m => m.probabilita >= 70 && m.quota >= 1.10 && m.quota <= 1.50)
                            .map(m => ({
                                ...m,
                                scoreDetails: calculateMagicSingoleScore(m, leaguePerformance, allMatches)
                            }))
                            .filter(m => m.scoreDetails.magicScore >= 50)
                            .sort((a, b) => b.scoreDetails.magicScore - a.scoreDetails.magicScore)
                            .slice(0, 5);
                        
                        title = 'üéØ TOP 5 SINGOLE/MULTIPLE';
                        subtitle = 'Selezione automatica: alta probabilit√† + score elevato + leghe affidabili';
                        icon = 'fa-bullseye';
                        gradientClass = 'from-green-500 to-emerald-600';
                        
                    } else if (type === 'trading') {
                        // TOP 5 TRADING: orario tardo + HT forte + Over
                        rankedMatches = todayMatches
                            .filter(m => m.tip.startsWith('+') && m.probabilita >= 65)
                            .map(m => ({
                                ...m,
                                scoreDetails: calculateMagicTradingScore(m, leaguePerformance, allMatches)
                            }))
                            .filter(m => m.scoreDetails.magicScore >= 40)
                            .sort((a, b) => b.scoreDetails.magicScore - a.scoreDetails.magicScore)
                            .slice(0, 5);
                        
                        title = 'üìà TOP 5 TRADING BETFAIR';
                        subtitle = 'Selezione automatica: orario ideale + HT forte + Over per green';
                        icon = 'fa-chart-line';
                        gradientClass = 'from-blue-500 to-indigo-600';
                    }
                    
                    if (rankedMatches.length === 0) {
                        magicResults.innerHTML = `<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita soddisfa i criteri Magic per oggi.<br><span class="text-sm">Prova con il ranking standard.</span></div>`;
                        return;
                    }
                    
                    // SALVA per tracking ML
                    lastGeneratedRanking = {
                        timestamp: new Date().toISOString(),
                        data_partite: rankingDate,
                        filtro_nome: `MAGIC_${type.toUpperCase()}`,
                        filtro_id: null,
                        magic_type: type,
                        partite_by_tip: {},
                        stats: {
                            totale_partite: rankedMatches.length,
                            score_minimo: Math.min(...rankedMatches.map(m => m.scoreDetails.magicScore)),
                            tips_count: new Set(rankedMatches.map(m => m.tip)).size
                        }
                    };
                    
                    rankedMatches.forEach(m => {
                        if (!lastGeneratedRanking.partite_by_tip[m.tip]) {
                            lastGeneratedRanking.partite_by_tip[m.tip] = [];
                        }
                        lastGeneratedRanking.partite_by_tip[m.tip].push({
                            partita: m.partita,
                            lega: m.lega,
                            tip: m.tip,
                            mercato: m.mercato,
                            quota: m.quota,
                            probabilita: m.probabilita,
                            score: m.scoreDetails.magicScore,
                            esito: null
                        });
                    });
                    
                    // Render risultati Magic
                    const matchCards = rankedMatches.map((m, idx) => {
                        const [team1, team2] = m.partita.split(' - ');
                        const team1Stats = analyzeTeamStats(team1, true, m.tip, allMatches);
                        const team2Stats = analyzeTeamStats(team2, false, m.tip, allMatches);
                        
                        // USA MAGIC ADVICE invece di generateTradingAdvice standard
                        const advice = generateMagicAdvice(m, type);
                        
                        // HT indicator
                        let htBadge = '<span class="text-gray-400 text-xs">No HT</span>';
                        if (m.info_ht) {
                            const htMatch = m.info_ht.match(/(\d+)%/);
                            if (htMatch) {
                                const htProb = parseInt(htMatch[1]);
                                const htClass = htProb >= 75 ? 'bg-green-100 text-green-700' : htProb >= 60 ? 'bg-yellow-100 text-yellow-700' : 'bg-gray-100 text-gray-600';
                                htBadge = `<span class="${htClass} px-2 py-1 rounded text-xs font-bold">HT: ${m.info_ht}</span>`;
                            }
                        }
                        
                        // Time badge
                        let timeBadge = '';
                        if (m.time) {
                            const [hours] = m.time.split(':').map(Number);
                            const timeClass = (hours >= 17 && hours <= 22) ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-600';
                            timeBadge = `<span class="${timeClass} px-2 py-1 rounded text-xs font-bold">‚è∞ ${m.time}</span>`;
                        }
                        
                        // Magic Score Tooltip content (user-friendly)
                        const tooltipContent = generateUserFriendlyTooltip(m, type);
                        
                        return `
                            <div class="bg-white border-2 ${idx === 0 ? 'border-amber-400 shadow-lg' : 'border-gray-200'} rounded-xl p-5 mb-4 hover:shadow-md transition-shadow">
                                <div class="flex justify-between items-start mb-3">
                                    <div class="flex-1">
                                        <div class="flex items-center gap-2 mb-2">
                                            <span class="bg-gradient-to-r ${gradientClass} text-white text-xs font-bold px-3 py-1 rounded-full">
                                                #${idx + 1}
                                            </span>
                                            ${idx === 0 ? '<span class="text-amber-500 text-lg">üëë</span>' : ''}
                                            <span class="text-xs text-gray-500">${m.lega}</span>
                                        </div>
                                        <div class="font-bold text-lg mb-2">
                                            <span class="team-${team1Stats.color}">${team1}</span>
                                            <span class="text-gray-400 mx-2">vs</span>
                                            <span class="team-${team2Stats.color}">${team2}</span>
                                        </div>
                                        <div class="flex flex-wrap gap-2 text-xs">
                                            <span class="bg-purple-100 text-purple-700 px-2 py-1 rounded font-bold">${m.tip} @${m.quota.toFixed(2)}</span>
                                            <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded">${m.probabilita}% prob</span>
                                            ${htBadge}
                                            ${timeBadge}
                                        </div>
                                    </div>
                                    <div class="text-center tooltip-trigger cursor-help" data-tooltip-type="magic" data-magic-content="${encodeURIComponent(tooltipContent)}">
                                        <div class="text-3xl font-black bg-gradient-to-r ${gradientClass} bg-clip-text text-transparent">
                                            ${m.scoreDetails.magicScore}
                                        </div>
                                        <div class="text-xs text-gray-500">MAGIC</div>
                                    </div>
                                </div>
                                
                                <!-- PERCH√â QUESTA PARTITA (user-friendly) -->
                                <div class="bg-gray-50 rounded-lg p-3 mb-3">
                                    <div class="text-xs font-bold text-gray-700 mb-2">üìä PERCH√â QUESTA PARTITA:</div>
                                    <div class="text-xs text-gray-600 space-y-1">
                                        ${generateWhyThisMatch(m, type)}
                                    </div>
                                </div>
                                
                                <!-- STRATEGIA -->
                                <div class="p-3 rounded-lg ${advice.confidenceColor} border-l-4 ${advice.confidence === 'MOLTO ALTA' || advice.confidence === 'ALTA' ? 'border-green-500' : advice.confidence === 'MEDIA' ? 'border-yellow-500' : 'border-red-500'}">
                                    <div class="font-bold text-sm mb-2">
                                        ${advice.confidenceIcon} ${type === 'trading' ? 'STRATEGIA TRADING' : 'STRATEGIA'}
                                        <span class="float-right text-xs">${advice.confidence}</span>
                                    </div>
                                    <div class="text-xs space-y-1">
                                        <div><strong>üí∞ Entry:</strong> ${advice.entry}</div>
                                        ${advice.timing ? `<div><strong>‚ö° Timing:</strong> ${advice.timing}</div>` : ''}
                                        ${advice.plan ? `<div><strong>üéØ Plan:</strong> ${advice.plan}</div>` : ''}
                                        ${advice.greenInfo && advice.greenInfo !== 'N/A' ? `<div><strong>üíö Green:</strong> ${advice.greenInfo}</div>` : ''}
                                        ${advice.stopLoss ? `<div><strong>‚õî Stop:</strong> ${advice.stopLoss}</div>` : ''}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    magicResults.innerHTML = `
                        <div class="mb-6 bg-gradient-to-r ${gradientClass} text-white p-6 rounded-xl shadow-lg">
                            <div class="flex items-center gap-3 mb-2">
                                <span class="text-4xl">üîÆ</span>
                                <div>
                                    <h2 class="text-2xl font-bold">${title}</h2>
                                    <p class="text-sm opacity-90">${subtitle}</p>
                                </div>
                            </div>
                            <div class="text-sm opacity-90 mt-3">
                                üìÖ ${rankingDate} ‚Ä¢ ${rankedMatches.length} partite selezionate ‚Ä¢ Basato su 12,000+ match storici
                            </div>
                            <div class="flex gap-3 mt-4">
                                <button id="save-magic-btn" class="bg-white text-gray-800 px-4 py-2 rounded-lg font-bold hover:bg-gray-100 text-sm">
                                    <i class="fa-solid fa-save mr-2"></i>Salva per Tracking
                                </button>
                            </div>
                        </div>
                        ${matchCards}
                    `;
                    
                    // Event listener salvataggio
                    document.getElementById('save-magic-btn').addEventListener('click', saveRankingForTracking);
                    
                } catch(e) {
                    console.error('Magic Error:', e);
                    magicResults.innerHTML = `<div class="bg-red-50 p-6 rounded-xl text-center">‚ùå Errore: ${e.message}</div>`;
                }
            }
            
            // Genera spiegazione user-friendly per tooltip
            function generateUserFriendlyTooltip(match, type) {
                const parts = [];
                const s = match.scoreDetails;
                
                if (s.legaScore > 10) parts.push(`Lega top: +${s.legaScore}`);
                if (s.tipScore > 10) parts.push(`Tip affidabile: +${s.tipScore}`);
                if (s.probScore > 15) parts.push(`Prob alta: +${s.probScore}`);
                if (s.teamBonus > 10) parts.push(`Squadre prolifiche: +${s.teamBonus}`);
                if (s.htBonus > 5) parts.push(`HT boost: +${s.htBonus}`);
                
                return parts.join(' | ');
            }
            
            // Genera "Perch√© questa partita" in modo chiaro
            function generateWhyThisMatch(match, type) {
                const reasons = [];
                const s = match.scoreDetails;
                
                // Probabilit√†
                if (match.probabilita >= 85) {
                    reasons.push(`<div>‚úÖ <strong>Probabilit√† eccellente</strong> (${match.probabilita}%) - storico molto favorevole</div>`);
                } else if (match.probabilita >= 75) {
                    reasons.push(`<div>‚úÖ <strong>Probabilit√† alta</strong> (${match.probabilita}%) - buono storico</div>`);
                }
                
                // Lega
                if (s.legaScore >= 15) {
                    reasons.push(`<div>üèÜ <strong>Lega top</strong> per questo tipo di scommessa</div>`);
                } else if (s.legaScore >= 10) {
                    reasons.push(`<div>üèÜ <strong>Lega affidabile</strong> - buone performance storiche</div>`);
                }
                
                // Squadre
                if (s.teamBonus >= 20) {
                    reasons.push(`<div>‚öΩ <strong>Entrambe le squadre prolifiche</strong> - tendenza gol alta</div>`);
                } else if (s.teamBonus >= 10) {
                    reasons.push(`<div>‚öΩ <strong>Squadre con buona tendenza gol</strong></div>`);
                }
                
                // HT
                if (match.info_ht) {
                    const htMatch = match.info_ht.match(/(\d+)%/);
                    if (htMatch) {
                        const htProb = parseInt(htMatch[1]);
                        if (htProb >= 75) {
                            reasons.push(`<div>üî• <strong>HT molto alto</strong> (${htProb}%) - gol probabile nel 1¬∞ tempo</div>`);
                        } else if (htProb >= 65) {
                            reasons.push(`<div>üí° <strong>HT buono</strong> (${htProb}%) - possibile gol precoce</div>`);
                        }
                    }
                }
                
                // Orario (per trading)
                if (type === 'trading' && match.time) {
                    const [hours] = match.time.split(':').map(Number);
                    if (hours >= 17 && hours <= 22) {
                        reasons.push(`<div>‚è∞ <strong>Orario ideale</strong> (${match.time}) - perfetto per trading serale</div>`);
                    }
                }
                
                // Quota
                if (match.quota >= 1.15 && match.quota <= 1.35) {
                    reasons.push(`<div>üí∞ <strong>Quota bilanciata</strong> (@${match.quota.toFixed(2)}) - buon rapporto rischio/rendimento</div>`);
                }
                
                return reasons.length > 0 ? reasons.join('') : '<div>Partita selezionata per score complessivo elevato</div>';
            }
            
            // Event listeners per Magic buttons
            document.getElementById('magic-singole-btn').addEventListener('click', () => generateMagicSelection('singole'));
            document.getElementById('magic-trading-btn').addEventListener('click', () => generateMagicSelection('trading'));
            
            // MAGIC ADVICE - usa magicScore per confidence (non base score!)
            function generateMagicAdvice(match, type) {
                const magicScore = match.scoreDetails.magicScore;
                const quota = match.quota;
                const tip = match.tip;
                
                // Estrai HT prob se disponibile
                let htProb = 0;
                if (match.info_ht) {
                    const htMatch = match.info_ht.match(/(\d+)%/);
                    if (htMatch) htProb = parseInt(htMatch[1]);
                }
                
                // Target tip per trading
                const targetTip = type === 'trading' ? '+2.5' : tip;
                const targetOdds = getTargetOdds(match, type === 'trading' ? '+2.5' : null);
                
                const advice = {
                    confidence: '',
                    confidenceIcon: '',
                    confidenceColor: '',
                    entry: '',
                    timing: '',
                    plan: '',
                    stopLoss: '',
                    reason: '',
                    riskLevel: '',
                    greenInfo: ''
                };
                
                // SOGLIE MAGIC (pi√π alte perch√© magicScore include bonus extra)
                if (magicScore >= 120) {
                    advice.confidence = 'ECCELLENTE';
                    advice.confidenceIcon = 'üî•üî•';
                    advice.confidenceColor = 'text-green-700 bg-green-100';
                    advice.riskLevel = 'MOLTO BASSO';
                    
                    if (type === 'trading') {
                        advice.entry = `BACK Over 2.5 ${targetOdds ? targetOdds.display : ''} pre-match`;
                        advice.timing = htProb >= 70 ? `Gol quasi certo 1¬∞T (HT ${htProb}%)` : `Partita ad alto potenziale gol`;
                        advice.plan = `Se gol entro 25' ‚Üí LAY Over 2.5 per green sicuro`;
                        advice.stopLoss = `Se 0-0 a 60' ‚Üí Cash out con -5% max`;
                        advice.reason = `Magic Score ${magicScore} = TOP PICK! Tutti i fattori allineati.`;
                    } else {
                        advice.entry = `${tip} @${quota.toFixed(2)} - ALTA FIDUCIA`;
                        advice.timing = `Ottima per singola o inserimento in multipla`;
                        advice.plan = `Stake normale (1-2% bankroll)`;
                        advice.stopLoss = `N/A - scommessa diretta`;
                        advice.reason = `Magic Score ${magicScore} = TOP PICK! Probabilit√† + storico eccellenti.`;
                    }
                    
                    if (targetOdds && targetOdds.isEstimate) {
                        const greenRange = calculateGreenRange(100, quota, targetOdds.min, targetOdds.max);
                        advice.greenInfo = `‚Ç¨${greenRange.min.toFixed(2)}-‚Ç¨${greenRange.max.toFixed(2)} su ‚Ç¨100`;
                    } else if (targetOdds) {
                        const green = calculateGreen(100, quota, targetOdds.odds);
                        advice.greenInfo = `‚Ç¨${green.toFixed(2)} su ‚Ç¨100`;
                    }
                    
                } else if (magicScore >= 100) {
                    advice.confidence = 'MOLTO ALTA';
                    advice.confidenceIcon = 'üî•';
                    advice.confidenceColor = 'text-green-600 bg-green-50';
                    advice.riskLevel = 'BASSO';
                    
                    if (type === 'trading') {
                        advice.entry = `BACK Over 2.5 ${targetOdds ? targetOdds.display : ''} pre-match`;
                        advice.timing = htProb >= 65 ? `Gol probabile 1¬∞T (HT ${htProb}%)` : `Buone probabilit√† gol precoce`;
                        advice.plan = `Monitor primi 30', se gol ‚Üí LAY per green`;
                        advice.stopLoss = `Se 0-0 a 55' ‚Üí Cash out con -8%`;
                        advice.reason = `Magic Score ${magicScore} molto alto. Ottimo per trading.`;
                    } else {
                        advice.entry = `${tip} @${quota.toFixed(2)} - Consigliata`;
                        advice.timing = `Buona per singola o multipla`;
                        advice.plan = `Stake normale`;
                        advice.stopLoss = `N/A`;
                        advice.reason = `Magic Score ${magicScore} = scelta solida.`;
                    }
                    
                    if (targetOdds && targetOdds.isEstimate) {
                        const greenRange = calculateGreenRange(100, quota, targetOdds.min, targetOdds.max);
                        advice.greenInfo = `‚Ç¨${greenRange.min.toFixed(2)}-‚Ç¨${greenRange.max.toFixed(2)} su ‚Ç¨100`;
                    } else if (targetOdds) {
                        const green = calculateGreen(100, quota, targetOdds.odds);
                        advice.greenInfo = `‚Ç¨${green.toFixed(2)} su ‚Ç¨100`;
                    }
                    
                } else if (magicScore >= 80) {
                    advice.confidence = 'ALTA';
                    advice.confidenceIcon = '‚ö°';
                    advice.confidenceColor = 'text-blue-600 bg-blue-50';
                    advice.riskLevel = 'MEDIO-BASSO';
                    
                    if (type === 'trading') {
                        advice.entry = `BACK Over 2.5 ${targetOdds ? targetOdds.display : ''} con stake ridotto`;
                        advice.timing = htProb >= 60 ? `Possibile gol 1¬∞T (HT ${htProb}%)` : `Monitorare andamento`;
                        advice.plan = `Entry cauta, se gol ‚Üí LAY per green`;
                        advice.stopLoss = `Se 0-0 a 50' ‚Üí Cash out con -10%`;
                        advice.reason = `Magic Score ${magicScore} buono ma non eccezionale.`;
                    } else {
                        advice.entry = `${tip} @${quota.toFixed(2)} - Buona scelta`;
                        advice.timing = `Valida per singola`;
                        advice.plan = `Stake ridotto (0.5-1% bankroll)`;
                        advice.stopLoss = `N/A`;
                        advice.reason = `Magic Score ${magicScore} = scelta valida.`;
                    }
                    
                    if (targetOdds && targetOdds.isEstimate) {
                        const greenRange = calculateGreenRange(100, quota, targetOdds.min, targetOdds.max);
                        advice.greenInfo = `‚Ç¨${greenRange.min.toFixed(2)}-‚Ç¨${greenRange.max.toFixed(2)} possibili`;
                    } else if (targetOdds) {
                        const green = calculateGreen(100, quota, targetOdds.odds);
                        advice.greenInfo = `‚Ç¨${green.toFixed(2)} possibili`;
                    }
                    
                } else {
                    // Score < 80 (non dovrebbe apparire nel Magic TOP 5 ma per sicurezza)
                    advice.confidence = 'MEDIA';
                    advice.confidenceIcon = 'üí°';
                    advice.confidenceColor = 'text-yellow-600 bg-yellow-50';
                    advice.riskLevel = 'MEDIO';
                    
                    advice.entry = `${tip} @${quota.toFixed(2)} - Con cautela`;
                    advice.timing = `Valutare attentamente`;
                    advice.plan = `Stake minimo`;
                    advice.stopLoss = `Exit veloce se andamento negativo`;
                    advice.reason = `Magic Score ${magicScore} nella media.`;
                    advice.greenInfo = `Variabile`;
                }
                
                return advice;
            }
            
            // ==================== RANKING TRACKING & ML ====================
            async function saveRankingForTracking() {
                if (!lastGeneratedRanking) {
                    showModal("Errore", "Nessun ranking da salvare!", () => {});
                    return;
                }
                
                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    await addDoc(rankingHistoryCol, lastGeneratedRanking);
                    
                    showModal("‚úÖ Salvato!", `Ranking salvato per tracking ML!\nData: ${lastGeneratedRanking.data_partite}\nPartite: ${lastGeneratedRanking.stats.totale_partite}`, () => {});
                    
                    // Disabilita bottone dopo salvataggio
                    const btn = document.getElementById('save-ranking-btn');
                    if (btn) {
                        btn.disabled = true;
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                        btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Ranking Salvato';
                    }
                } catch(e) {
                    showModal("Errore", `Errore salvataggio: ${e.message}`, () => {});
                }
            }
            
            async function updateRankingResults(uploadedDate, uploadedMatches) {
                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    const q = query(rankingHistoryCol, where("data_partite", "==", uploadedDate));
                    const snapshot = await getDocs(q);
                    
                    if (snapshot.empty) {
                        return null; // Nessun ranking salvato per quella data
                    }
                    
                    let totalUpdated = 0;
                    const performanceByFilter = {};
                    
                    for (const docSnap of snapshot.docs) {
                        const ranking = docSnap.data();
                        let updated = false;
                        
                        // Per ogni tip nel ranking
                        Object.keys(ranking.partite_by_tip).forEach(tip => {
                            ranking.partite_by_tip[tip].forEach(partitaRanking => {
                                // Trova match corrispondente nei risultati caricati
                                const match = uploadedMatches.find(m => 
                                    m.partita === partitaRanking.partita && 
                                    m.tip === partitaRanking.tip &&
                                    m.risultato
                                );
                                
                                if (match && match.esito) {
                                    partitaRanking.esito = match.esito;
                                    partitaRanking.risultato = match.risultato;
                                    updated = true;
                                    totalUpdated++;
                                }
                            });
                        });
                        
                        if (updated) {
                            // Calcola performance
                            let totalMatches = 0;
                            let wonMatches = 0;
                            
                            Object.keys(ranking.partite_by_tip).forEach(tip => {
                                ranking.partite_by_tip[tip].forEach(p => {
                                    if (p.esito) {
                                        totalMatches++;
                                        if (p.esito === 'Vinto') wonMatches++;
                                    }
                                });
                            });
                            
                            const winrate = totalMatches > 0 ? Math.round((wonMatches / totalMatches) * 100) : 0;
                            ranking.performance = {
                                totale: totalMatches,
                                vinte: wonMatches,
                                perse: totalMatches - wonMatches,
                                winrate: winrate
                            };
                            
                            // Aggiorna su Firestore
                            await setDoc(doc(db, "ranking_history", docSnap.id), ranking);
                            
                            performanceByFilter[ranking.filtro_nome] = ranking.performance;
                        }
                    }
                    
                    return {
                        updated: totalUpdated,
                        performance: performanceByFilter
                    };
                } catch(e) {
                    console.error("Error updating ranking results:", e);
                    return null;
                }
            }
            
            // ==================== RANKING FUNCTIONS ====================
            function calculateScore(partita, legheSet, tipsSet, leaguePerformance = {}, dbCompleto = null) {
                let legaScore = 0, tipScore = 0, probScore = 0, quotaValid = true;
                let teamBonus = 0;
                
                const lega = (partita.lega || '').toLowerCase().trim();
                if (legheSet.has(lega)) legaScore = 15;
                else if (lega.startsWith('eu-')) legaScore = 5;
                
                let tipNorm = (partita.tip || '').trim().toUpperCase();
                if (tipsSet.has(tipNorm)) tipScore = 10;
                
                const mercato = (partita.mercato || '').toLowerCase().trim();
                
                // ANALISI SQUADRE per tip GOL
                if (dbCompleto && dbCompleto.length > 0 && partita.partita) {
                    const teams = partita.partita.split(' - ');
                    if (teams.length === 2) {
                        const teamHome = teams[0].trim();
                        const teamAway = teams[1].trim();
                        
                        // Analizza entrambe le squadre
                        const homeStats = analyzeTeamStats(teamHome, true, tipNorm, dbCompleto);
                        const awayStats = analyzeTeamStats(teamAway, false, tipNorm, dbCompleto);
                        
                        // Per tip GOL (+1.5, +2.5, etc): conta tendenza gol
                        if (mercato.includes('numero di gol') || mercato.includes('goal')) {
                            // Calcola bonus squadre per gol
                            if (homeStats.total >= 5 && awayStats.total >= 5) {
                                const homePerc = (homeStats.count / homeStats.total) * 100;
                                const awayPerc = (awayStats.count / awayStats.total) * 100;
                                const avgPerc = (homePerc + awayPerc) / 2;
                                
                                // Bonus significativo per squadre con buona tendenza
                                if (avgPerc >= 70) teamBonus = 25;
                                else if (avgPerc >= 60) teamBonus = 15;
                                else if (avgPerc >= 50) teamBonus = 5;
                                else if (avgPerc < 40) teamBonus = -10; // Penalit√†
                            }
                        }
                        // Per 1X2: conta forma (gi√† gestito in league performance)
                        else if (mercato.includes('1x2') || mercato.includes('doppia chance')) {
                            // Per 1X2 usa statistiche casa/trasferta
                            if (homeStats.total >= 5) {
                                const homePerc = (homeStats.count / homeStats.total) * 100;
                                if (homePerc >= 60) teamBonus += 10;
                            }
                            if (awayStats.total >= 5) {
                                const awayPerc = (awayStats.count / awayStats.total) * 100;
                                if (awayPerc >= 60) teamBonus += 10;
                            }
                        }
                    }
                }
                
                let confidenceFactor = 1.0;
                let recencyFactor = 1.0;
                
                if (dbCompleto && dbCompleto.length > 0) {
                    const leagueMatches = dbCompleto.filter(m => (m.lega || '').toLowerCase().trim() === lega);
                    const sampleSize = leagueMatches.length;
                    confidenceFactor = Math.min(1.0, 0.5 + (sampleSize / 500));
                    
                    const threeMonthsAgo = new Date();
                    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                    const recentMatches = leagueMatches.filter(m => {
                        const matchDate = new Date(m.data || '2000-01-01');
                        return matchDate >= threeMonthsAgo;
                    });
                    if (recentMatches.length >= 10) recencyFactor = 1.2;
                }
                
                if (leaguePerformance[lega]) {
                    const leagueStats = leaguePerformance[lega];
                    
                    if (tipNorm.startsWith('+') && parseFloat(leagueStats.over25Percentage) > 55) {
                        const overPerc = parseFloat(leagueStats.over25Percentage);
                        legaScore += Math.min(15, Math.max(0, (overPerc - 55) / 2));
                    }
                    
                    if (tipNorm.startsWith('-') && parseFloat(leagueStats.under25Percentage) > 55) {
                        const underPerc = parseFloat(leagueStats.under25Percentage);
                        legaScore += Math.min(15, Math.max(0, (underPerc - 55) / 2));
                    }
                    
                    if (leagueStats.tips[tipNorm]) {
                        const tipSuccessRate = parseFloat(leagueStats.tips[tipNorm].successRate);
                        if (tipSuccessRate > 65) {
                            tipScore += Math.min(20, Math.max(0, (tipSuccessRate - 65)));
                        } else if (tipSuccessRate > 50) {
                            tipScore += Math.min(10, Math.max(0, (tipSuccessRate - 50) / 2));
                        }
                    }
                }
                
                const quota = parseFloat(partita.quota || 0);
                if (quota < 1.20) quotaValid = false;
                
                const prob = parseFloat((partita.probabilita || 0));
                if (prob <= 60) probScore = 0;
                else if (prob <= 75) probScore = 5 + Math.round((prob - 60) * 0.5);
                else probScore = 15 + Math.min(15, Math.round((prob - 75)));
                
                // HT BOOST - PI√ô SIGNIFICATIVO
                let htBonus = 0;
                if (partita.info_ht && partita.info_ht.trim() !== '') {
                    const probMatch = partita.info_ht.match(/(\d+)%/);
                    if (probMatch) {
                        const htProb = parseInt(probMatch[1]);
                        
                        // BOOST significativo per Over + HT alto
                        if (tipNorm.startsWith('+') && htProb >= 65) {
                            htBonus = Math.round((htProb - 60) * 0.4); // Max +16 punti se htProb=100
                        }
                        
                        // PENALIT√Ä per Under + HT alto
                        if (tipNorm.startsWith('-') && htProb >= 75) {
                            htBonus = -15;
                        }
                    }
                }
                
                legaScore = Math.round(legaScore * confidenceFactor * recencyFactor);
                tipScore = Math.round(tipScore * confidenceFactor);
                
                const quotaPenalty = quota < 1.15 ? 0.85 : 1.0;
                const totalScore = Math.round((legaScore + tipScore + probScore + teamBonus + htBonus) * quotaPenalty);
                
                return { 
                    legaScore, 
                    tipScore, 
                    probScore: Math.round(probScore),
                    teamBonus,
                    htBonus,
                    totalScore,
                    quotaValid
                };
            }
            
            function analyzeLeaguePerformance(dbCompleto) {
                if (!dbCompleto || dbCompleto.length === 0) return {};
                
                const leagueStats = {};
                
                dbCompleto.forEach(match => {
                    const lega = (match.lega || '').toLowerCase().trim();
                    if (!lega) return;
                    
                    if (!leagueStats[lega]) {
                        leagueStats[lega] = {
                            totalMatches: 0,
                            over25Count: 0,
                            under25Count: 0,
                            tips: {}
                        };
                    }
                    
                    leagueStats[lega].totalMatches++;
                    
                    const risultato = match.risultato || '';
                    const golMatch = risultato.match(/(\d+)\s*-\s*(\d+)/);
                    
                    let golTotali = 0;
                    if (golMatch) {
                        const golCasa = parseInt(golMatch[1]);
                        const golTrasferta = parseInt(golMatch[2]);
                        golTotali = golCasa + golTrasferta;
                        
                        if (golTotali > 2.5) leagueStats[lega].over25Count++;
                        else leagueStats[lega].under25Count++;
                    }
                    
                    const tip = (match.tip || '').trim();
                    if (tip) {
                        if (!leagueStats[lega].tips[tip]) {
                            leagueStats[lega].tips[tip] = { total: 0, success: 0 };
                        }
                        
                        leagueStats[lega].tips[tip].total++;
                        
                        let success = false;
                        if (golMatch && golTotali > 0) {
                            if (tip.startsWith('+')) {
                                const soglia = parseFloat(tip.substring(1));
                                success = golTotali > soglia;
                            } else if (tip.startsWith('-')) {
                                const soglia = parseFloat(tip.substring(1));
                                success = golTotali < soglia;
                            }
                        }
                        
                        if (success) leagueStats[lega].tips[tip].success++;
                    }
                });
                
                Object.keys(leagueStats).forEach(lega => {
                    const stats = leagueStats[lega];
                    stats.over25Percentage = (stats.over25Count / stats.totalMatches * 100).toFixed(0);
                    stats.under25Percentage = (stats.under25Count / stats.totalMatches * 100).toFixed(0);
                    
                    Object.keys(stats.tips).forEach(tip => {
                        const tipStats = stats.tips[tip];
                        tipStats.successRate = (tipStats.success / tipStats.total * 100).toFixed(0);
                    });
                });
                
                return leagueStats;
            }
            
            function analyzeTeamStats(teamName, isHome, tip, dbCompleto) {
                if (!dbCompleto || dbCompleto.length === 0) {
                    return { color: 'black', stats: '', count: 0, total: 0 };
                }
                
                const teamNorm = teamName.toLowerCase().trim();
                const mercato = dbCompleto.find(m => m.tip === tip)?.mercato || '';
                
                // NUOVA LOGICA: Diversa per tipo mercato
                let relevantMatches = [];
                
                if (mercato.toLowerCase().includes('numero di gol')) {
                    // Per OVER/UNDER: guarda TUTTI i match della squadra (non solo casa/trasferta)
                    // Conta se la squadra √® coinvolta in match con molti/pochi gol
                    const allTeamMatches = dbCompleto.filter(row => {
                        const team1 = (row.partita || '').split(' - ')[0]?.toLowerCase().trim() || '';
                        const team2 = (row.partita || '').split(' - ').slice(1).join(' - ')?.toLowerCase().trim() || '';
                        return (team1 === teamNorm || team2 === teamNorm);
                    });
                    
                    allTeamMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                    relevantMatches = allTeamMatches.slice(0, 15); // Ultimi 15 match totali
                    
                } else {
                    // Per 1X2/Doppia Chance: guarda casa/trasferta separatamente
                    let locationMatches = dbCompleto.filter(row => {
                        const team1 = (row.partita || '').split(' - ')[0]?.toLowerCase().trim() || '';
                        const team2 = (row.partita || '').split(' - ').slice(1).join(' - ')?.toLowerCase().trim() || '';
                        
                        if (isHome) return team1 === teamNorm;
                        else return team2 === teamNorm;
                    });
                    
                    locationMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                    relevantMatches = locationMatches.filter(m => m.tip === tip).slice(0, 15);
                }
                
                if (relevantMatches.length < 10) {
                    return { color: 'gray', stats: `(${relevantMatches.length})`, count: 0, total: relevantMatches.length };
                }
                
                let successCount = 0;
                relevantMatches.forEach(match => {
                    const risultato = match.risultato || '';
                    const golMatch = risultato.match(/(\d+)\s*-\s*(\d+)/);
                    
                    if (!golMatch) return;
                    
                    const golCasa = parseInt(golMatch[1]);
                    const golTrasferta = parseInt(golMatch[2]);
                    const golTotali = golCasa + golTrasferta;
                    
                    let success = false;
                    if (tip.startsWith('+')) {
                        const soglia = parseFloat(tip.substring(1));
                        success = golTotali > soglia;
                    } else if (tip.startsWith('-')) {
                        const soglia = parseFloat(tip.substring(1));
                        success = golTotali < soglia;
                    }
                    
                    if (success) successCount++;
                });
                
                const percentage = (successCount / relevantMatches.length) * 100;
                
                let color = 'black';
                if (relevantMatches.length >= 10) {
                    if (percentage > 70) color = 'green';
                    else if (percentage >= 50) color = 'yellow';
                    else color = 'red';
                }
                
                return {
                    color: color,
                    stats: `(${successCount}/${relevantMatches.length})`,
                    count: successCount,
                    total: relevantMatches.length
                };
            }
            
            // ==================== MODAL ====================
            function showModal(title, message, onConfirm) {
                document.getElementById('modal-title').textContent = title;
                document.getElementById('modal-message').textContent = message;
                const modal = document.getElementById('modal');
                modal.classList.remove('hidden');
                modal.classList.add('flex');
                
                document.getElementById('modal-confirm').onclick = () => {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                    onConfirm();
                };
                
                document.getElementById('modal-cancel').onclick = () => {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                };
            }
            
            // ==================== INIT APP ====================
            await loadAllMatches();
            await loadFavorites();
            setupFilters();
            populateFilters();
            applyFiltersAndRender();
            await loadSavedFilters();
            showPage('page-dashboard');
            
            loadingOverlay.classList.add('hidden');
        });
        
        // ==================== TOOLTIP SYSTEM ====================
        
        // Crea elemento tooltip
        const tooltipEl = document.createElement('div');
        tooltipEl.id = 'custom-tooltip';
        tooltipEl.className = 'fixed bg-gray-900 text-white text-xs rounded-lg p-3 shadow-xl pointer-events-none z-[9999] max-w-xs';
        tooltipEl.style.display = 'none';
        document.body.appendChild(tooltipEl);
        
        // Mostra tooltip - VERSIONE USER-FRIENDLY v3.3
        function showTooltipCustom(element, type) {
            const rect = element.getBoundingClientRect();
            let content = '';
            
            if (type === 'score') {
                const score = element.dataset.score || '0';
                const legaScore = parseInt(element.dataset.legaScore) || 0;
                const tipScore = parseInt(element.dataset.tipScore) || 0;
                const probScore = parseInt(element.dataset.probScore) || 0;
                const teamBonus = parseInt(element.dataset.teamBonus) || 0;
                const htBonus = parseInt(element.dataset.htBonus) || 0;
                
                // Genera spiegazione user-friendly
                const reasons = [];
                
                if (legaScore >= 15) reasons.push('üèÜ <strong>Lega top</strong> per questo mercato');
                else if (legaScore >= 10) reasons.push('üèÜ Lega con buono storico');
                else if (legaScore >= 5) reasons.push('üèÜ Lega nella media');
                
                if (tipScore >= 15) reasons.push('‚úÖ <strong>Tip molto affidabile</strong> (storico >70%)');
                else if (tipScore >= 10) reasons.push('‚úÖ Tip affidabile');
                
                if (probScore >= 20) reasons.push('üìä <strong>Prob. eccellente</strong> (>80%)');
                else if (probScore >= 15) reasons.push('üìä Prob. alta (>75%)');
                else if (probScore >= 10) reasons.push('üìä Prob. buona (>70%)');
                
                if (teamBonus >= 20) reasons.push('‚öΩ <strong>Squadre molto prolifiche</strong>');
                else if (teamBonus >= 10) reasons.push('‚öΩ Squadre con buona tendenza gol');
                else if (teamBonus < 0) reasons.push('‚ö†Ô∏è Squadre poco prolifiche');
                
                if (htBonus >= 10) reasons.push('üî• <strong>HT molto alto</strong> - gol probabile 1¬∞T');
                else if (htBonus >= 5) reasons.push('üí° HT buono');
                else if (htBonus < 0) reasons.push('‚ö†Ô∏è HT sfavorevole per questa tip');
                
                content = `
                    <div class="font-bold mb-2 text-center text-base">üìä PERCH√â SCORE ${score}</div>
                    <div class="space-y-2">
                        ${reasons.length > 0 ? reasons.map(r => `<div>${r}</div>`).join('') : '<div>Score nella media</div>'}
                    </div>
                    <div class="text-xs mt-3 pt-2 border-t border-gray-700 opacity-75 text-center">
                        <div>üî• 65+ = TOP | ‚ö° 50-64 = BUONO</div>
                        <div>üí° 30-49 = MEDIO | ‚ö†Ô∏è <30 = SKIP</div>
                    </div>
                `;
            } else if (type === 'stats') {
                const mercato = element.dataset.mercato || '';
                const tip = element.dataset.tip || '';
                const homeCount = parseInt(element.dataset.homeCount) || 0;
                const homeTotal = parseInt(element.dataset.homeTotal) || 0;
                const awayCount = parseInt(element.dataset.awayCount) || 0;
                const awayTotal = parseInt(element.dataset.awayTotal) || 0;
                
                const homePerc = homeTotal > 0 ? Math.round((homeCount / homeTotal) * 100) : 0;
                const awayPerc = awayTotal > 0 ? Math.round((awayCount / awayTotal) * 100) : 0;
                
                const homeColor = homePerc >= 70 ? 'üü¢' : homePerc >= 50 ? 'üü°' : 'üî¥';
                const awayColor = awayPerc >= 70 ? 'üü¢' : awayPerc >= 50 ? 'üü°' : 'üî¥';
                
                // Per mercato GOL mostra tendenza gol con spiegazione chiara
                if (mercato.toLowerCase().includes('gol') || mercato.toLowerCase().includes('goal') || tip.startsWith('+') || tip.startsWith('-')) {
                    const tipLabel = tip.startsWith('+') ? `Over ${tip.substring(1)}` : tip.startsWith('-') ? `Under ${tip.substring(1)}` : tip;
                    
                    // Valutazione complessiva
                    const avgPerc = (homePerc + awayPerc) / 2;
                    let verdict = '';
                    if (avgPerc >= 70) verdict = '<div class="text-green-400 font-bold mt-2">‚úÖ COPPIA PROLIFICA - Ottimo per Over!</div>';
                    else if (avgPerc >= 55) verdict = '<div class="text-yellow-400 mt-2">üí° Tendenza gol nella media</div>';
                    else verdict = '<div class="text-red-400 mt-2">‚ö†Ô∏è Squadre poco prolifiche</div>';
                    
                    content = `
                        <div class="font-bold mb-2 text-center">‚öΩ TENDENZA GOL (${tipLabel})</div>
                        <div class="space-y-1">
                            <div>${homeColor} <strong>Casa:</strong> ${homeCount}/${homeTotal} (${homePerc}%)</div>
                            <div>${awayColor} <strong>Trasferta:</strong> ${awayCount}/${awayTotal} (${awayPerc}%)</div>
                        </div>
                        ${verdict}
                        <div class="text-xs mt-2 pt-2 border-t border-gray-700 opacity-75">
                            üü¢ 70%+ = Prolifica | üü° 50-69% = Media | üî¥ <50% = Scarsa
                        </div>
                    `;
                } else {
                    // Per 1X2/Doppia Chance
                    content = `
                        <div class="font-bold mb-2 text-center">üìà FORMA SQUADRE</div>
                        <div class="space-y-1">
                            <div>${homeColor} <strong>Casa:</strong> ${homeCount}/${homeTotal} (${homePerc}%)</div>
                            <div>${awayColor} <strong>Trasferta:</strong> ${awayCount}/${awayTotal} (${awayPerc}%)</div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t border-gray-700 opacity-75">
                            üü¢ 70%+ = OTTIMA | üü° 50-69% = MEDIA | üî¥ <50% = SCARSA
                        </div>
                    `;
                }
            }
            
            tooltipEl.innerHTML = content;
            tooltipEl.style.display = 'block';
            
            // Posiziona tooltip - FIX: Rimuovi scrollY perch√© √® position: fixed
            setTimeout(() => {
                const tooltipRect = tooltipEl.getBoundingClientRect();
                let top = rect.top - tooltipRect.height - 10;
                let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
                
                // Evita overflow top/bottom/left/right
                if (top < 0) top = rect.bottom + 10;
                if (left < 10) left = 10;
                if (left + tooltipRect.width > window.innerWidth) {
                    left = window.innerWidth - tooltipRect.width - 10;
                }
                
                tooltipEl.style.top = `${top}px`; // FIX: Solo top relativo a viewport
                tooltipEl.style.left = `${left}px`;
            }, 0);
        }
        
        // Nascondi tooltip
        function hideTooltipCustom() {
            tooltipEl.style.display = 'none';
        }
        
        // Event delegation per tooltip - FIX: Usa mouseover per bubbling corretto
        document.addEventListener('mouseover', (e) => {
            const trigger = e.target.closest('.tooltip-trigger');
            if (trigger && trigger.dataset.tooltipType) {
                showTooltipCustom(trigger, trigger.dataset.tooltipType);
            } else {
                hideTooltipCustom();
            }
        });
        
        document.addEventListener('mouseout', (e) => {
             // Lascia che mouseover gestisca la scomparsa se esce dal trigger
             const related = e.relatedTarget;
             const trigger = e.target.closest('.tooltip-trigger');
             if (trigger && (!related || !trigger.contains(related))) {
                 hideTooltipCustom();
             }
        });
    </script>
</body>
</html>