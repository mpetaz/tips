<!DOCTYPE html>
<html lang="it" class="h-full bg-gray-50">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tipster-AI Admin</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css" rel="stylesheet">
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .noUi-connect {
            background: #3b82f6;
        }

        .noUi-handle {
            border-radius: 9999px;
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        .tip-button.active {
            background-color: #3b82f6;
            color: white;
            border-color: #3b82f6;
            font-weight: 600;
        }

        .sortable-header {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .sortable-header:hover {
            background-color: #e5e7eb;
        }

        .sort-icon {
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .sortable-header.active .sort-icon {
            opacity: 1;
            color: #3b82f6;
        }

        .favorite-star {
            cursor: pointer;
            color: #d1d5db;
            transition: color 0.2s, transform 0.2s;
        }

        .favorite-star.is-favorite {
            color: #f59e0b;
        }

        .favorite-star:hover {
            transform: scale(1.2);
        }

        .team-green {
            color: #10b981;
            font-weight: 600;
        }

        .team-yellow {
            color: #f59e0b;
            font-weight: 600;
        }

        .team-red {
            color: #ef4444;
            font-weight: 600;
        }

        .team-gray {
            color: #9ca3af;
            font-weight: 500;
        }

        .team-black {
            color: #374151;
        }

        .score-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: bold;
        }

        .ht-badge-high {
            background-color: #10b981;
            color: white;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .ht-badge-medium {
            background-color: #f59e0b;
            color: white;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .ht-badge-low {
            background-color: #9ca3af;
            color: white;
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .ht-badge-none {
            color: #d1d5db;
            font-size: 0.7rem;
        }
    </style>
</head>

<body class="h-full text-gray-800">
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center max-w-md px-4">
            <div id="loading-spinner" class="text-white text-xl font-semibold animate-pulse mb-2">Inizializzazione...
            </div>
            <div id="auth-status"
                class="text-blue-200 text-sm font-mono bg-gray-800 p-2 rounded border border-gray-700">Attesa
                connessione...</div>
            <button id="retry-auth-btn"
                class="hidden mt-4 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Riprova</button>
        </div>
    </div>

    <div class="min-h-full flex flex-col">
        <!-- Header -->
        <header class="bg-white shadow-sm">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center py-4">
                    <div class="flex items-center">
                        <img src="logo.png" alt="Tipster-AI Logo" class="h-10 w-10 mr-3 rounded-lg">
                        <h1 class="text-xl font-bold text-gray-900">Tipster-AI Admin</h1>
                    </div>
                    <nav class="flex flex-wrap gap-2">
                        <button data-page="page-dashboard"
                            class="nav-button bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold shadow-sm hover:bg-blue-700 transition-colors text-sm">
                            <i class="fa-solid fa-chart-bar mr-1"></i>Dashboard
                        </button>

                        <!-- NEW TABS -->
                        <button data-page="page-inserisci"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-file-import mr-1"></i>Inserisci Partite
                        </button>
                        <button data-page="page-pronostici"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-trophy mr-1"></i>Pronostici
                        </button>
                        <button data-page="page-test"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-flask mr-1"></i>Test Strategie
                        </button>

                        <button data-page="page-gestione-db"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-database mr-1"></i>Gestione DB
                        </button>

                        <!-- OLD TABS (HIDDEN - for compatibility) -->
                        <button data-page="page-oggi" style="display:none"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-calendar-day mr-1"></i>Oggi
                        </button>
                        <button data-page="page-risultati" style="display:none"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-check-circle mr-1"></i>Risultati
                        </button>
                        <button data-page="page-ranking" style="display:none"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-trophy mr-1"></i>Ranking
                        </button>
                        <button data-page="page-storico" style="display:none"
                            class="nav-button bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-semibold hover:bg-gray-300 transition-colors text-sm">
                            <i class="fa-solid fa-clock-rotate-left mr-1"></i>Storico
                        </button>
                    </nav>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-grow">

            <!-- PAGINA DASHBOARD -->
            <div id="page-dashboard" class="page active max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Sticky Stats -->
                <div id="stats-container"
                    class="sticky top-0 z-10 bg-gray-50/80 backdrop-blur-sm py-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-8">
                </div>

                <!-- Filters -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-8">
                    <div class="flex flex-col md:flex-row gap-4 mb-4 items-center">
                        <div class="relative w-full md:w-64 hidden"> <!-- Search moved below -->
                            <input type="text" id="search-input-hidden" placeholder="Cerca lega o squadra..."
                                class="w-full pl-10 pr-4 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                            <i
                                class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                        </div>
                        <div class="flex items-center gap-2 w-full md:w-auto">
                            <label class="text-sm font-medium text-gray-700">Periodo:</label>
                            <input type="date" id="filter-date-start" class="p-2 border rounded-lg">
                            <input type="date" id="filter-date-end" class="p-2 border rounded-lg">
                            <button id="show-no-result-btn"
                                class="bg-orange-500 text-white px-3 py-2 rounded-lg font-semibold text-sm hover:bg-orange-600 transition shadow-sm ml-2"
                                title="Mostra solo partite senza risultato">
                                <i class="fa-solid fa-filter mr-1"></i> Senza Risultato
                            </button>
                        </div>
                    </div>

                    <!-- STRATEGY BUILDER & CLIENT MANAGEMENT -->
                    <div class="bg-white p-6 rounded-xl shadow-md border border-gray-200 mb-8">
                        <div class="flex items-center gap-2 mb-4">
                            <i class="fa-solid fa-wand-magic-sparkles text-purple-600 text-xl"></i>
                            <h3 class="text-lg font-bold text-gray-800">Gestione Strategie & Filtri</h3>
                        </div>
                        <p class="text-sm text-gray-500 mb-6">Crea, testa e pubblica le strategie per il Client.</p>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            <!-- COL 1: LOCAL TEST -->
                            <div class="bg-gray-50 p-4 rounded-xl border border-gray-200">
                                <h4 class="font-bold text-gray-700 mb-3 flex items-center gap-2">
                                    <i class="fa-solid fa-flask text-blue-500"></i> Test Locale (Admin)
                                </h4>
                                <div class="space-y-3">
                                    <div>
                                        <label class="block text-xs font-medium text-gray-500 mb-1">Strategie Salvate
                                            (Locale)</label>
                                        <div class="flex gap-2">
                                            <select id="saved-strategies-select"
                                                class="flex-grow p-2 border rounded text-sm bg-white">
                                                <option value="">Seleziona...</option>
                                            </select>
                                            <button id="load-filter-btn"
                                                class="bg-blue-600 text-white px-3 py-2 rounded hover:bg-blue-700"
                                                title="Carica Filtri">
                                                <i class="fa-solid fa-upload"></i>
                                            </button>
                                            <button id="delete-filter-btn"
                                                class="bg-red-500 text-white px-3 py-2 rounded hover:bg-red-600"
                                                title="Elimina">
                                                <i class="fa-solid fa-trash"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="text-xs text-gray-400 mt-2">
                                        <i class="fa-solid fa-info-circle mr-1"></i> Queste strategie sono visibili solo
                                        a te per testare i filtri.
                                    </div>
                                    <!-- Reset & Export moved here -->
                                    <div class="flex gap-2 mt-4">
                                        <button id="reset-filters-btn"
                                            class="bg-gray-500 text-white px-3 py-2 rounded text-sm hover:bg-gray-600 flex-1">
                                            <i class="fa-solid fa-arrows-rotate mr-1"></i>Reset
                                        </button>
                                        <button id="export-filtered-btn"
                                            class="bg-blue-600 text-white px-3 py-2 rounded text-sm hover:bg-blue-700 flex-1">
                                            <i class="fa-solid fa-file-csv mr-1"></i>Export CSV
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- COL 2: CLIENT MANAGEMENT -->
                            <div class="bg-yellow-50 p-4 rounded-xl border border-yellow-200">
                                <h4 class="font-bold text-gray-700 mb-3 flex items-center gap-2">
                                    <i class="fa-solid fa-users text-green-600"></i> Gestione Client (Pubblico)
                                </h4>
                                <div class="space-y-4">
                                    <!-- Select Client Filter -->
                                    <div>
                                        <label class="block text-xs font-medium text-gray-500 mb-1">Filtri Attivi su
                                            Client</label>
                                        <div class="flex gap-2">
                                            <select id="client-filters-select"
                                                class="flex-grow p-2 border rounded text-sm bg-white">
                                                <option value="">Caricamento...</option>
                                            </select>
                                            <button id="delete-client-filter-btn"
                                                class="bg-red-500 text-white px-3 py-2 rounded hover:bg-red-600"
                                                title="Elimina dal Client">
                                                <i class="fa-solid fa-trash"></i>
                                            </button>
                                            <button id="update-client-filter-btn"
                                                class="bg-blue-600 text-white px-3 py-2 rounded hover:bg-blue-700"
                                                title="Aggiorna Modifiche">
                                                <i class="fa-solid fa-save"></i>
                                            </button>
                                        </div>
                                    </div>

                                    <hr class="border-yellow-200">

                                    <!-- Save New Strategy -->
                                    <div>
                                        <label class="block text-xs font-medium text-gray-500 mb-1">Pubblica Nuova
                                            Strategia</label>
                                        <div class="flex gap-2">
                                            <input type="text" id="new-strategy-name"
                                                placeholder="Nome (es. Over 2.5 Safe)..."
                                                class="flex-grow p-2 border rounded text-sm">
                                            <button id="save-filter-btn"
                                                class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 font-bold shadow-sm whitespace-nowrap">
                                                <i class="fa-solid fa-cloud-arrow-up mr-2"></i>Pubblica
                                            </button>
                                        </div>
                                        <div class="text-xs text-gray-500 mt-1">
                                            Salva i filtri attuali (sotto) come strategia pubblica.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <!-- LEFT COLUMN: Leagues -->
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <label class="block text-sm font-medium text-gray-700">Leghe</label>
                                <div>
                                    <button id="update-favorites-btn"
                                        class="text-xs text-green-600 hover:underline font-semibold mr-4">Aggiorna
                                        Preferiti</button>
                                    <button id="reset-leagues-btn"
                                        class="text-xs text-blue-600 hover:underline font-semibold">Azzera
                                        Leghe</button>
                                </div>
                            </div>
                            <div id="league-filters-grid" class="grid grid-cols-1 sm:grid-cols-2 gap-2"></div>
                        </div>

                        <!-- RIGHT COLUMN: Sliders & Tips -->
                        <div class="space-y-4">
                            <!-- Probabilit√† Slider + Inputs -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Probabilit√† (%)</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="prob-min-input" min="0" max="100" value="0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                    <div class="flex-1">
                                        <div id="probability-slider" class="mx-2"></div>
                                    </div>
                                    <input type="number" id="prob-max-input" min="0" max="100" value="100"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                </div>
                            </div>

                            <!-- Quota Slider + Inputs -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Quota</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="odds-min-input" min="1.0" max="10.0" step="0.01"
                                        value="1.0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                    <div class="flex-1">
                                        <div id="odds-slider" class="mx-2"></div>
                                    </div>
                                    <input type="number" id="odds-max-input" min="1.0" max="10.0" step="0.01"
                                        value="10.0"
                                        class="w-20 p-2 border rounded-lg text-sm text-center font-semibold">
                                </div>
                            </div>

                            <!-- Tips -->
                            <div class="pt-2">
                                <div class="flex justify-between items-center mb-1">
                                    <label class="block text-sm font-medium text-gray-700">Tips</label>
                                    <button id="reset-tips-btn"
                                        class="text-xs text-blue-600 hover:underline font-semibold">Azzera Tips</button>
                                </div>
                                <div id="tip-filters-container"
                                    class="w-full p-2 border rounded-lg bg-gray-50 flex flex-wrap gap-2"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Match List -->
                <div id="match-list-container" class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <!-- Search Bar Row -->
                    <div class="mb-4">
                        <div class="relative w-full">
                            <input type="text" id="search-input" placeholder="üîç Cerca lega, squadra o tip..."
                                class="w-full pl-10 pr-4 py-2 border-2 border-blue-100 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-blue-50/30">
                            <i
                                class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-blue-400"></i>
                        </div>
                    </div>

                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">Partite filtrate (<span id="filtered-count">0</span>)</h3>

                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-gray-700 whitespace-nowrap">Ordina per:</label>
                            <select id="dashboard-sort-select" class="p-2 border rounded-lg text-sm">
                                <option value="data-desc">üìÖ Data (recente)</option>
                                <option value="orario-asc">‚è∞ Orario (cronologico)</option>
                                <option value="lega">Lega</option>
                                <option value="quota">Quota</option>
                            </select>
                        </div>
                    </div>
                    <div class="max-h-[60vh] overflow-y-auto custom-scrollbar">
                        <table class="w-full text-sm text-left">
                            <thead class="bg-gray-100 text-xs uppercase sticky top-0">
                                <tr>
                                    <th class="p-3 font-semibold sortable-header" data-sort="data">Data <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="lega">Lega <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="partita">Partita <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header" data-sort="tip">Tip <i
                                            class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center">Ris.</th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="probabilita">
                                        Prob. <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="quota">
                                        Quota <i class="fa-solid fa-sort sort-icon"></i></th>
                                    <th class="p-3 font-semibold text-center" title="Over 0.5 HT - Info primo tempo">HT
                                    </th>
                                    <th class="p-3 font-semibold sortable-header text-center" data-sort="esito">
                                        Esito <i class="fa-solid fa-sort sort-icon"></i></th>
                                </tr>
                            </thead>
                            <tbody id="match-list-body" class="divide-y"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- PAGINA INSERISCI PARTITE (New Unified Interface) -->
            <div id="page-inserisci" class="page max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-8">

                <!-- Header -->
                <div class="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-6 rounded-2xl shadow-lg mb-8">
                    <h1 class="text-3xl font-bold flex items-center gap-3">
                        <i class="fa-solid fa-file-import"></i>
                        Inserisci Partite
                    </h1>
                    <p class="text-blue-100 mt-2">Carica tips e risultati per il giorno selezionato</p>
                </div>

                <!-- Quick Navigation -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <button onclick="document.querySelector('[data-page=page-oggi]').click()"
                        class="bg-blue-500 hover:bg-blue-600 text-white p-6 rounded-xl shadow-lg transition-all transform hover:scale-105">
                        <i class="fa-solid fa-calendar-plus text-4xl mb-3"></i>
                        <h3 class="text-xl font-bold mb-2">üì• Carica Tips</h3>
                        <p class="text-blue-100 text-sm">Carica pronostici per una data specifica</p>
                    </button>

                    <button onclick="document.querySelector('[data-page=page-risultati]').click()"
                        class="bg-green-500 hover:bg-green-600 text-white p-6 rounded-xl shadow-lg transition-all transform hover:scale-105">
                        <i class="fa-solid fa-check-circle text-4xl mb-3"></i>
                        <h3 class="text-xl font-bold mb-2">‚úÖ Aggiorna Risultati</h3>
                        <p class="text-green-100 text-sm">Inserisci risultati delle partite giocate</p>
                    </button>
                </div>

                <!-- Info -->
                <div class="bg-white p-6 rounded-xl shadow-md border border-gray-200">
                    <div class="flex items-start gap-4">
                        <i class="fa-solid fa-circle-info text-blue-500 text-2xl mt-1"></i>
                        <div>
                            <h3 class="font-bold text-lg mb-2">Come funziona</h3>
                            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                                <li><strong>Carica Tips:</strong> Upload CSV con pronostici (prima dei match)</li>
                                <li><strong>Aggiungi HT (opzionale):</strong> Dati Over 0.5 HT per boost ranking</li>
                                <li><strong>Aggiorna Risultati:</strong> Dopo i match, upload CSV risultati</li>
                                <li><strong>Calcola esiti automatici:</strong> Il sistema determina Vinto/Perso</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>

            <!-- PAGINA OGGI (Old - Keep for compatibility) -->
            <div id="page-oggi" class="page max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4 border-b pb-2">üì• Carica Tips del Giorno</h2>

                    <!-- Info ordine caricamento -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 text-sm">
                        <i class="fa-solid fa-circle-info text-blue-500 mr-2"></i>
                        <strong>Ordine libero:</strong> Puoi caricare prima Tips e poi HT, o viceversa. Il sistema
                        far√†
                        il merge automaticamente.
                    </div>

                    <div class="space-y-6">
                        <div>
                            <label for="tips-date" class="block text-sm font-medium text-gray-700 mb-1">Data
                                Partite</label>
                            <input type="date" id="tips-date"
                                class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>

                        <!-- STEP 1: Tips principale -->
                        <div class="border-2 border-blue-200 rounded-lg p-4 bg-blue-50/30">
                            <label for="tips-csv-file" class="block text-sm font-medium text-gray-700 mb-1">
                                <span class="bg-blue-600 text-white text-xs px-2 py-1 rounded mr-2">TIPS</span>
                                File CSV Tips (senza risultati)
                            </label>
                            <input type="file" id="tips-csv-file" accept=".csv"
                                class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                            <div id="tips-file-status" class="mt-2 text-xs text-gray-500 hidden">
                                <i class="fa-solid fa-check-circle text-green-500 mr-1"></i>
                                <span id="tips-file-name"></span>
                            </div>
                        </div>

                        <!-- STEP 2: HT opzionale -->
                        <div class="border-2 border-purple-200 rounded-lg p-4 bg-purple-50/30">
                            <label for="tips-ht-file"
                                class="block text-sm font-medium text-gray-700 mb-1 flex items-center gap-2">
                                <span class="bg-purple-600 text-white text-xs px-2 py-1 rounded mr-2">HT</span>
                                File CSV 0.5 HT (Opzionale - per boost ranking)
                                <span class="text-xs text-gray-500 font-normal cursor-help"
                                    title="Aggiungi dati Over 0.5 HT per timing gol e boost ranking">
                                    <i class="fa-solid fa-circle-info"></i>
                                </span>
                            </label>
                            <input type="file" id="tips-ht-file" accept=".csv"
                                class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100">
                            <div id="ht-file-status" class="mt-2 text-xs text-gray-500 hidden">
                                <i class="fa-solid fa-check-circle text-green-500 mr-1"></i>
                                <span id="ht-file-name"></span> - <span id="ht-match-count"></span> partite con HT
                            </div>
                        </div>

                        <div id="tips-upload-preview" class="hidden bg-gray-50 p-4 rounded-lg border"></div>
                    </div>
                </div>

                <!-- Gestione Giornate Tips -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4">üóëÔ∏è Gestione Giornate Caricate</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="delete-tips-date" class="block text-sm font-medium text-gray-700 mb-1">Seleziona
                                data da cancellare</label>
                            <select id="delete-tips-date" class="w-full p-2 border rounded-lg">
                                <option value="">Seleziona una data...</option>
                            </select>
                        </div>
                        <button id="delete-tips-day-btn"
                            class="w-full bg-red-600 text-white py-2 rounded-lg font-semibold hover:bg-red-700">
                            <i class="fa-solid fa-trash mr-2"></i>Cancella Giornata Selezionata
                        </button>
                        <div id="tips-days-info" class="text-sm text-gray-600"></div>
                    </div>
                </div>
            </div>

            <!-- PAGINA RISULTATI -->
            <div id="page-risultati" class="page max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4 border-b pb-2">‚úÖ Aggiorna Risultati</h2>
                    <div class="space-y-6">
                        <div>
                            <label for="results-date" class="block text-sm font-medium text-gray-700 mb-1">Data
                                Risultati</label>
                            <input type="date" id="results-date"
                                class="w-full p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div>
                            <label for="results-csv-file" class="block text-sm font-medium text-gray-700 mb-1">File
                                CSV
                                Risultati (con risultati finali)</label>
                            <input type="file" id="results-csv-file" accept=".csv"
                                class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100">
                        </div>
                        <div id="results-upload-preview" class="hidden bg-gray-50 p-4 rounded-lg border"></div>
                    </div>
                </div>

                <!-- Gestione Giornate Risultati -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4">üóëÔ∏è Gestione Giornate con Risultati</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="delete-results-date"
                                class="block text-sm font-medium text-gray-700 mb-1">Seleziona data da
                                cancellare</label>
                            <select id="delete-results-date" class="w-full p-2 border rounded-lg">
                                <option value="">Seleziona una data...</option>
                            </select>
                        </div>
                        <button id="delete-results-day-btn"
                            class="w-full bg-red-600 text-white py-2 rounded-lg font-semibold hover:bg-red-700">
                            <i class="fa-solid fa-trash mr-2"></i>Cancella Risultati Giornata Selezionata
                        </button>
                        <div id="results-days-info" class="text-sm text-gray-600"></div>
                    </div>
                </div>
            </div>

            <!-- PAGINA RANKING -->
            <div id="page-ranking" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Filtri Ranking -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4">üèÜ Ranking Partite del Giorno</h2>
                    <p class="text-sm text-gray-600 mb-6">Seleziona un filtro salvato e genera il ranking delle
                        migliori
                        partite</p>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <!-- Prima riga -->
                        <div>
                            <label class="block text-sm font-medium mb-1">Data Partite</label>
                            <input type="date" id="ranking-date" class="w-full p-3 border rounded-lg">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1">Filtro Strategia</label>
                            <select id="ranking-filter-select" class="w-full p-3 border rounded-lg bg-white">
                                <option value="">Nessun filtro (tutte le partite)</option>
                            </select>
                        </div>
                    </div>

                    <div class="mb-6">
                        <label class="block text-sm font-medium mb-1">Max Partite da Mostrare</label>
                        <input type="number" id="ranking-max-matches" value="20" min="1" max="50"
                            class="w-full p-3 border rounded-lg">
                        <p class="text-xs text-gray-500 mt-1">Numero massimo di partite per ogni tip nel ranking</p>
                    </div>

                    <button id="generate-ranking-btn"
                        class="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-3 rounded-lg font-bold hover:opacity-90">
                        <i class="fa-solid fa-magic mr-2"></i>Applica e Genera Ranking
                    </button>
                </div>

                <!-- Toggle Visualizzazione v3.5.3 -->
                <div id="ranking-view-toggle" class="mb-4 hidden">
                    <div class="bg-white p-4 rounded-lg shadow border border-gray-200">
                        <div class="flex items-center space-x-2">
                            <button id="view-by-tip-btn"
                                class="flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white">
                                <i class="fa-solid fa-chart-bar mr-2"></i>Per Tip e Ranking
                            </button>
                            <button id="view-by-time-btn"
                                class="flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300">
                                <i class="fa-solid fa-clock mr-2"></i>Per Orario
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Risultati Ranking -->
                <div id="ranking-results"></div>
            </div>

            <!-- PAGINA STORICO PREVISIONI -->
            <div id="page-storico" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Strategy Management Header -->
                <div class="bg-white p-6 rounded-xl shadow-sm border border-gray-100 mb-8">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold text-gray-800 flex items-center">
                            <i class="fa-solid fa-wand-magic-sparkles text-purple-600 mr-2"></i>
                            Gestione Strategie
                        </h2>
                        <button id="recalc-strategies-btn"
                            class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 transition shadow-md flex items-center text-sm">
                            <i class="fa-solid fa-rotate mr-2"></i> Ricalcola Data Selezionata
                        </button>
                    </div>
                </div>
                <!-- Selezione Data -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200 mb-6">
                    <h2 class="text-2xl font-bold mb-4">
                        <i class="fa-solid fa-clock-rotate-left text-purple-600 mr-2"></i>
                        Storico Previsioni
                    </h2>
                    <p class="text-sm text-gray-600 mb-6">Visualizza le previsioni salvate e verifica i risultati
                    </p>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                        <div>
                            <label class="block text-sm font-medium mb-1">Data Previsioni</label>
                            <input type="date" id="storico-date" class="w-full p-3 border rounded-lg">
                        </div>
                        <div>
                            <button id="load-storico-btn"
                                class="w-full bg-purple-600 text-white py-3 rounded-lg font-bold hover:bg-purple-700">
                                <i class="fa-solid fa-search mr-2"></i>Cerca Previsioni
                            </button>
                        </div>
                        <div>
                            <button id="load-all-storico-btn"
                                class="w-full bg-gray-600 text-white py-3 rounded-lg font-bold hover:bg-gray-700">
                                <i class="fa-solid fa-list mr-2"></i>Ultime 10 Giornate
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Lista Strategie per Data -->
                <div id="storico-strategie-list" class="hidden">
                    <div class="bg-gradient-to-r from-purple-500 to-indigo-600 text-white p-4 rounded-t-xl">
                        <h3 class="text-xl font-bold" id="storico-date-title">Strategie del --</h3>
                        <p class="text-sm opacity-90" id="storico-count">-- strategie salvate</p>
                    </div>
                    <div id="storico-strategie-container"
                        class="bg-white rounded-b-xl shadow-md border border-gray-200 p-4">
                        <!-- Strategie caricate dinamicamente -->
                    </div>
                </div>

                <!-- Dettaglio Strategia Selezionata -->
                <div id="storico-dettaglio" class="hidden mt-6">
                    <!-- Dettaglio caricato dinamicamente -->
                </div>

                <!-- Stats Globali -->
                <div id="storico-stats-globali" class="hidden mt-6">
                    <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                        <h3 class="text-xl font-bold mb-4">üìä Statistiche Globali</h3>
                        <div id="storico-stats-content" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <!-- Stats caricate dinamicamente -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- PAGINA PRONOSTICI (Unified with single date selector) -->
            <div id="page-pronostici" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                <!-- Header with unified controls -->
                <div class="bg-gradient-to-r from-purple-600 to-blue-600 text-white p-6 rounded-2xl shadow-lg mb-8">
                    <h1 class="text-3xl font-bold flex items-center gap-3 mb-6">
                        <i class="fa-solid fa-trophy"></i>
                        Pronostici
                    </h1>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <!-- Date Selector -->
                        <div>
                            <label class="block text-sm font-medium mb-2 opacity-90">Seleziona Data</label>
                            <input type="date" id="pronostici-unified-date"
                                class="w-full p-3 border rounded-lg text-gray-900 font-semibold">
                        </div>

                        <!-- Button 1: Carica Previsioni (calcola + visualizza) -->
                        <div class="flex items-end">
                            <button id="pronostici-load-btn"
                                class="w-full bg-white text-purple-700 px-6 py-3 rounded-lg font-bold transition hover:bg-purple-50 shadow-lg flex items-center justify-center gap-2">
                                <i class="fa-solid fa-calculator"></i>
                                Carica Previsioni
                            </button>
                        </div>

                        <!-- Button 2: Storico Strategie -->
                        <div class="flex items-end">
                            <button id="pronostici-history-btn"
                                class="w-full bg-white/20 hover:bg-white/30 text-white px-6 py-3 rounded-lg font-bold transition shadow-lg flex items-center justify-center gap-2">
                                <i class="fa-solid fa-calendar-days"></i>
                                Storico Strategie
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Ranking Section -->
                <div id="pronostici-ranking-section" class="hidden">
                    <div
                        class="bg-gradient-to-br from-purple-50 to-blue-50 p-6 rounded-2xl shadow-md border-2 border-purple-200 mb-6">
                        <h2 class="text-2xl font-bold mb-4 flex items-center gap-2">
                            <i class="fa-solid fa-chart-line text-purple-600"></i>
                            üìä Ranking Salvati
                        </h2>

                        <!-- Lista Strategie del Giorno -->
                        <div id="ranking-strategies-list" class="hidden">
                            <h3 class="text-lg font-bold mb-3 text-gray-800">Strategie Disponibili:</h3>
                            <div id="ranking-strategies-grid"
                                class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 mb-4">
                                <!-- Populated dynamically -->
                            </div>
                        </div>

                        <!-- Dettaglio Partite della Strategia Selezionata -->
                        <div id="ranking-matches-detail" class="hidden">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-bold text-gray-800" id="ranking-strategy-name"></h3>
                                <button id="ranking-back-btn"
                                    class="text-sm text-gray-600 hover:text-gray-800 underline">
                                    <i class="fa-solid fa-arrow-left mr-1"></i>Torna alle strategie
                                </button>
                            </div>
                            <div id="ranking-matches-container" class="space-y-3">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Storico Section -->
                <div id="pronostici-storico-section" class="hidden">
                    <!-- Lista Strategie per Data -->
                    <div id="pronostici-storico-list" class="mb-6">
                        <div class="bg-gradient-to-r from-purple-500 to-indigo-600 text-white p-4 rounded-t-xl">
                            <h3 class="text-xl font-bold" id="pronostici-storico-title">Strategie del --</h3>
                            <p class="text-sm opacity-90" id="pronostici-storico-count">-- strategie salvate</p>
                        </div>
                        <div id="pronostici-storico-container"
                            class="bg-white rounded-b-xl shadow-md border border-gray-200 p-4">
                            <!-- Strategie caricate dinamicamente -->
                        </div>
                    </div>

                    <!-- Dettaglio Strategia Selezionata -->
                    <div id="storico-dettaglio" class="hidden mt-6">
                        <!-- Dettaglio caricato dinamicamente -->
                    </div>

                    <!-- Stats Globali -->
                    <div id="storico-stats-globali" class="hidden mt-6">
                        <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                            <h3 class="text-xl font-bold mb-4">üìä Statistiche Globali</h3>
                            <div id="storico-stats-content" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                                <!-- Stats caricate dinamicamente -->
                            </div>
                        </div>
                    </div>
                </div>

            </div>
    </div>

    <!-- PAGINA TEST STRATEGIE (Placeholder) -->
    <div id="page-test" class="page max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div class="bg-gradient-to-r from-orange-600 to-red-600 text-white p-6 rounded-2xl shadow-lg mb-8">
            <h1 class="text-3xl font-bold flex items-center gap-3">
                <i class="fa-solid fa-flask"></i>
                Test Strategie
            </h1>
            <p class="text-orange-100 mt-2">‚ö†Ô∏è Modalit√† Test - I dati non verranno salvati su Firebase</p>
        </div>

        <div class="bg-yellow-50 border-2 border-yellow-400 rounded-xl p-6 text-center">
            <i class="fa-solid fa-triangle-exclamation text-yellow-600 text-5xl mb-4"></i>
            <h2 class="text-2xl font-bold text-gray-800 mb-3">In Sviluppo</h2>
            <p class="text-gray-700 mb-4">
                Questa sezione permetter√† di testare nuove strategie senza salvare su Firebase.
            </p>
            <p class="text-sm text-gray-600">
                Per ora puoi usare <strong>Ranking</strong> per testare configurazioni.
            </p>
        </div>
    </div>

    <!-- PAGINA GESTIONE DB -->
    <div id="page-gestione-db" class="page max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

            <!-- LEFT: Mass Find & Replace -->
            <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                <h2 class="text-xl font-bold mb-4 text-gray-800"><i
                        class="fa-solid fa-tools mr-2 text-blue-600"></i>Trova e Sostituisci Massivo</h2>
                <p class="text-sm text-gray-500 mb-4">Utile per correggere nomi di leghe o squadre in blocco
                    (es. "EU-KOR" -> "AS-KOR").</p>

                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Campo su cui
                            agire</label>
                        <select id="mass-edit-field" class="w-full p-2 border rounded-lg bg-gray-50">
                            <option value="lega">Lega</option>
                            <option value="partita">Partita (Squadre)</option>
                            <option value="tip">Tip</option>
                            <option value="mercato">Mercato</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Trova (Valore
                                errato)</label>
                            <input type="text" id="mass-edit-find" placeholder="es. EU-KOR"
                                class="w-full p-2 border rounded-lg">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Sostituisci con
                                (Nuovo)</label>
                            <input type="text" id="mass-edit-replace" placeholder="es. AS-KOR"
                                class="w-full p-2 border rounded-lg">
                        </div>
                    </div>

                    <button id="mass-edit-preview-btn"
                        class="w-full bg-blue-600 text-white py-2 rounded-lg font-semibold hover:bg-blue-700">
                        <i class="fa-solid fa-magnifying-glass mr-2"></i>Anteprima Modifiche
                    </button>

                    <div id="mass-edit-preview" class="hidden bg-gray-50 p-4 rounded-lg border text-sm">
                    </div>
                </div>
            </div>

            <!-- RIGHT: Backup & Restore -->
            <div class="space-y-6">
                <!-- AI KNOWLEDGE BASE MANAGEMENT -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4 text-gray-800"><i
                            class="fa-solid fa-brain mr-2 text-purple-600"></i>Gestione Conoscenza AI</h2>
                    <p class="text-sm text-gray-500 mb-4">Carica le definizioni statiche delle strategie (es.
                        quali leghe sono in "Top EU") per l'AI.</p>

                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Seleziona
                                Strategia</label>
                            <select id="ai-strat-id" class="w-full p-2 border rounded-lg bg-white">
                                <option value="">Scegli strategia...</option>
                                <optgroup label="Preset di Sistema">
                                    <option value="top_eu">Top EU (Premier, Liga, ecc.)</option>
                                    <option value="winrate_80">Winrate 80%</option>
                                    <option value="italia">Campionati Italiani</option>
                                    <option value="cups">Coppe Europee</option>
                                    <option value="best_05_ht">Over 0.5 HT Best</option>
                                </optgroup>
                                <optgroup label="Strategie Personalizzate" id="ai-custom-strats-group">
                                    <!-- Populated dynamically -->
                                </optgroup>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Descrizione AI</label>
                            <textarea id="ai-strat-desc" placeholder="Descrizione per l'AI..."
                                class="w-full p-2 border rounded-lg" rows="2"></textarea>
                        </div>
                        <div class="border-2 border-purple-200 rounded-lg p-4 bg-purple-50/30">
                            <label class="block text-sm font-medium text-gray-700 mb-1">
                                File CSV (per estrarre leghe)
                            </label>
                            <input type="file" id="ai-csv-file" accept=".csv"
                                class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100">
                        </div>

                        <button id="upload-ai-knowledge-btn"
                            class="w-full bg-purple-600 text-white py-2 rounded-lg font-semibold hover:bg-purple-700">
                            <i class="fa-solid fa-cloud-upload-alt mr-2"></i>Carica su Firebase
                        </button>
                        <div id="ai-upload-status" class="text-sm text-gray-600 hidden"></div>
                    </div>
                </div>
                <!-- Backup Upload (Moved) -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4 text-gray-800"><i
                            class="fa-solid fa-cloud-upload-alt mr-2 text-orange-600"></i>Ripristino /
                        Aggiornamento</h2>
                    <div class="border-2 border-orange-200 rounded-lg p-4 bg-orange-50/30">
                        <label for="backup-csv-file" class="block text-sm font-medium text-gray-700 mb-1">
                            <span class="bg-orange-600 text-white text-xs px-2 py-1 rounded mr-2">BACKUP</span>
                            File CSV Backup / Totale
                        </label>
                        <input type="file" id="backup-csv-file" accept=".csv"
                            class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-50 file:text-orange-700 hover:file:bg-orange-100">
                        <div id="backup-file-status" class="mt-2 text-xs text-gray-500 hidden">
                            <i class="fa-solid fa-check-circle text-green-500 mr-1"></i>
                            <span id="backup-file-name"></span>
                        </div>
                    </div>
                    <div id="backup-upload-preview" class="hidden bg-gray-50 p-4 rounded-lg border mt-4">
                    </div>


                </div>

                <!-- Export (Moved Logic) -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4 text-gray-800"><i
                            class="fa-solid fa-download mr-2 text-green-600"></i>Backup Database</h2>
                    <p class="text-sm text-gray-500 mb-4">Scarica tutto il database corrente in CSV (inclusi
                        ID).</p>
                    <button id="export-full-db-btn"
                        class="w-full bg-green-600 text-white py-2 rounded-lg font-semibold hover:bg-green-700">
                        <i class="fa-solid fa-file-csv mr-2"></i>Scarica Backup Completo
                    </button>
                </div>

                <!-- Export Storico Partite (NEW) -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4 text-gray-800">
                        <i class="fa-solid fa-file-export mr-2 text-blue-600"></i>Export Storico Partite (CSV)
                    </h2>
                    <p class="text-sm text-gray-500 mb-4">Esporta le partite storiche con risultati e
                        statistiche complete.</p>

                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Data Inizio</label>
                            <input type="date" id="export-start-date" class="w-full p-2 border rounded-lg bg-gray-50">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Data Fine</label>
                            <input type="date" id="export-end-date" class="w-full p-2 border rounded-lg bg-gray-50">
                        </div>
                    </div>

                    <div class="mb-4">
                        <label class="flex items-center gap-2 text-sm">
                            <input type="checkbox" id="export-only-results" checked
                                class="form-checkbox rounded text-blue-600">
                            <span>Solo partite con risultato</span>
                        </label>
                    </div>

                    <button id="export-storico-btn"
                        class="w-full bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700 transition-colors">
                        <i class="fa-solid fa-download mr-2"></i>Scarica CSV Storico
                    </button>
                </div>

                <!-- Bulk Recalculate Esito (NEW) -->
                <div class="bg-white p-6 rounded-2xl shadow-md border border-gray-200">
                    <h2 class="text-xl font-bold mb-4 text-gray-800">
                        <i class="fa-solid fa-calculator mr-2 text-yellow-600"></i>Ricalcola Esiti
                    </h2>
                    <p class="text-sm text-gray-500 mb-4">Ricalcola automaticamente gli esiti (Vinto/Perso) per
                        tutte le partite che hanno un risultato ma mancano di esito.</p>

                    <button id="bulk-recalculate-esito-btn"
                        class="w-full bg-yellow-600 text-white py-3 rounded-lg font-bold hover:bg-yellow-700 transition-colors">
                        <i class="fa-solid fa-rotate mr-2"></i>Ricalcola Tutti gli Esiti
                    </button>
                    <div id="recalc-status" class="hidden mt-3 text-sm"></div>
                </div>
            </div>
        </div>

        <!-- Quick Search & Edit Table -->
        <div class="mt-8 bg-white p-6 rounded-2xl shadow-md border border-gray-200">
            <h2 class="text-xl font-bold mb-4 text-gray-800"><i
                    class="fa-solid fa-search mr-2 text-purple-600"></i>Ricerca e Modifica Rapida DB</h2>
            <div class="mb-4">
                <input type="text" id="quick-db-search" placeholder="Cerca qualsiasi cosa nel DB..."
                    class="w-full p-3 border-2 border-purple-100 rounded-lg focus:ring-2 focus:ring-purple-500">
            </div>
            <div class="max-h-[500px] overflow-y-auto custom-scrollbar">
                <table class="w-full text-sm text-left">
                    <thead class="text-xs text-gray-700 uppercase bg-gray-50 sticky top-0">
                        <tr>
                            <th class="px-4 py-3">Data</th>
                            <th class="px-4 py-3">Lega</th>
                            <th class="px-4 py-3">Partita</th>
                            <th class="px-4 py-3">Tip</th>
                            <th class="px-4 py-3 text-center">Risultato</th>
                            <th class="px-4 py-3 text-center">Azioni</th>
                        </tr>
                    </thead>
                    <tbody id="quick-db-results">
                        <tr>
                            <td colspan="6" class="p-4 text-center text-gray-500">Usa la barra di ricerca
                                per trovare record...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    </main>
    </div>

    <!-- Modal -->
    <div id="modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-2xl p-6 max-w-md mx-4">
            <h3 id="modal-title" class="text-xl font-bold mb-4"></h3>
            <p id="modal-message" class="mb-6"></p>
            <div class="flex justify-end space-x-4">
                <button id="modal-cancel" class="bg-gray-200 px-4 py-2 rounded-lg font-semibold">Annulla</button>
                <button id="modal-confirm"
                    class="bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold">Conferma</button>
            </div>
        </div>
    </div>

    <script src="secrets.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, collection, getDocs, writeBatch, query, where, doc, addDoc, deleteDoc, setDoc, getDoc, updateDoc, orderBy, limit } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";

        // ==================== CONFIGURAZIONE FIREBASE CORRETTA ====================
        // ==================== CONFIGURAZIONE FIREBASE CORRETTA ====================
        // Config loaded from secrets.js (window.firebaseConfig)
        const firebaseConfig = window.firebaseConfig;

        let db;
        let auth;

        try {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (error) {
            console.error("Critical Firebase Init Error:", error);
            document.getElementById('auth-status').textContent = "Errore critico inizializzazione.";
            document.getElementById('auth-status').classList.add('text-red-400');
        }

        // ==================== GLOBAL STATE ====================
        let allMatches = [];
        window.allMatches = allMatches; // Expose to window for global access
        let dataToUpload = [];
        let filteredMatches = [];
        let savedFilters = [];
        let editingMatchId = null; // Track currently editing match
        let favoriteLeagues = [];
        let stagedFavoriteLeagues = [];
        let sortState = { column: 'data', direction: 'desc' };
        let lastGeneratedRanking = null;

        // HT MERGE STATE
        let rawMainData = [];
        let rawHtData = [];

        // API FOOTBALL CONFIG
        const API_FOOTBALL_KEY = '62706d306e456ad02769b5bf985b8973';
        const API_FOOTBALL_URL = 'https://v3.api-football.com';

        // MATCH TIMES CACHE (Firebase - condiviso tutti utenti, 24h)
        const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 ore

        // Salva orario in Firebase cache temporanea
        async function saveTimeToCache(date, partita, ora) {
            if (!ora || ora.trim() === '') return;

            try {
                const key = `${date}_${partita.replace(/[^a-zA-Z0-9]/g, '_')}`;
                await setDoc(doc(db, "match_times_temp", key), {
                    data: date,
                    partita: partita,
                    ora: ora,
                    timestamp: Date.now()
                });
            } catch (e) {
                console.error('[CACHE] Error saving time:', e);
            }
        }

        // Ottieni orario da Firebase cache
        async function getTimeFromCache(date, partita) {
            try {
                const key = `${date}_${partita.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const docSnap = await getDoc(doc(db, "match_times_temp", key));

                if (!docSnap.exists()) return null;

                const data = docSnap.data();

                // Check se >24h
                if (Date.now() - data.timestamp > CACHE_DURATION) {
                    // Expired, cancella
                    await deleteDoc(doc(db, "match_times_temp", key));
                    return null;
                }

                return data.ora;
            } catch (e) {
                console.error('[CACHE] Error getting time:', e);
                return null;
            }
        }

        // Cleanup automatico cache >24h (batch)
        async function cleanupExpiredTimes() {
            try {
                const q = query(collection(db, "match_times_temp"));
                const snapshot = await getDocs(q);

                const batch = writeBatch(db);
                let cleanedCount = 0;
                const now = Date.now();

                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (now - data.timestamp > CACHE_DURATION) {
                        batch.delete(doc.ref);
                        cleanedCount++;
                    }
                });

                if (cleanedCount > 0) {
                    await batch.commit();
                    console.log(`[CACHE] Cleaned ${cleanedCount} expired times (>24h)`);
                }
            } catch (e) {
                console.error('[CACHE] Cleanup error:', e);
            }
        }

        // Stats cache
        async function getCacheStats() {
            try {
                const q = query(collection(db, "match_times_temp"));
                const snapshot = await getDocs(q);
                return {
                    total: snapshot.size,
                    items: snapshot.docs.map(d => d.data())
                };
            } catch (e) {
                return { total: 0, items: [] };
            }
        }
        let dailyFixturesCache = null; // Bulk cache giornaliero

        // ==================== FUZZY MATCHING ====================

        // Levenshtein distance
        function levenshteinDistance(a, b) {
            const matrix = [];

            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[b.length][a.length];
        }

        // Fuzzy match team name
        function fuzzyMatchTeam(csvTeam, apiTeams) {
            const csvNorm = csvTeam.toLowerCase().trim();
            let bestMatch = null;
            let bestScore = Infinity;

            for (let apiTeam of apiTeams) {
                const apiNorm = apiTeam.toLowerCase().trim();

                // Match esatto
                if (csvNorm === apiNorm) return apiTeam;

                // Contains
                if (csvNorm.includes(apiNorm) || apiNorm.includes(csvNorm)) {
                    const distance = levenshteinDistance(csvNorm, apiNorm);
                    if (distance < bestScore) {
                        bestScore = distance;
                        bestMatch = apiTeam;
                    }
                }

                // Levenshtein
                const distance = levenshteinDistance(csvNorm, apiNorm);
                if (distance < bestScore) {
                    bestScore = distance;
                    bestMatch = apiTeam;
                }
            }

            // Accetta solo se distance < 5
            return bestScore < 5 ? bestMatch : null;
        }

        // ==================== BULK API FOOTBALL ====================

        // Carica tutte le fixtures del giorno (1 chiamata bulk)
        async function loadDailyFixtures(date) {
            console.log(`[API DEBUG] Loading fixtures for ${date}...`);

            // Check localStorage
            const cacheKey = `fixtures_${date}`;
            const cached = localStorage.getItem(cacheKey);

            if (cached) {
                const data = JSON.parse(cached);
                // Valido per 6 ore
                if (Date.now() - data.timestamp < 6 * 60 * 60 * 1000) {
                    console.log(`[API DEBUG] Using cached fixtures for ${date} (${data.fixtures.length} matches)`);
                    dailyFixturesCache = data.fixtures;
                    return data.fixtures;
                }
            }

            // Fetch da API
            try {
                console.log(`[API DEBUG] Fetching from API-Football...`);
                const url = `${API_FOOTBALL_URL}/fixtures?date=${date}`;
                console.log(`[API DEBUG] URL: ${url}`);

                const response = await fetch(url, {
                    headers: {
                        'x-rapidapi-key': API_FOOTBALL_KEY,
                        'x-rapidapi-host': 'v3.api-football.com'
                    }
                });

                console.log(`[API DEBUG] Response status: ${response.status}`);

                if (!response.ok) {
                    console.error(`[API DEBUG] API error: ${response.status} ${response.statusText}`);
                    return [];
                }

                const data = await response.json();
                apiCallsToday++;

                console.log(`[API DEBUG] Response data:`, data);

                const fixtures = data.response || [];
                console.log(`[API DEBUG] Loaded ${fixtures.length} fixtures (API calls today: ${apiCallsToday})`);

                // Salva in localStorage
                localStorage.setItem(cacheKey, JSON.stringify({
                    fixtures: fixtures,
                    timestamp: Date.now()
                }));

                dailyFixturesCache = fixtures;

                return fixtures;
            } catch (e) {
                console.error('[API DEBUG] Error fetching fixtures:', e);
                return [];
            }
        }

        // Trova fixture matchante con fuzzy matching
        function findMatchingFixture(csvMatch, fixtures) {
            if (!fixtures || fixtures.length === 0) return null;

            const [csvHome, csvAway] = csvMatch.split(' - ').map(t => t.trim());

            // Estrai tutti i nomi team dall'API
            const apiTeams = fixtures.flatMap(f => [
                f.teams.home.name,
                f.teams.away.name
            ]);

            // Fuzzy match
            const homeMatch = fuzzyMatchTeam(csvHome, apiTeams);
            const awayMatch = fuzzyMatchTeam(csvAway, apiTeams);

            if (!homeMatch || !awayMatch) return null;

            // Trova fixture con entrambi i team
            const fixture = fixtures.find(f =>
                f.teams.home.name === homeMatch &&
                f.teams.away.name === awayMatch
            );

            return fixture;
        }

        // Ottieni orario da bulk cache
        function getTimeFromBulkCache(date, match) {
            if (!dailyFixturesCache) return null;

            const fixture = findMatchingFixture(match, dailyFixturesCache);
            if (!fixture || !fixture.fixture || !fixture.fixture.date) return null;

            // Converti UTC a ora italiana
            const utcDate = new Date(fixture.fixture.date);
            const italianTime = new Date(utcDate.getTime() + (1 * 60 * 60 * 1000)); // UTC+1

            const hours = String(italianTime.getHours()).padStart(2, '0');
            const minutes = String(italianTime.getMinutes()).padStart(2, '0');

            return `${hours}:${minutes}`;
        }

        // ODDS CORRELATIONS LOOKUP TABLE - CALIBRATE SU 12,414 MATCH REALI
        // Aggiornato v3.3 con dati storici effettivi
        const ODDS_CORRELATIONS = {
            "+1.5": {
                "+2.5": {
                    // Basato su analisi: Over1.5@1.00-1.15 ‚Üí 63.5% Over2.5 ‚Üí @1.65
                    "1.00-1.15": [1.58, 1.72],
                    "1.10-1.20": [1.60, 1.75],
                    // Over1.5@1.15-1.25 ‚Üí 56.5% Over2.5 ‚Üí @1.86
                    "1.15-1.25": [1.78, 1.95],
                    "1.20-1.30": [1.80, 2.00],
                    // Over1.5@1.25-1.35 ‚Üí 51.6% Over2.5 ‚Üí @2.03
                    "1.25-1.35": [1.95, 2.15],
                    "1.30-1.40": [2.00, 2.20],
                    // Over1.5@1.35-1.50 ‚Üí 42.6% Over2.5 ‚Üí @2.47
                    "1.35-1.50": [2.35, 2.60],
                    "1.40-1.50": [2.40, 2.65]
                },
                "+3.5": {
                    // Basato su: Over1.5@1.00-1.15 ‚Üí 43.1% Over3.5 ‚Üí @2.44
                    "1.00-1.15": [2.30, 2.55],
                    "1.10-1.20": [2.35, 2.60],
                    // Over1.5@1.15-1.25 ‚Üí 34.5% Over3.5 ‚Üí @3.04
                    "1.15-1.25": [2.90, 3.20],
                    "1.20-1.30": [2.95, 3.25],
                    // Over1.5@1.25-1.35 ‚Üí 29.7% Over3.5 ‚Üí @3.54
                    "1.25-1.35": [3.35, 3.75],
                    "1.30-1.40": [3.45, 3.85]
                },
                "-2.5": {
                    "1.10-1.20": [2.50, 3.00],
                    "1.20-1.30": [2.20, 2.70],
                    "1.30-1.40": [2.00, 2.40]
                }
            },
            "+2.5": {
                "+3.5": {
                    "1.10-1.20": [1.50, 1.75],
                    "1.20-1.30": [1.70, 2.00],
                    "1.30-1.40": [1.90, 2.30],
                    "1.40-1.60": [2.10, 2.60]
                },
                "+4.5": {
                    "1.10-1.20": [2.30, 2.80],
                    "1.20-1.30": [2.50, 3.00],
                    "1.30-1.40": [2.70, 3.30]
                },
                "-3.5": {
                    "1.10-1.20": [2.00, 2.40],
                    "1.20-1.30": [1.80, 2.20],
                    "1.30-1.40": [1.60, 2.00]
                }
            }
        };

        // TOP LEGHE PER OVER (dalla nostra analisi)
        const TOP_OVER_LEAGUES = [
            'EU-FIN Kakkonen', 'EU-TUR Turkish Cup', 'EU-SVK Slovakia Cup',
            'EU-NOR Eliteserien', 'EU-NOR Obos-Ligaen', 'EU-FIN Veikkausliiga',
            'EU-NLD Eredivisie', 'EU-Champions League', 'NA-USA Major League Soccer',
            'EU-EST Meistriliiga', 'EU-SWE Ettan: North', 'EU-WAL Premier League',
            'EU-DEU 3. Liga', 'EU-SWE Ettan: South', 'EU-POL 1. Liga'
        ];

        // ==================== UTILS (GLOBAL) ====================
        // ==================== DATE FORMATTING (ITALIAN) ====================
        function formatDateIT(dateString) {
            // Input: "2025-11-27" (YYYY-MM-DD) ‚Üí Output: "27/11/2025" (DD/MM/YYYY)
            if (!dateString) return '';
            const [year, month, day] = dateString.split('-');
            return `${day}/${month}/${year}`;
        }

        function parseDateIT(dateStringIT) {
            // Input: "27/11/2025" (DD/MM/YYYY) ‚Üí Output: "2025-11-27" (YYYY-MM-DD)
            if (!dateStringIT) return '';
            const [day, month, year] = dateStringIT.split('/');
            return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
        }

        function normalizeLega(lega) {
            return lega.replace(/\s+/g, ' ').trim();
        }

        // ==================== GLOBAL STATS VARS ====================
        let tipsFileCount = 0;
        let htFileCount = 0;

        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', async () => {
            const loadingOverlay = document.getElementById('loading-overlay');
            const authStatus = document.getElementById('auth-status');
            const retryBtn = document.getElementById('retry-auth-btn');




            // ==================== MODAL (Global) ====================
            function showModal(title, message, onConfirm = null) {
                document.getElementById('modal-title').textContent = title;
                document.getElementById('modal-message').innerHTML = message;

                const confirmBtn = document.getElementById('modal-confirm');
                const cancelBtn = document.getElementById('modal-cancel');

                // Reset listeners
                const newConfirm = confirmBtn.cloneNode(true);
                const newCancel = cancelBtn.cloneNode(true);
                confirmBtn.parentNode.replaceChild(newConfirm, confirmBtn);
                cancelBtn.parentNode.replaceChild(newCancel, cancelBtn);

                newConfirm.addEventListener('click', () => {
                    document.getElementById('modal').classList.add('hidden');
                    if (onConfirm) onConfirm();
                });

                newCancel.addEventListener('click', () => {
                    document.getElementById('modal').classList.add('hidden');
                });

                if (!onConfirm) {
                    newCancel.classList.add('hidden');
                    newConfirm.textContent = "OK";
                } else {
                    newCancel.classList.remove('hidden');
                    newConfirm.textContent = "Conferma";
                }

                document.getElementById('modal').classList.remove('hidden');
            }

            // --- GESTIONE AUTH ---

            async function authenticate() {
                authStatus.textContent = "Connessione a Firebase...";
                authStatus.className = "text-blue-200 text-sm font-mono bg-gray-800 p-2 rounded border border-gray-700";
                retryBtn.classList.add('hidden');

                try {
                    await setPersistence(auth, browserLocalPersistence);
                    await signInAnonymously(auth);
                    // Non nascondiamo ancora l'overlay, aspettiamo il caricamento dati
                    authStatus.textContent = "Autenticato. Caricamento dati...";
                    authStatus.className = "text-green-400 text-sm font-mono bg-gray-800 p-2 rounded border border-green-700";

                    // Avvia l'app vera e propria
                    await startApp();

                } catch (error) {
                    console.error("Auth Error:", error);
                    let msg = "Errore sconosciuto.";
                    if (error.code === 'auth/api-key-not-valid') {
                        msg = "CHIAVE API NON VALIDA. Controlla il codice HTML.";
                    } else if (error.code === 'auth/operation-not-allowed') {
                        msg = "AUTH ANONIMA NON ABILITATA in Firebase Console.";
                    } else {
                        msg = error.message;
                    }

                    authStatus.innerHTML = `<strong class="text-red-500">ERRORE:</strong><br>${msg}`;
                    authStatus.className = "text-red-300 text-xs font-mono bg-red-900/50 p-2 rounded border border-red-700 text-left break-words";
                    document.getElementById('loading-spinner').textContent = "‚ö†Ô∏è Connessione Fallita";
                    document.getElementById('loading-spinner').classList.remove('animate-pulse');
                    retryBtn.classList.remove('hidden');
                }
            }

            retryBtn.addEventListener('click', authenticate);

            // --- START APP LOGIC ---
            async function startApp() {
                try {
                    await loadAllMatches();
                    await loadFavorites();
                    setupFilters();
                    populateFilters();
                    applyFiltersAndRender();
                    await loadSavedFilters();
                    await loadClientFiltersForAdmin(); // Load Client Filters

                    showPage('page-dashboard');
                    loadingOverlay.classList.add('hidden');
                } catch (e) {
                    console.error("Data Load Error:", e);
                    authStatus.textContent = "Errore caricamento dati Firestore.";
                    authStatus.classList.add('text-red-400');
                }
            } // Close startApp early


            // Avvia flusso auth
            authenticate();

            // UI Elements
            const pages = document.querySelectorAll('.page');
            const navButtons = document.querySelectorAll('.nav-button');
            const filterDateStart = document.getElementById('filter-date-start');
            const filterDateEnd = document.getElementById('filter-date-end');
            const leagueFiltersGrid = document.getElementById('league-filters-grid');
            const tipFiltersContainer = document.getElementById('tip-filters-container');
            const probabilitySliderEl = document.getElementById('probability-slider');
            const oddsSliderEl = document.getElementById('odds-slider');
            const probMinInput = document.getElementById('prob-min-input');
            const probMaxInput = document.getElementById('prob-max-input');
            const oddsMinInput = document.getElementById('odds-min-input');
            const oddsMaxInput = document.getElementById('odds-max-input');
            const searchInput = document.getElementById('search-input');
            const sortableHeaders = document.querySelectorAll('.sortable-header');

            // Sliders Dashboard
            noUiSlider.create(probabilitySliderEl, {
                start: [0, 100],
                connect: true,
                range: { min: 0, max: 100 },
                step: 1,
                tooltips: false
            });

            noUiSlider.create(oddsSliderEl, {
                start: [1.0, 10.0],
                connect: true,
                range: { min: 1.0, max: 10.0 },
                step: 0.01,
                tooltips: false
            });

            // Sincronizzazione SLIDER ‚Üí INPUT (Probabilit√†)
            probabilitySliderEl.noUiSlider.on('update', (values) => {
                probMinInput.value = parseInt(values[0]);
                probMaxInput.value = parseInt(values[1]);
            });

            probabilitySliderEl.noUiSlider.on('set', () => {
                applyFiltersAndRender();
            });

            // Sincronizzazione INPUT ‚Üí SLIDER (Probabilit√†)
            probMinInput.addEventListener('change', () => {
                const min = parseInt(probMinInput.value) || 0;
                const max = parseInt(probMaxInput.value) || 100;
                if (min <= max) {
                    probabilitySliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            probMaxInput.addEventListener('change', () => {
                const min = parseInt(probMinInput.value) || 0;
                const max = parseInt(probMaxInput.value) || 100;
                if (min <= max) {
                    probabilitySliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            // Sincronizzazione SLIDER ‚Üí INPUT (Quota)
            oddsSliderEl.noUiSlider.on('update', (values) => {
                oddsMinInput.value = parseFloat(values[0]).toFixed(2);
                oddsMaxInput.value = parseFloat(values[1]).toFixed(2);
            });

            oddsSliderEl.noUiSlider.on('set', () => {
                applyFiltersAndRender();
            });

            // Sincronizzazione INPUT ‚Üí SLIDER (Quota)
            oddsMinInput.addEventListener('change', () => {
                const min = parseFloat(oddsMinInput.value) || 1.0;
                const max = parseFloat(oddsMaxInput.value) || 10.0;
                if (min <= max) {
                    oddsSliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            oddsMaxInput.addEventListener('change', () => {
                const min = parseFloat(oddsMinInput.value) || 1.0;
                const max = parseFloat(oddsMaxInput.value) || 10.0;
                if (min <= max) {
                    oddsSliderEl.noUiSlider.set([min, max]);
                    applyFiltersAndRender();
                }
            });

            // Buttons
            const resetFiltersBtn = document.getElementById('reset-filters-btn');
            const resetLeaguesBtn = document.getElementById('reset-leagues-btn');
            const resetTipsBtn = document.getElementById('reset-tips-btn');
            const exportFilteredBtn = document.getElementById('export-filtered-btn');
            const saveFilterBtn = document.getElementById('save-filter-btn');
            const loadFilterBtn = document.getElementById('load-filter-btn');
            const deleteFilterBtn = document.getElementById('delete-filter-btn');
            const updateFavoritesBtn = document.getElementById('update-favorites-btn');

            // Dates - Dashboard VUOTA all'inizio
            filterDateStart.value = '';
            filterDateEnd.value = '';

            // Altre pagine mantengono data odierna
            const today = new Date();
            document.getElementById('tips-date').value = today.toISOString().split('T')[0];
            document.getElementById('results-date').value = today.toISOString().split('T')[0];
            document.getElementById('ranking-date').value = today.toISOString().split('T')[0];

            // ==================== NAVIGATION ====================
            function showPage(pageId) {
                pages.forEach(p => p.classList.remove('active'));
                document.getElementById(pageId).classList.add('active');

                navButtons.forEach(btn => {
                    if (btn.dataset.page === pageId) {
                        btn.classList.remove('bg-gray-200', 'text-gray-700');
                        btn.classList.add('bg-blue-600', 'text-white');
                    } else {
                        btn.classList.remove('bg-blue-600', 'text-white');
                        btn.classList.add('bg-gray-200', 'text-gray-700');
                    }
                });

                if (pageId === 'page-oggi') updateTipsDaysList();
                if (pageId === 'page-risultati') updateResultsDaysList();
            }

            navButtons.forEach(btn => btn.addEventListener('click', (e) => showPage(e.currentTarget.dataset.page)));

            // ==================== LOAD DATA ====================
            async function loadAllMatches() {
                try {
                    const matchesCol = collection(db, "matches");
                    const snapshot = await getDocs(matchesCol);
                    allMatches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    allMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                    window.allMatches = allMatches; // Sync global
                } catch (e) {
                    console.error('Error loading matches:', e);
                    allMatches = [];
                    window.allMatches = []; // Sync global
                }
            }



            // ==================== FILTERS ====================
            function setupFilters() {
                searchInput.addEventListener('input', applyFiltersAndRender);
                filterDateStart.addEventListener('change', applyFiltersAndRender);
                filterDateEnd.addEventListener('change', applyFiltersAndRender);

                document.getElementById('show-no-result-btn').addEventListener('click', function () {
                    showOnlyNoResult = !showOnlyNoResult;
                    if (showOnlyNoResult) {
                        this.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                        this.classList.add('bg-green-600', 'hover:bg-green-700');
                        this.innerHTML = '<i class="fa-solid fa-check mr-1"></i> Senza Risultato';
                    } else {
                        this.classList.remove('bg-green-600', 'hover:bg-green-700');
                        this.classList.add('bg-orange-500', 'hover:bg-orange-600');
                        this.innerHTML = '<i class="fa-solid fa-filter mr-1"></i> Senza Risultato';
                    }
                    applyFiltersAndRender();
                });
            }

            function categorizeLeague(leagueName) {
                if (favoriteLeagues.includes(leagueName)) return '‚≠ê Preferiti';
                if (leagueName.startsWith('EU-Champions League') || leagueName.startsWith('EU-Europa League') || leagueName.startsWith('EU-Europa Conference League')) return 'Coppe Europee';
                if (leagueName.includes('WCQ') || leagueName.endsWith('-NAZ')) return 'Competizioni Nazionali';
                if (/(Cup|Coppa|Copa|Beker|Ta√ßa)/i.test(leagueName)) return 'Coppe Nazionali';

                const continentMatch = leagueName.match(/^(AS|AF|NA|SA|OC)-/);
                if (continentMatch) return 'Resto del Mondo';

                const europeanPrefixes = ['EU-'];
                if (europeanPrefixes.some(prefix => leagueName.startsWith(prefix))) return 'Europa';

                return 'Non Classificati';
            }

            function populateFilters() {
                // Leagues categorizzate
                const leagues = [...new Set(allMatches.map(m => m.lega))];
                const categorized = leagues.reduce((acc, league) => {
                    const category = categorizeLeague(league);
                    if (!acc[category]) acc[category] = [];
                    acc[category].push(league);
                    return acc;
                }, {});

                const categoryOrder = ['‚≠ê Preferiti', 'Europa', 'Resto del Mondo', 'Coppe Europee', 'Competizioni Nazionali', 'Coppe Nazionali', 'Non Classificati'];
                leagueFiltersGrid.innerHTML = '';

                // Change container style to flex column for accordions
                leagueFiltersGrid.className = 'flex flex-col gap-2';

                categoryOrder.forEach(category => {
                    if (!categorized[category] || categorized[category].length === 0) return;

                    const details = document.createElement('details');
                    details.className = 'group bg-gray-50 border rounded-lg overflow-hidden shadow-sm';
                    // Open Favorites by default - DISABLED
                    // if (category === '‚≠ê Preferiti') details.open = true;

                    const leaguesInCategory = categorized[category].sort().map(league => `
                        <div class="flex items-center justify-between p-2 hover:bg-blue-50 border-b border-gray-100 last:border-0 transition-colors">
                            <label class="flex items-center space-x-3 cursor-pointer flex-grow">
                                <input type="checkbox" value="${league}" class="league-checkbox form-checkbox h-4 w-4 rounded text-blue-600 border-gray-300 focus:ring-blue-500">
                                <span class="text-sm text-gray-700" title="${league}">${league}</span>
                            </label>
                            <i class="fa-solid fa-star favorite-star ${stagedFavoriteLeagues.includes(league) ? 'is-favorite' : ''} text-gray-300 hover:text-yellow-400 transition-colors cursor-pointer p-1" data-league="${league}"></i>
                        </div>`).join('');

                    details.innerHTML = `
                        <summary class="flex items-center justify-between p-3 cursor-pointer bg-white hover:bg-gray-50 transition-colors list-none select-none">
                            <div class="flex items-center space-x-2 font-semibold text-gray-700">
                                <input type="checkbox" class="category-select-all form-checkbox h-4 w-4 rounded text-blue-600 border-gray-300 focus:ring-blue-500" onclick="event.stopPropagation()">
                                <span>${category}</span>
                                <span class="text-xs font-normal text-gray-500 bg-gray-100 px-2 py-0.5 rounded-full">${categorized[category].length}</span>
                            </div>
                            <i class="fa-solid fa-chevron-down text-gray-400 transition-transform duration-200 group-open:rotate-180"></i>
                        </summary>
                        <div class="max-h-96 overflow-y-auto custom-scrollbar bg-white border-t border-gray-100">
                            ${leaguesInCategory}
                        </div>`;

                    leagueFiltersGrid.appendChild(details);
                });

                leagueFiltersGrid.querySelectorAll('.league-checkbox').forEach(cb => {
                    cb.addEventListener('change', applyFiltersAndRender);
                });

                leagueFiltersGrid.querySelectorAll('.category-select-all').forEach(masterCb => {
                    masterCb.addEventListener('change', (e) => {
                        const isChecked = e.target.checked;
                        const details = e.target.closest('details');
                        details.querySelectorAll('.league-checkbox').forEach(leagueCb => {
                            leagueCb.checked = isChecked;
                        });
                        applyFiltersAndRender();
                    });
                });

                leagueFiltersGrid.querySelectorAll('.favorite-star').forEach(star => {
                    star.addEventListener('click', handleFavoriteToggle);
                });

                // Predefined Tips by Market
                const predefinedTips = {
                    '1X2': ['1', 'X', '2'],
                    'Doppia Chance': ['1X', '12', 'X2'],
                    'Under/Over': ['-1.5', '+1.5', '-2.5', '+2.5', '-3.5', '+3.5'],
                    'Gol/No Gol': ['S√¨', 'No']
                };

                tipFiltersContainer.innerHTML = `<div class="grid grid-cols-2 md:grid-cols-4 gap-4">${Object.entries(predefinedTips).map(([market, tips]) => {
                    const tipButtons = tips.map(tip => `
                        <button data-tip="${tip}" class="tip-button w-full px-2 py-1 text-xs rounded-full border border-gray-300 bg-white hover:bg-gray-100 transition-colors">${tip}</button>
                    `).join('');
                    return `
                        <div>
                            <h4 class="font-semibold text-xs uppercase text-gray-500 mb-2">${market}</h4>
                            <div class="flex flex-wrap gap-2">${tipButtons}</div>
                        </div>
                    `;
                }).join('')}</div>`;

                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('active');
                        applyFiltersAndRender();
                    });
                });
            }

            let showOnlyNoResult = false;

            function applyFiltersAndRender(customSort = null) {
                const selectedLeagues = Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value);
                const selectedTips = Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip);
                const [probMin, probMax] = probabilitySliderEl.noUiSlider.get().map(v => parseInt(v));
                const [oddsMin, oddsMax] = oddsSliderEl.noUiSlider.get().map(v => parseFloat(v));
                const searchTerm = searchInput.value.toLowerCase().trim();
                const dateStart = filterDateStart.value ? new Date(filterDateStart.value) : null;
                const dateEnd = filterDateEnd.value ? new Date(filterDateEnd.value) : null;

                filteredMatches = allMatches.filter(m => {
                    if (showOnlyNoResult) {
                        if (m.risultato && m.risultato.trim() !== '') return false;
                    }

                    if (selectedLeagues.length > 0 && !selectedLeagues.includes(m.lega)) return false;
                    if (selectedTips.length > 0 && !selectedTips.includes(m.tip)) return false;
                    if (m.probabilita < probMin || m.probabilita > probMax) return false;
                    if (m.quota < oddsMin || m.quota > oddsMax) return false;

                    if (searchTerm) {
                        const matchText = `${m.lega} ${m.partita}`.toLowerCase();
                        if (!matchText.includes(searchTerm)) return false;
                    }

                    if (dateStart || dateEnd) {
                        const matchDate = new Date(m.data || '2000-01-01');
                        if (dateStart && matchDate < dateStart) return false;
                        if (dateEnd && matchDate > dateEnd) return false;
                    }

                    return true;
                });

                console.log(`[applyFiltersAndRender] Filtered matches: ${filteredMatches.length} (from ${allMatches.length})`);
                sortAndRenderMatches(customSort);
                updateStatsDisplay(filteredMatches);
            }

            function updateStatsDisplay(filteredMatches) {
                // SMART STATS: 
                // - If NO filters active: show GLOBAL stats (matching Client App)
                // - If filters active: show stats for filtered matches

                const selectedLeagues = Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value);
                const selectedTips = Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip);
                const searchTerm = searchInput.value.toLowerCase().trim();
                const dateStart = filterDateStart.value;
                const dateEnd = filterDateEnd.value;
                const [probMin, probMax] = probabilitySliderEl.noUiSlider.get().map(v => parseInt(v));
                const [oddsMin, oddsMax] = oddsSliderEl.noUiSlider.get().map(v => parseFloat(v));

                // Detect if filters are active
                const hasActiveFilters =
                    selectedLeagues.length > 0 ||
                    selectedTips.length > 0 ||
                    searchTerm !== '' ||
                    dateStart || dateEnd ||
                    showOnlyNoResult ||
                    probMin > 0 || probMax < 100 ||
                    oddsMin > 1.0 || oddsMax < 10.0;

                let matchesToCount;
                if (hasActiveFilters) {
                    // Use filtered matches
                    matchesToCount = filteredMatches;
                    console.log(`[updateStatsDisplay] Filters active - using ${matchesToCount.length} filtered matches`);
                } else {
                    // Use global matches with result (matching Client App)
                    matchesToCount = (window.allMatches || []).filter(m => m.risultato && m.risultato.trim() !== '');
                    console.log(`[updateStatsDisplay] No filters - using ${matchesToCount.length} global matches with result`);
                }

                const matchesWithResult = matchesToCount.filter(m => m.risultato && m.risultato.trim() !== '');
                const won = matchesWithResult.filter(m => m.esito === 'Vinto').length;
                const lost = matchesWithResult.filter(m => m.esito === 'Perso').length;

                const totalStake = matchesWithResult.length;
                const winRate = totalStake > 0 ? (won / totalStake) * 100 : 0;

                const matchesWithOutcome = matchesWithResult.filter(m => m.esito === 'Vinto' || m.esito === 'Perso');
                const profit = matchesWithOutcome.reduce((acc, m) => acc + (m.esito === 'Vinto' ? m.quota - 1 : -1), 0);
                const roi = matchesWithOutcome.length > 0 ? (profit / matchesWithOutcome.length * 100) : 0;

                const label = hasActiveFilters ? 'Totale (Filtrato)' : 'Totale';
                const statsContainer = document.getElementById('stats-container');
                statsContainer.innerHTML = `
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-blue-600">${totalStake}</div><div class="text-xs text-gray-600">${label}</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-green-600">${won}</div><div class="text-xs text-gray-600">Vinte</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold text-red-600">${lost}</div><div class="text-xs text-gray-600">Perse</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold ${winRate >= 70 ? 'text-green-600' : 'text-red-600'}">${winRate.toFixed(1)}%</div><div class="text-xs text-gray-600">Winrate</div></div>
                    <div class="bg-white p-4 rounded-xl shadow-md border"><div class="text-2xl font-bold ${roi >= 0 ? 'text-green-600' : 'text-red-600'}">${roi.toFixed(1)}%</div><div class="text-xs text-gray-600">ROI</div></div>
                `;
            }

            function sortAndRenderMatches(customSort = null) {
                let sorted;

                // v3.5.3: Custom sort da dropdown
                if (customSort) {
                    const sortSelect = document.getElementById('dashboard-sort-select');
                    const sortValue = customSort || (sortSelect ? sortSelect.value : 'data-desc');

                    sorted = [...filteredMatches].sort((a, b) => {
                        if (sortValue === 'orario-asc') {
                            // Ordina per orario cronologico
                            const timeA = a.time || '99:99';
                            const timeB = b.time || '99:99';
                            return timeA.localeCompare(timeB);
                        } else if (sortValue === 'data-desc') {
                            return new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01');
                        } else if (sortValue === 'lega') {
                            return (a.lega || '').localeCompare(b.lega || '');
                        } else if (sortValue === 'quota') {
                            return (a.quota || 0) - (b.quota || 0);
                        }
                        return 0;
                    });
                } else {
                    // Sort normale da header click
                    const { column, direction } = sortState;
                    sorted = [...filteredMatches].sort((a, b) => {
                        const valA = a[column];
                        const valB = b[column];
                        let comparison = 0;
                        if (typeof valA === 'string') comparison = valA.localeCompare(valB);
                        else comparison = valA - valB;
                        return direction === 'asc' ? comparison : -comparison;
                    });
                }

                renderMatchList(sorted);
                updateSortIcons();
            }

            function renderMatchList(matches) {
                const tbody = document.getElementById('match-list-body');
                document.getElementById('filtered-count').textContent = matches.length;

                const displayMatches = matches.slice(0, 200);
                const now = new Date();

                const tableHeader = `
        <thead class="text-xs text-gray-700 uppercase bg-gray-50 sticky top-0">
            <tr>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('data')">DATA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('lega')">LEGA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('partita')">PARTITA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-left cursor-pointer hover:bg-gray-100" onclick="updateSort('tip')">TIP <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('risultato')">RIS. <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('probabilita')">PROB. <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('quota')">QUOTA <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100 w-48" onclick="updateSort('info_ht')">HT <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th> <!-- Expanded HT -->
                <th class="p-3 text-center cursor-pointer hover:bg-gray-100" onclick="updateSort('esito')">ESITO <i class="fa-solid fa-sort text-gray-400 ml-1"></i></th>
                <!-- Actions Removed -->
            </tr>
        </thead>
        <tbody class="divide-y divide-gray-100">
    `;

                const matchesToRender = matches || filteredMatches;

                if (matchesToRender.length === 0) {
                    tbody.innerHTML = `
            ${tableHeader}
            <tr><td colspan="9" class="p-8 text-center text-gray-500">Nessuna partita trovata.</td></tr>
            </tbody></table>
        `;
                    return;
                }

                tbody.innerHTML = displayMatches.map(m => {
                    const isEditing = m.id === editingMatchId;
                    const esitoClass = m.esito === 'Vinto' ? 'text-green-600 font-bold' : m.esito === 'Perso' ? 'text-red-600 font-bold' : '';

                    // Processo info HT
                    let htDisplay = '<span class="ht-badge-none">-</span>';
                    if (m.info_ht && m.info_ht.trim() !== '') {
                        const probMatch = m.info_ht.match(/(\d+)%/);
                        if (probMatch) {
                            const htProb = parseInt(probMatch[1]);
                            let badgeClass = 'ht-badge-low';
                            if (htProb >= 75) badgeClass = 'ht-badge-high';
                            else if (htProb >= 60) badgeClass = 'ht-badge-medium';
                            htDisplay = `<span class="${badgeClass}">${m.info_ht}</span>`;
                        }
                    }

                    if (isEditing) {
                        return `
                            <tr class="bg-blue-50 border-2 border-blue-400">
                                <td class="p-3 text-xs">${m.data}</td>
                                <td class="p-3 text-xs"><input type="text" id="edit-lega-${m.id}" value="${m.lega}" class="w-full p-1 border rounded"></td>
                                <td class="p-3 text-xs"><input type="text" id="edit-partita-${m.id}" value="${m.partita}" class="w-full p-1 border rounded"></td>
                                <td class="p-3 text-xs font-semibold">${m.tip}</td>
                                <td class="p-3 text-xs"><input type="text" id="edit-risultato-${m.id}" value="${m.risultato || ''}" class="w-full p-1 border rounded" placeholder="-"></td>
                                <td class="p-3 text-xs text-center">${m.probabilita}%</td>
                                <td class="p-3 text-xs text-center font-bold">${m.quota}</td>
                                <td class="p-3 text-xs text-center">${htDisplay}</td>
                                <td class="p-3 text-xs">
                                    <select id="edit-esito-${m.id}" class="w-full p-1 border rounded">
                                        <option value="" ${!m.esito ? 'selected' : ''}>-</option>
                                        <option value="Vinto" ${m.esito === 'Vinto' ? 'selected' : ''}>Vinto</option>
                                        <option value="Perso" ${m.esito === 'Perso' ? 'selected' : ''}>Perso</option>
                                    </select>
                                </td>
                                <td class="p-3 text-xs text-center flex gap-2 justify-center">
                                    <button onclick="saveEdit('${m.id}')" class="text-green-600 hover:text-green-800" title="Salva"><i class="fa-solid fa-check fa-lg"></i></button>
                                    <button onclick="cancelEdit()" class="text-red-600 hover:text-red-800" title="Annulla"><i class="fa-solid fa-times fa-lg"></i></button>
                                </td>
                            </tr>
                        `;
                    }

                    return `
                        <tr class="hover:bg-gray-50 group">
                            <td class="p-3 text-xs">${m.data}</td>
                            <td class="p-3 text-xs">${m.lega}</td>
                            <td class="p-3 text-xs font-medium">${m.partita}</td>
                            <td class="p-3 text-xs font-semibold">${m.tip}</td>
                            <td class="p-3 text-xs text-center">${m.risultato || '-'}</td>
                            <td class="p-3 text-xs text-center">${m.probabilita}%</td>
                            <td class="p-3 text-xs text-center font-bold">${m.quota}</td>
                            <td class="p-3 text-xs text-center w-48 whitespace-nowrap">${htDisplay}</td> <!-- Expanded HT -->
                            <td class="p-3 text-xs text-center ${esitoClass}">${m.esito || '-'}</td>
                            <td class="p-3 text-xs text-center opacity-0 group-hover:opacity-100 transition-opacity flex gap-2 justify-center">
                                <button onclick="enableEditMode('${m.id}')" class="text-blue-600 hover:text-blue-800" title="Modifica"><i class="fa-solid fa-pencil"></i></button>
                                <button onclick="deleteMatch('${m.id}')" class="text-red-600 hover:text-red-800" title="Elimina"><i class="fa-solid fa-trash"></i></button>
                            </td>
                        </tr>
                    `;
                }).join('');

                if (matches.length > 200) {
                    tbody.innerHTML += `<tr><td colspan="11" class="p-3 text-center text-sm text-gray-500">Mostrati primi 200 di ${matches.length}</td></tr>`;
                }
            }

            // ==================== EDIT & DELETE FUNCTIONS ====================
            window.enableEditMode = (matchId) => {
                editingMatchId = matchId;
                applyFiltersAndRender(); // Re-render to show inputs
            };

            window.cancelEdit = () => {
                editingMatchId = null;
                applyFiltersAndRender();
            };

            window.saveEdit = async (matchId) => {
                const newLega = document.getElementById(`edit-lega-${matchId}`).value;
                const newPartita = document.getElementById(`edit-partita-${matchId}`).value;
                const newRisultato = document.getElementById(`edit-risultato-${matchId}`).value;
                const newEsito = document.getElementById(`edit-esito-${matchId}`).value;

                try {
                    const matchRef = doc(db, "matches", matchId);
                    await updateDoc(matchRef, {
                        lega: newLega,
                        partita: newPartita,
                        risultato: newRisultato,
                        esito: newEsito
                    });

                    // Update local data
                    const matchIndex = allMatches.findIndex(m => m.id === matchId);
                    if (matchIndex !== -1) {
                        allMatches[matchIndex].lega = newLega;
                        allMatches[matchIndex].partita = newPartita;
                        allMatches[matchIndex].risultato = newRisultato;
                        allMatches[matchIndex].esito = newEsito;
                    }

                    editingMatchId = null;
                    applyFiltersAndRender();
                    alert("Partita aggiornata con successo!");
                } catch (error) {
                    console.error("Error updating match:", error);
                    alert("Errore durante l'aggiornamento: " + error.message);
                }
            };

            window.deleteMatch = async (matchId) => {
                if (!confirm("Sei sicuro di voler eliminare questa partita? L'operazione √® irreversibile.")) return;

                try {
                    await deleteDoc(doc(db, "matches", matchId));

                    // Remove from local data
                    allMatches = allMatches.filter(m => m.id !== matchId);
                    applyFiltersAndRender();
                    alert("Partita eliminata.");
                } catch (error) {
                    console.error("Error deleting match:", error);
                    alert("Errore durante l'eliminazione: " + error.message);
                }
            };

            function updateSortIcons() {
                document.querySelectorAll('.sortable-header').forEach(header => {
                    const icon = header.querySelector('.sort-icon');
                    if (header.dataset.sort === sortState.column) {
                        header.classList.add('active');
                        if (sortState.direction === 'asc') {
                            icon.classList.remove('fa-sort', 'fa-sort-down');
                            icon.classList.add('fa-sort-up');
                        } else {
                            icon.classList.remove('fa-sort', 'fa-sort-up');
                            icon.classList.add('fa-sort-down');
                        }
                    } else {
                        header.classList.remove('active');
                        icon.classList.remove('fa-sort-up', 'fa-sort-down');
                        icon.classList.add('fa-sort');
                    }
                });
            }

            sortableHeaders.forEach(header => header.addEventListener('click', (e) => {
                const newColumn = e.currentTarget.dataset.sort;
                if (sortState.column === newColumn) {
                    sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.column = newColumn;
                    sortState.direction = ['data', 'probabilita', 'quota'].includes(newColumn) ? 'desc' : 'asc';
                }
                sortAndRenderMatches();
            }));

            // ==================== FAVORITES ====================
            const loadFavorites = async () => {
                try {
                    const favDocRef = doc(db, "preferences", "favoriteLeagues");
                    const docSnap = await getDoc(favDocRef);
                    if (docSnap.exists()) {
                        favoriteLeagues = docSnap.data().leagues || [];
                        stagedFavoriteLeagues = [...favoriteLeagues];
                    }
                } catch (e) { console.error("Error:", e); }
            };

            const handleUpdateFavorites = async () => {
                favoriteLeagues = [...stagedFavoriteLeagues];
                try {
                    await setDoc(doc(db, "preferences", "favoriteLeagues"), { leagues: favoriteLeagues });
                    populateFilters();
                    applyFiltersAndRender();
                    showModal("Successo", "Preferiti aggiornati!", () => { });
                } catch (e) {
                    showModal("Errore", `Errore: ${e.message}`, () => { });
                }
            };

            const handleFavoriteToggle = (e) => {
                const leagueName = e.target.dataset.league;
                if (stagedFavoriteLeagues.includes(leagueName)) {
                    stagedFavoriteLeagues = stagedFavoriteLeagues.filter(l => l !== leagueName);
                } else {
                    stagedFavoriteLeagues.push(leagueName);
                }
                e.target.classList.toggle('is-favorite');
            };

            updateFavoritesBtn.addEventListener('click', handleUpdateFavorites);

            // ==================== CLIENT FILTERS MANAGEMENT (NEW) ====================
            let allClientFilters = {}; // Stores both presets and strategies

            async function loadClientFiltersForAdmin() {
                try {
                    allClientFilters = {};
                    const select = document.getElementById('client-filters-select');
                    select.innerHTML = '<option value="">Seleziona Filtro Client...</option>';

                    // 1. Load Standard Presets
                    const presetsDoc = await getDoc(doc(db, "system", "client_presets"));
                    if (presetsDoc.exists()) {
                        const presets = presetsDoc.data();
                        Object.keys(presets).forEach(key => {
                            if (key === 'lastUpdated') return;
                            // v4.0: Presets now have { leagues: [], stats: {} } structure
                            const presetData = presets[key];
                            // Handle both old (array) and new (object) structure for backward compatibility
                            const leagues = Array.isArray(presetData) ? presetData : (presetData.leagues || []);

                            allClientFilters[key] = {
                                type: 'preset',
                                name: key.replace(/_/g, ' ').toUpperCase(),
                                leagues: leagues,
                                // Standard presets don't have sliders/tips stored, they use defaults
                            };
                            select.innerHTML += `<option value="${key}">üéØ ${allClientFilters[key].name}</option>`;
                        });
                    }

                    // 2. Load Custom Strategies (ONLY published ones with readable names)
                    const strategiesDoc = await getDoc(doc(db, "system", "client_strategies"));
                    if (strategiesDoc.exists()) {
                        const strategies = strategiesDoc.data();
                        Object.keys(strategies).forEach(key => {
                            // Skip if it's a random Firebase ID (contains random chars, not a readable name)
                            // Published strategies should have readable IDs like "magia_ai___"
                            const isRandomId = /^[A-Z0-9]{20,}$/i.test(key);
                            if (isRandomId) {
                                console.log(`[loadClientFilters] Skipping unpublished test strategy: ${key}`);
                                return;
                            }

                            allClientFilters[key] = {
                                type: 'strategy',
                                name: strategies[key].name || key.replace(/_/g, ' ').toUpperCase(),
                                ...strategies[key] // Contains leagues, probRange, oddsRange, etc.
                            };
                            select.innerHTML += `<option value="${key}">‚ö° ${allClientFilters[key].name}</option>`;
                        });
                    }
                } catch (e) {
                    console.error("Error loading client filters:", e);
                    showModal("Errore", "Impossibile caricare i filtri client.");
                }
            }

            function handleClientFilterSelect() {
                const selectedKey = document.getElementById('client-filters-select').value;
                if (!selectedKey) return;

                const filter = allClientFilters[selectedKey];
                if (!filter) return;

                // Reset UI first
                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));

                // Apply Leagues
                if (filter.leagues && Array.isArray(filter.leagues)) {
                    console.log(`[handleClientFilterSelect] Leagues in filter: ${filter.leagues.length}`);
                    let checkedCount = 0;
                    filter.leagues.forEach(league => {
                        // Normalize league name for matching (handle case sensitivity if needed)
                        // The checkbox values are usually the exact league names from DB
                        const cb = leagueFiltersGrid.querySelector(`input.league-checkbox[value="${league}"]`);
                        if (cb) {
                            cb.checked = true;
                            checkedCount++;
                        } else {
                            console.warn(`[handleClientFilterSelect] Checkbox not found for league: ${league}`);
                        }
                    });
                    console.log(`[handleClientFilterSelect] Checked ${checkedCount} boxes.`);
                } else {
                    console.log(`[handleClientFilterSelect] No leagues in filter or not an array.`);
                }

                // Apply Sliders (if present, otherwise default)
                if (filter.probRange) {
                    probabilitySliderEl.noUiSlider.set(filter.probRange);
                } else {
                    probabilitySliderEl.noUiSlider.set([0, 100]); // Default
                }

                if (filter.oddsRange) {
                    oddsSliderEl.noUiSlider.set(filter.oddsRange);
                } else {
                    oddsSliderEl.noUiSlider.set([1.0, 10.0]); // Default
                }

                // Apply Tips (if present)
                if (filter.tips && Array.isArray(filter.tips)) {
                    filter.tips.forEach(tip => {
                        const btn = tipFiltersContainer.querySelector(`.tip-button[data-tip="${tip}"]`);
                        if (btn) btn.classList.add('active');
                    });
                }

                console.log(`[handleClientFilterSelect] Applying filter: ${filter.name}`);
                applyFiltersAndRender();
                showModal("Filtro Caricato", `Caricato filtro: <b>${filter.name}</b>.<br>Puoi modificarlo e salvarlo.`);
            }

            // Recalculate Button Handler
            const recalcBtn = document.getElementById('recalc-strategies-btn');
            if (recalcBtn) {
                recalcBtn.addEventListener('click', async () => {
                    const btn = document.getElementById('recalc-strategies-btn');
                    const originalText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i> Calcolo in corso...';

                    try {
                        // USE THE DATE FROM CALENDAR, NOT ALWAYS TODAY!
                        // Try new Pronostici tab first, fallback to old Storico tab
                        const pronosticiDate = document.getElementById('pronostici-date')?.value;
                        const storicoDate = document.getElementById('storico-date')?.value;
                        const calendarDate = pronosticiDate || storicoDate;
                        const targetDate = calendarDate || new Date().toISOString().split('T')[0];

                        console.log(`[Ricalcola Oggi] Recalculating for date: ${targetDate}`);

                        const matchesRef = collection(db, "matches");
                        const q = query(matchesRef, where("data", "==", targetDate));
                        const snapshot = await getDocs(q);

                        const targetMatches = [];
                        snapshot.forEach(doc => targetMatches.push(doc.data()));

                        if (targetMatches.length > 0) {
                            await calculateStrategyRankings(targetMatches, targetDate);
                            alert(`‚úÖ Strategie ricalcolate con successo per il ${targetDate}!\n\n${targetMatches.length} partite elaborate.`);
                        } else {
                            alert('‚ö†Ô∏è Nessuna partita trovata per oggi.');
                        }
                    } catch (e) {
                        console.error("Error recalculating:", e);
                        alert('Errore durante il ricalcolo: ' + e.message);
                    } finally {
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                    }
                });
            }

            // === PRONOSTICI TAB: 2 SIMPLE BUTTONS ===

            // Button 1: Carica Previsioni (ricalcola + visualizza)
            const pronosticiLoadBtn = document.getElementById('pronostici-load-btn');
            if (pronosticiLoadBtn) {
                pronosticiLoadBtn.addEventListener('click', async () => {
                    const selectedDate = document.getElementById('pronostici-unified-date').value;
                    if (!selectedDate) {
                        alert('‚ö†Ô∏è Seleziona una data!');
                        return;
                    }

                    const btn = document.getElementById('pronostici-load-btn');
                    const originalText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i> Calcolo in corso...';

                    try {
                        console.log(`[Pronostici] Calculating for date: ${selectedDate}`);

                        // Step 1: Ricalcola strategie
                        const matchesRef = collection(db, "matches");
                        const q = query(matchesRef, where("data", "==", selectedDate));
                        const snapshot = await getDocs(q);

                        const targetMatches = [];
                        snapshot.forEach(doc => targetMatches.push(doc.data()));

                        if (targetMatches.length === 0) {
                            alert(`‚ö†Ô∏è Nessuna partita trovata per il ${selectedDate}.`);
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                            return;
                        }

                        await calculateStrategyRankings(targetMatches, selectedDate);
                        console.log('[Pronostici] ‚úÖ Calculation completed, now loading display...');

                        // Step 2: Carica e visualizza ranking
                        console.log('[Pronostici] Fetching from rankings/' + selectedDate);
                        const rankingDoc = await getDoc(doc(db, "rankings", selectedDate));
                        console.log('[Pronostici] Doc exists:', rankingDoc.exists());

                        if (!rankingDoc.exists()) {
                            alert(`Ranking calcolato ma errore visualizzazione`);
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                            return;
                        }

                        const savedRankingData = rankingDoc.data();
                        const strategies = savedRankingData.strategies;
                        console.log('[Pronostici] Strategies loaded:', Object.keys(strategies).length);

                        // Mostra sezione ranking
                        console.log('[Pronostici] Showing ranking section...');
                        document.getElementById('pronostici-ranking-section').classList.remove('hidden');
                        document.getElementById('pronostici-storico-section').classList.add('hidden');

                        const strategiesGrid = document.getElementById('ranking-strategies-grid');
                        strategiesGrid.innerHTML = '';
                        console.log('[Pronostici] Building strategy cards...');

                        Object.keys(strategies).forEach((stratId, index) => {
                            try {
                                console.log(`[Pronostici] Creating card ${index + 1}/${Object.keys(strategies).length}: ${stratId}`);
                                const strat = strategies[stratId];

                                // Calculate stats
                                const matches = strat.partite_by_tip || strat.matches || [];
                                const allPartite = Array.isArray(matches) ? matches : Object.values(matches).flat();

                                // HYDRATION: Update esito/risultato from allMatches
                                // NOTE: Saved rankings don't have 'id', so we use data+partita as key
                                const globalMatchesMap = new Map((window.allMatches || []).map(m => {
                                    const key = `${m.data}_${m.partita}`;
                                    return [key, m];
                                }));

                                let vinte = 0, perse = 0, void_match = 0;
                                allPartite.forEach(p => {
                                    const matchKey = `${p.data}_${p.partita}`;
                                    const latest = globalMatchesMap.get(matchKey);
                                    if (latest) {
                                        p.risultato = latest.risultato || p.risultato;
                                        p.esito = latest.esito || p.esito;
                                    }

                                    if (p.esito === 'Vinto') vinte++;
                                    else if (p.esito === 'Perso') perse++;
                                    else void_match++;
                                });

                                const totalResolved = vinte + perse;
                                const winRate = totalResolved > 0 ? ((vinte / totalResolved) * 100).toFixed(1) : 0;

                                const card = document.createElement('div'); // Changed to div for better control
                                card.className = `p-4 rounded-xl border-2 cursor-pointer transition-all hover:shadow-xl hover:-translate-y-1 ${strat.magic_type === 'gold' ? 'border-yellow-400 bg-yellow-50' :
                                    strat.magic_type === 'silver' ? 'border-gray-300 bg-gray-50' :
                                        'border-purple-100 bg-white hover:border-purple-300'
                                    }`;

                                card.innerHTML = `
                                    <div class="flex justify-between items-start mb-3">
                                        <div class="font-bold text-gray-800 text-lg truncate pr-2" title="${strat.name}">${strat.name}</div>
                                        <div class="text-xs px-2 py-1 rounded font-bold uppercase tracking-wider ${strat.magic_type === 'gold' ? 'bg-yellow-200 text-yellow-800' :
                                        strat.magic_type === 'silver' ? 'bg-gray-200 text-gray-700' :
                                            'bg-purple-100 text-purple-700'
                                    }">
                                            ${strat.magic_type || 'STD'}
                                        </div>
                                    </div>
                                    
                                    <div class="grid grid-cols-3 gap-2 mb-3">
                                        <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                            <div class="text-xs text-gray-500 uppercase">Partite</div>
                                            <div class="font-bold text-gray-800 text-lg">${allPartite.length}</div>
                                        </div>
                                        <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                            <div class="text-xs text-gray-500 uppercase">Win Rate</div>
                                            <div class="font-bold ${parseFloat(winRate) >= 70 ? 'text-green-600' : parseFloat(winRate) >= 50 ? 'text-blue-600' : 'text-orange-500'} text-lg">${winRate}%</div>
                                        </div>
                                        <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                            <div class="text-xs text-gray-500 uppercase">W / L</div>
                                            <div class="font-bold text-gray-800 text-lg">
                                                <span class="text-green-600">${vinte}</span> / <span class="text-red-500">${perse}</span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="text-center text-xs text-purple-600 font-medium border-t border-purple-100 pt-2 mt-2">
                                        Clicca per vedere le partite <i class="fa-solid fa-chevron-right ml-1"></i>
                                    </div>
                                `;
                                card.addEventListener('click', () => displayRankingMatches(stratId, strat, savedRankingData));
                                strategiesGrid.appendChild(card);
                                console.log(`[Pronostici] Card ${index + 1} created successfully`);
                            } catch (cardError) {
                                console.error(`[Pronostici] Error creating card for ${stratId}:`, cardError);
                            }
                        });

                        console.log('[Pronostici] All cards created, showing lists...');

                        document.getElementById('ranking-strategies-list').classList.remove('hidden');
                        document.getElementById('ranking-matches-detail').classList.add('hidden');

                        alert(`‚úÖ Previsioni calcolate per il ${selectedDate}!\n\n${targetMatches.length} partite elaborate.\n${Object.keys(strategies).length} strategie generate.`);

                    } catch (e) {
                        console.error('[Pronostici] Error:', e);
                        alert('Errore: ' + e.message);
                    } finally {
                        btn.disabled = false;
                        btn.innerHTML = originalText;
                    }
                });
            }

            // Button 2: Storico Strategie
            const pronosticiHistoryBtn = document.getElementById('pronostici-history-btn');
            if (pronosticiHistoryBtn) {
                pronosticiHistoryBtn.addEventListener('click', async () => {
                    console.log('[Pronostici] Loading history (last 31 days)...');

                    try {
                        // Hide ranking, show storico
                        document.getElementById('pronostici-ranking-section').classList.add('hidden');

                        const storicoSection = document.getElementById('pronostici-storico-section');
                        storicoSection.classList.remove('hidden');

                        // Get last 31 dates (approx 1 month)
                        const historyRef = collection(db, "ranking_history");
                        const q = query(historyRef, orderBy("data_partite", "desc"), limit(50)); // Increased limit to handle duplicates
                        const snapshot = await getDocs(q);

                        if (snapshot.empty) {
                            alert('Nessuno storico trovato');
                            return;
                        }

                        // Update title
                        document.getElementById('pronostici-storico-title').textContent = `Storico Strategie`;
                        document.getElementById('pronostici-storico-count').textContent = `Seleziona una data per vedere i dettagli`;

                        // Show section
                        const listSection = document.getElementById('pronostici-storico-list');
                        listSection.classList.remove('hidden');

                        // Populate Simple List with DEDUPLICATION
                        const container = document.getElementById('pronostici-storico-container');
                        container.innerHTML = '';
                        container.className = "bg-white rounded-b-xl shadow-md border border-gray-200 overflow-hidden";

                        // Create Header
                        const header = document.createElement('div');
                        header.className = "grid grid-cols-3 bg-gray-50 p-4 font-bold text-gray-700 border-b border-gray-200 uppercase text-xs tracking-wider";
                        header.innerHTML = `
                            <div>Data</div>
                            <div class="text-center">Strategie</div>
                            <div class="text-center">Tot. Partite</div>
                        `;
                        container.appendChild(header);

                        // Deduplicate by date
                        const uniqueDates = new Map();

                        snapshot.forEach(doc => {
                            const data = doc.data();
                            const date = data.data_partite || doc.id;
                            const strategies = data.strategies || [];
                            const strategiesList = Array.isArray(strategies) ? strategies : Object.values(strategies);

                            // If date already exists, keep the one with more strategies
                            if (uniqueDates.has(date)) {
                                const existing = uniqueDates.get(date);
                                if (strategiesList.length > existing.strategiesList.length) {
                                    uniqueDates.set(date, { date, strategiesList });
                                }
                            } else {
                                uniqueDates.set(date, { date, strategiesList });
                            }
                        });

                        // Render unique rows
                        uniqueDates.forEach(({ date, strategiesList }) => {
                            const count = strategiesList.length;

                            // Calculate total matches
                            let totalMatches = 0;
                            strategiesList.forEach(s => {
                                const matches = s.partite_by_tip || s.matches || [];
                                const matchCount = Array.isArray(matches) ? matches.length : Object.values(matches).flat().length;
                                totalMatches += matchCount;
                            });

                            const row = document.createElement('div');
                            row.className = "grid grid-cols-3 p-4 border-b border-gray-100 hover:bg-purple-50 cursor-pointer transition-colors items-center group";
                            row.innerHTML = `
                                <div class="font-bold text-gray-800 group-hover:text-purple-700 flex items-center gap-2">
                                    <i class="fa-regular fa-calendar text-gray-400 group-hover:text-purple-500"></i>
                                    ${date}
                                </div>
                                <div class="text-center font-semibold text-gray-700">
                                    <span class="bg-gray-100 text-gray-800 py-1 px-3 rounded-full text-xs">${count}</span>
                                </div>
                                <div class="text-center text-gray-600 font-mono">${totalMatches}</div>
                            `;

                            row.addEventListener('click', () => {
                                renderStoricoStrategiesForDate(date, strategiesList);
                            });

                            container.appendChild(row);
                        });

                        console.log('[Pronostici] History list loaded successfully!');

                    } catch (e) {
                        console.error('[Pronostici] Error loading history:', e);
                        alert('Errore: ' + e.message);
                    }
                });
            }

            function renderStoricoStrategiesForDate(date, strategiesList) {
                // Update header
                document.getElementById('pronostici-storico-title').innerHTML = `
                    <button id="back-to-history-btn" class="mr-3 hover:text-purple-200 transition-colors">
                        <i class="fa-solid fa-arrow-left"></i>
                    </button>
                    Strategie del ${date}
                `;
                document.getElementById('pronostici-storico-count').textContent = `${strategiesList.length} strategie salvate`;

                const container = document.getElementById('pronostici-storico-container');
                container.innerHTML = '';

                // Add Back Button Logic
                document.getElementById('back-to-history-btn').addEventListener('click', () => {
                    document.getElementById('pronostici-history-btn').click();
                });

                // Ensure grid layout for strategies
                container.className = "bg-white rounded-b-xl shadow-md border border-gray-200 p-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4";

                // Hydration Map (using data+partita as key)
                const globalMatchesMap = new Map((window.allMatches || []).map(m => {
                    const key = `${m.data}_${m.partita}`;
                    return [key, m];
                }));

                strategiesList.forEach((ranking, index) => {
                    const partiteByTip = ranking.partite_by_tip || ranking.matches || [];
                    const allPartite = Array.isArray(partiteByTip) ? partiteByTip : Object.values(partiteByTip).flat();

                    let vinte = 0, perse = 0, void_match = 0;
                    allPartite.forEach(p => {
                        // HYDRATE using data+partita key
                        const matchKey = `${p.data}_${p.partita}`;
                        const latest = globalMatchesMap.get(matchKey);
                        if (latest) {
                            p.risultato = latest.risultato || p.risultato;
                            p.esito = latest.esito || p.esito;
                        }

                        if (p.esito === 'Vinto') vinte++;
                        else if (p.esito === 'Perso') perse++;
                        else void_match++;
                    });

                    const totalResolved = vinte + perse;
                    const winRate = totalResolved > 0 ? ((vinte / totalResolved) * 100).toFixed(1) : 0;

                    const card = document.createElement('div');
                    card.className = `p-4 rounded-xl border-2 cursor-pointer transition-all hover:shadow-xl hover:-translate-y-1 ${ranking.magic_type === 'gold' ? 'border-yellow-400 bg-yellow-50' :
                        ranking.magic_type === 'silver' ? 'border-gray-300 bg-gray-50' :
                            'border-purple-100 bg-white hover:border-purple-300'
                        }`;

                    card.innerHTML = `
                        <div class="flex justify-between items-start mb-3">
                            <div class="font-bold text-gray-800 text-lg truncate pr-2" title="${ranking.filtro_nome || ranking.name}">${ranking.filtro_nome || ranking.name || `Strategia ${index + 1}`}</div>
                            <div class="text-xs px-2 py-1 rounded font-bold uppercase tracking-wider ${ranking.magic_type === 'gold' ? 'bg-yellow-200 text-yellow-800' :
                            ranking.magic_type === 'silver' ? 'bg-gray-200 text-gray-700' :
                                'bg-purple-100 text-purple-700'
                        }">
                                ${ranking.magic_type || 'STD'}
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2 mb-3">
                            <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                <div class="text-xs text-gray-500 uppercase">Partite</div>
                                <div class="font-bold text-gray-800 text-lg">${allPartite.length}</div>
                            </div>
                            <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                <div class="text-xs text-gray-500 uppercase">Win Rate</div>
                                <div class="font-bold ${parseFloat(winRate) >= 70 ? 'text-green-600' : parseFloat(winRate) >= 50 ? 'text-blue-600' : 'text-orange-500'} text-lg">${winRate}%</div>
                            </div>
                            <div class="bg-white/50 rounded p-2 text-center border border-gray-100">
                                <div class="text-xs text-gray-500 uppercase">W / L</div>
                                <div class="font-bold text-gray-800 text-lg">
                                    <span class="text-green-600">${vinte}</span> / <span class="text-red-500">${perse}</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="text-center text-xs text-purple-600 font-medium border-t border-purple-100 pt-2 mt-2">
                            Clicca per vedere le partite <i class="fa-solid fa-chevron-right ml-1"></i>
                        </div>
                    `;

                    // Add click listener to show matches
                    card.addEventListener('click', () => {
                        displayRankingMatches(ranking.name || `Strategia ${index}`, ranking, { strategies: { [index]: ranking } });
                        // We need to ensure the ranking section is visible for the modal/list to appear if it uses that container
                        // Or we can render it in a modal. 
                        // The existing displayRankingMatches populates 'ranking-matches-container' and shows 'ranking-matches-detail'
                        // We need to make sure those elements are visible even if we are in "Storico" mode.

                        document.getElementById('pronostici-storico-list').classList.add('hidden');

                        // We'll reuse the ranking-matches-detail container but move it or ensure it's visible
                        const detailSection = document.getElementById('ranking-matches-detail');
                        detailSection.classList.remove('hidden');

                        // Hack: Move detail section to be visible in Storico context if needed, 
                        // or just hide storico list and show detail.
                        // The current structure has 'ranking-matches-detail' inside 'pronostici-ranking-section' which is hidden.
                        // We should move 'ranking-matches-detail' OUT of 'pronostici-ranking-section' or clone it.
                        // For now, let's unhide the parent ranking section TEMPORARILY but hide the ranking list

                        document.getElementById('pronostici-ranking-section').classList.remove('hidden');
                        document.getElementById('ranking-strategies-list').classList.add('hidden');
                        document.getElementById('pronostici-storico-section').classList.add('hidden');

                        // Override back button behavior
                        const backBtn = document.getElementById('ranking-back-btn');
                        const newBackBtn = backBtn.cloneNode(true);
                        backBtn.parentNode.replaceChild(newBackBtn, backBtn);

                        newBackBtn.addEventListener('click', () => {
                            document.getElementById('ranking-matches-detail').classList.add('hidden');
                            document.getElementById('pronostici-ranking-section').classList.add('hidden');
                            document.getElementById('pronostici-storico-section').classList.remove('hidden');
                            document.getElementById('pronostici-storico-list').classList.remove('hidden');
                        });
                    });

                    container.appendChild(card);
                });
            }

            // Helper function for displaying ranking matches
            function displayRankingMatches(stratId, strat, savedRankingData) {
                document.getElementById('ranking-strategy-name').textContent = strat.name;
                const container = document.getElementById('ranking-matches-container');
                container.innerHTML = '';

                const matches = strat.partite_by_tip || strat.matches || [];
                const allMatches = Array.isArray(matches) ? matches : Object.values(matches).flat();

                // Hydration Map (using data+partita as key)
                const globalMatchesMap = new Map((window.allMatches || []).map(m => {
                    const key = `${m.data}_${m.partita}`;
                    return [key, m];
                }));

                if (allMatches.length === 0) {
                    container.innerHTML = '<div class="text-gray-500 text-center py-8">Nessuna partita per questa strategia</div>';
                } else {
                    allMatches.forEach((m, idx) => {
                        // HYDRATE using data+partita key
                        const matchKey = `${m.data}_${m.partita}`;
                        const latest = globalMatchesMap.get(matchKey);
                        if (latest) {
                            m.risultato = latest.risultato || m.risultato;
                            m.esito = latest.esito || m.esito;
                        }

                        const card = document.createElement('div');

                        // SIMPLIFIED VIEW FOR COMPLETED MATCHES
                        if (m.risultato && m.esito) {
                            const isWin = m.esito === 'Vinto';
                            const isLoss = m.esito === 'Perso';
                            const bgColor = isWin ? 'bg-green-100 border-green-300' : isLoss ? 'bg-red-100 border-red-300' : 'bg-yellow-100 border-yellow-300';
                            const textColor = isWin ? 'text-green-900' : isLoss ? 'text-red-900' : 'text-yellow-900';

                            card.className = `p-4 rounded-lg shadow border-2 ${bgColor} transition-all`;
                            card.innerHTML = `
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-bold text-lg ${textColor}">${m.partita || m.match}</div>
                                        <div class="text-sm opacity-75 ${textColor}">${m.lega || m.league}</div>
                                    </div>
                                    <div class="text-right">
                                        <div class="text-2xl font-bold ${textColor}">${m.risultato}</div>
                                        <div class="text-sm font-bold uppercase tracking-wider ${textColor}">${m.esito}</div>
                                    </div>
                                </div>
                                <div class="mt-2 flex items-center gap-2">
                                    <span class="bg-white/50 px-2 py-1 rounded text-sm font-bold ${textColor}">${m.tip}</span>
                                    <span class="bg-white/50 px-2 py-1 rounded text-sm ${textColor}">@${m.quota}</span>
                                </div>
                            `;
                        } else {
                            // STANDARD DETAILED VIEW
                            card.className = 'bg-white p-4 rounded-lg shadow border border-gray-200 hover:shadow-md transition-all';

                            // Badges Logic
                            let indicationBadge = '';
                            if (m.indication) {
                                indicationBadge = `<span class="${m.indication.bg} ${m.indication.color} px-3 py-1 rounded-full text-xs font-bold">${m.indication.text}</span>`;
                            }

                            let betfairBadge = '';
                            if (m.betfairBadge && m.betfairBadge.text) {
                                betfairBadge = `<div class="mt-2 text-xs ${m.betfairBadge.color}">${m.betfairBadge.text}</div>`;
                            }

                            // Result Logic (Partial)
                            const resultBadge = m.risultato ? `<div class="text-sm font-bold bg-gray-100 px-2 py-1 rounded">${m.risultato}</div>` : '';
                            const esitoBadge = m.esito ? `<div class="px-2 py-1 rounded text-xs font-bold ${m.esito === 'Vinto' ? 'bg-green-100 text-green-800' : m.esito === 'Perso' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800'}">${m.esito}</div>` : '';

                            card.innerHTML = `
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-2xl font-bold text-purple-600">#${idx + 1}</span>
                                    <span class="bg-gradient-to-r from-yellow-400 to-orange-500 text-white px-4 py-1 rounded-full text-lg font-bold">
                                        ${m.score || 0}
                                    </span>
                                </div>
                                
                                <div class="flex justify-between items-start">
                                    <div>
                                        <div class="text-lg font-bold text-gray-800 mb-1">${m.partita || m.match}</div>
                                        <div class="text-sm text-gray-600 mb-2">${m.lega || m.league}</div>
                                    </div>
                                    <div class="flex flex-col items-end gap-1">
                                        ${resultBadge}
                                        ${esitoBadge}
                                    </div>
                                </div>

                                <div class="flex items-center gap-2 mb-2 flex-wrap">
                                    <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-semibold">${m.tip}</span>
                                    <span class="bg-gray-100 text-gray-800 px-2 py-1 rounded text-xs font-semibold">@${m.quota}</span>
                                    ${m.ora ? `<span class="bg-green-100 text-green-800 px-2 py-1 rounded text-xs font-semibold">üïê ${m.ora}</span>` : ''}
                                </div>
                                
                                ${indicationBadge ? `<div class="mb-2">${indicationBadge}</div>` : ''}
                                ${betfairBadge}
                                
                                ${m.teamStats && m.teamStats.home && m.teamStats.away ? `
                                    <div class="mt-3 pt-3 border-t border-gray-200">
                                        <div class="text-xs font-bold text-gray-700 mb-2">Statistiche Squadre:</div>
                                        <div class="grid grid-cols-2 gap-2 text-xs">
                                            <div class="bg-blue-50 p-2 rounded">
                                                <div class="font-semibold">Casa: ${m.teamStats.home.count}/${m.teamStats.home.total}</div>
                                                <div class="${m.teamStats.home.color === 'green' ? 'text-green-600' : m.teamStats.home.color === 'red' ? 'text-red-600' : 'text-yellow-600'} font-bold">
                                                    ${m.teamStats.home.percentage}%
                                                </div>
                                            </div>
                                            <div class="bg-blue-50 p-2 rounded">
                                                <div class="font-semibold">Trasferta: ${m.teamStats.away.count}/${m.teamStats.away.total}</div>
                                                <div class="${m.teamStats.away.color === 'green' ? 'text-green-600' : m.teamStats.away.color === 'red' ? 'text-red-600' : 'text-yellow-600'} font-bold">
                                                    ${m.teamStats.away.percentage}%
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                ` : ''}
                            `;
                        }

                        container.appendChild(card);
                    });
                }

                document.getElementById('ranking-strategies-list').classList.add('hidden');
                document.getElementById('ranking-matches-detail').classList.remove('hidden');
            }

            // Back button for ranking
            const rankingBackBtn = document.getElementById('ranking-back-btn');
            if (rankingBackBtn) {
                rankingBackBtn.addEventListener('click', () => {
                    document.getElementById('ranking-strategies-list').classList.remove('hidden');
                    document.getElementById('ranking-matches-detail').classList.add('hidden');
                });
            }

            async function handleSaveClientFilter() {
                const selectedKey = document.getElementById('client-filters-select').value;
                if (!selectedKey) {
                    showModal("Errore", "Seleziona un filtro client da modificare.");
                    return;
                }

                const filter = allClientFilters[selectedKey];
                if (!filter) return;

                // Capture current state from UI
                const currentLeagues = Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value);
                const currentProb = probabilitySliderEl.noUiSlider.get().map(v => parseInt(v));
                const currentOdds = oddsSliderEl.noUiSlider.get().map(v => parseFloat(v));
                const currentTips = Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip);

                try {
                    if (filter.type === 'preset') {
                        // Save COMPLETE filter configuration (leagues, tips, odds, prob)
                        const presetsDocRef = doc(db, "system", "client_presets");

                        const completeFilter = {
                            leagues: currentLeagues,
                            tips: currentTips,
                            odds: currentOdds,
                            prob: currentProb
                        };

                        await updateDoc(presetsDocRef, {
                            [selectedKey]: completeFilter,
                            lastUpdated: Date.now()
                        });

                        // Show loading indicator
                        const saveBtn = document.querySelector('#save-btn-strategies');
                        if (saveBtn) {
                            saveBtn.disabled = true;
                            saveBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Ricalcolo in corso...';
                        }

                        // TRIGGER RECALCULATION: When preset is modified, recalculate rankings for today
                        console.log(`[Admin] Preset ${selectedKey} modified, triggering recalculation...`);
                        const today = new Date().toISOString().split('T')[0];
                        const todayMatches = allMatches.filter(m => m.data === today && !m.risultato);

                        if (todayMatches.length > 0) {
                            await loadAllMatches(); // Ensure we have latest data
                            await calculateStrategyRankings(todayMatches, today);
                            console.log(`[Admin] Rankings recalculated after preset modification`);
                        }

                        // Restore button
                        if (saveBtn) {
                            saveBtn.disabled = false;
                            saveBtn.innerHTML = '<i class="fa-solid fa-save mr-2"></i>Salva';
                        }

                    } else if (filter.type === 'strategy') {
                        // Update system/client_strategies
                        const strategiesDocRef = doc(db, "system", "client_strategies");
                        // We need to update the specific field in the map
                        const updatedStrategy = {
                            leagues: currentLeagues,
                            probRange: currentProb,
                            oddsRange: currentOdds,
                            tips: currentTips
                        };

                        await updateDoc(strategiesDocRef, {
                            [selectedKey]: updatedStrategy
                        });

                        // TRIGGER RECALCULATION: When custom strategy is modified, recalculate rankings
                        console.log(`[Admin] Custom strategy ${selectedKey} modified, triggering recalculation...`);
                        const today = new Date().toISOString().split('T')[0];
                        const todayMatches = allMatches.filter(m => m.data === today && !m.risultato);

                        if (todayMatches.length > 0) {
                            await loadAllMatches();
                            await calculateStrategyRankings(todayMatches, today);
                            console.log(`[Admin] Rankings recalculated after strategy modification`);
                        }
                    }

                    showModal("Successo", `Filtro <b>${filter.name}</b> aggiornato e ranking ricalcolato!`);

                    // Reload to ensure local state is synced
                    await loadClientFiltersForAdmin();
                    document.getElementById('client-filters-select').value = selectedKey; // Restore selection

                } catch (e) {
                    console.error("Error saving client filter:", e);
                    showModal("Errore", `Impossibile salvare: ${e.message}`);
                }
            }

            async function handleDeleteClientFilter() {
                const selectedKey = document.getElementById('client-filters-select').value;
                if (!selectedKey) {
                    showModal("Errore", "Seleziona un filtro da eliminare.");
                    return;
                }

                if (!confirm(`Sei sicuro di voler eliminare il filtro client "${selectedKey}"?`)) return;

                try {
                    const filter = allClientFilters[selectedKey];
                    // Import deleteField if not available globally, but usually it is from firebase/firestore
                    // Assuming deleteField is available or we use null/undefined logic?
                    // Firestore requires deleteField() sentinel.
                    // Let's check imports. If not imported, we might need to add it.
                    // For now, let's try to just use update with deleteField().

                    const { deleteField } = await import("https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js");

                    if (filter.type === 'preset') {
                        const presetsDocRef = doc(db, "system", "client_presets");
                        await updateDoc(presetsDocRef, {
                            [selectedKey]: deleteField()
                        });
                    } else {
                        const strategiesDocRef = doc(db, "system", "client_strategies");
                        await updateDoc(strategiesDocRef, {
                            [selectedKey]: deleteField()
                        });
                    }
                    showModal("Successo", "Filtro eliminato.");
                    await loadClientFiltersForAdmin();
                } catch (e) {
                    console.error(e);
                    showModal("Errore", `Errore eliminazione: ${e.message}`);
                }
            }

            // Event Listeners for Client Filters
            document.getElementById('client-filters-select').addEventListener('change', handleClientFilterSelect);
            // document.getElementById('save-client-filter-btn').addEventListener('click', handleSaveClientFilter); // Removed in HTML
            document.getElementById('delete-client-filter-btn').addEventListener('click', handleDeleteClientFilter);


            // ==================== SAVED FILTERS (ADMIN) ====================
            const loadSavedFilters = async () => {
                const presetsCollection = collection(db, "presets");
                const snapshot = await getDocs(presetsCollection);
                savedFilters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data(), type: 'local' }));

                // Load Public Strategies for Ranking
                try {
                    const strategiesDoc = await getDoc(doc(db, "system", "client_strategies"));
                    if (strategiesDoc.exists()) {
                        const strategies = strategiesDoc.data();
                        Object.keys(strategies).forEach(key => {
                            savedFilters.push({
                                id: key,
                                name: strategies[key].name || key,
                                state: strategies[key], // Public strategy structure
                                type: 'public'
                            });
                        });
                    }
                } catch (e) {
                    console.error("Error loading public strategies for ranking:", e);
                }

                // Popola dropdown Dashboard (Local Only - kept as is for "Test Locale")
                const localFilters = savedFilters.filter(f => f.type === 'local');
                const select = document.getElementById('saved-strategies-select');
                if (select) {
                    select.innerHTML = '<option value="">Seleziona...</option>' + localFilters.map(f => `<option value="${f.id}">${f.name}</option>`).join('');
                }

                // Popola dropdown Ranking con TUTTO (Local + Public + Special + Standard Presets)
                const rankingSelect = document.getElementById('ranking-filter-select');
                if (rankingSelect) {
                    // Fetch Standard Presets first
                    let standardPresets = [];
                    try {
                        const presetsDoc = await getDoc(doc(db, "system", "client_presets"));
                        if (presetsDoc.exists()) {
                            const data = presetsDoc.data();
                            standardPresets = Object.keys(data).map(key => ({
                                id: key,
                                name: data[key].name || key,
                                type: 'preset'
                            }));
                        }
                    } catch (e) {
                        console.error("Error loading standard presets:", e);
                    }

                    rankingSelect.innerHTML = '<option value="">Nessun filtro (tutte le partite)</option>' +
                        '<option value="BEST_05HT" style="background: linear-gradient(to right, #fef3c7, #fde68a); font-weight: bold;">‚ö° BEST 0.5 HT (Auto)</option>' +
                        standardPresets.map(f => `<option value="${f.id}">üîí ${f.name}</option>`).join('') +
                        savedFilters
                            .filter(f => !standardPresets.some(sp => sp.id === f.id)) // Deduplicate
                            .map(f => {
                                const icon = f.type === 'public' ? 'üåç' : 'üë§';
                                return `<option value="${f.id}">${icon} ${f.name}</option>`;
                            }).join('');
                }
            };

            const handlePublishStrategy = async () => {
                const filterName = document.getElementById('new-strategy-name').value.trim();
                if (!filterName) {
                    showModal("Errore", "Inserisci nome strategia.", () => { });
                    return;
                }

                // Capture state
                const filterState = {
                    name: filterName,
                    leagues: Array.from(leagueFiltersGrid.querySelectorAll('input.league-checkbox:checked')).map(cb => cb.value),
                    tips: Array.from(tipFiltersContainer.querySelectorAll('.tip-button.active')).map(btn => btn.dataset.tip),
                    probRange: probabilitySliderEl.noUiSlider.get().map(v => parseInt(v)),
                    oddsRange: oddsSliderEl.noUiSlider.get().map(v => parseFloat(v)),
                    lastUpdated: Date.now()
                };

                try {
                    // Generate ID from name (sanitize)
                    const strategyId = filterName.toLowerCase().replace(/[^a-z0-9]/g, '_');

                    const strategiesDocRef = doc(db, "system", "client_strategies");
                    await setDoc(strategiesDocRef, {
                        [strategyId]: filterState
                    }, { merge: true });

                    // AUTO-RECALCOLA per le partite di oggi
                    const today = new Date().toISOString().split('T')[0];
                    const todayMatches = allMatches.filter(m => m.data === today && !m.risultato);

                    if (todayMatches.length > 0) {
                        console.log(`[handlePublishStrategy] Auto-recalc rankings for ${todayMatches.length} matches of today...`);
                        await calculateStrategyRankings(todayMatches, today);
                        showModal("‚úÖ Strategia Pubblicata",
                            `Strategia "${filterName}" pubblicata e ranking aggiornato per ${todayMatches.length} partite di oggi!`);
                    } else {
                        showModal("Successo", `Strategia "${filterName}" pubblicata sul Client!`, () => { });
                    }

                    document.getElementById('new-strategy-name').value = '';
                    await loadClientFiltersForAdmin();
                    await loadSavedFilters(); // Reload to update savedFilters array
                } catch (e) {
                    console.error(e);
                    showModal("Errore", `Errore pubblicazione: ${e.message}`, () => { });
                }
            };

            const handleSaveFilter = async () => {
                // ... (Old Local Save - kept for reference or future use if we add a button)
                // For now, we use handlePublishStrategy for the main UI button
            };

            const handleLoadFilter = () => {

                const selectedId = document.getElementById('saved-strategies-select').value;
                if (!selectedId) return;
                const selectedFilter = savedFilters.find(f => f.id === selectedId);
                if (!selectedFilter) return;

                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));

                selectedFilter.state.leagues.forEach(league => {
                    const cb = leagueFiltersGrid.querySelector(`input.league-checkbox[value="${league}"]`);
                    if (cb) cb.checked = true;
                });
                selectedFilter.state.tips.forEach(tip => {
                    const btn = tipFiltersContainer.querySelector(`.tip-button[data-tip="${tip}"]`);
                    if (btn) btn.classList.add('active');
                });

                probabilitySliderEl.noUiSlider.set(selectedFilter.state.prob);
                oddsSliderEl.noUiSlider.set(selectedFilter.state.odds);
                filterDateStart.value = selectedFilter.state.startDate;
                filterDateEnd.value = selectedFilter.state.endDate;

                applyFiltersAndRender();
            };

            const handleDeleteFilter = async () => {
                const selectedId = document.getElementById('saved-strategies-select').value;
                if (!selectedId) return;
                if (!confirm('Eliminare questa strategia?')) return;
                try {
                    await deleteDoc(doc(db, "presets", selectedId));
                    showModal("Successo", "Strategia eliminata!", () => { });
                    await loadSavedFilters();
                } catch (e) {
                    showModal("Errore", `Errore: ${e.message}`, () => { });
                }
            };

            // saveFilterBtn.addEventListener('click', handleSaveFilter); // OLD LOCAL SAVE
            saveFilterBtn.addEventListener('click', handlePublishStrategy); // NEW PUBLIC SAVE
            loadFilterBtn.addEventListener('click', handleLoadFilter);
            deleteFilterBtn.addEventListener('click', handleDeleteFilter);

            // Client Management Listeners
            document.getElementById('update-client-filter-btn').addEventListener('click', handleSaveClientFilter);

            // ==================== RESET FILTERS ====================
            resetLeaguesBtn.addEventListener('click', () => {
                leagueFiltersGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
                applyFiltersAndRender();
            });

            resetTipsBtn.addEventListener('click', () => {
                tipFiltersContainer.querySelectorAll('.tip-button').forEach(btn => btn.classList.remove('active'));
                applyFiltersAndRender();
            });

            resetFiltersBtn.addEventListener('click', () => {
                filterDateStart.value = '';
                filterDateEnd.value = '';
                searchInput.value = '';
                resetLeaguesBtn.click();
                resetTipsBtn.click();
                probabilitySliderEl.noUiSlider.set([0, 100]);
                oddsSliderEl.noUiSlider.set([1.0, 10.0]);
                document.getElementById('saved-strategies-select').value = ""; // Reset Local Dropdown
                document.getElementById('client-filters-select').value = ""; // Reset Public Dropdown
                applyFiltersAndRender();
            });

            // ==================== EXPORT ====================
            exportFilteredBtn.addEventListener('click', () => {
                if (filteredMatches.length === 0) {
                    showModal("Errore", "Nessun dato da esportare.", () => { });
                    return;
                }
                const headers = ['id', 'data', 'lega', 'partita', 'risultato', 'probabilita', 'mercato', 'tip', 'quota', 'esito'];
                const csv = Papa.unparse(filteredMatches.map(d => ({ ...d, quota: String(d.quota).replace('.', ',') })), { columns: headers });
                const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = 'tipster_filtrati.csv';
                link.click();
            });

            // ==================== TARGET ODDS SYSTEM ====================

            // Estrai odds da info_ht
            function extractHtOdds(infoHt) {
                if (!infoHt || infoHt.trim() === '') return null;

                const oddsMatch = infoHt.match(/(\d+)%/);
                if (oddsMatch) {
                    return parseFloat(oddsMatch[1]);
                }
                return null;
            }

            // Stima range odds basato su correlazioni
            function estimateOddsRange(tipAttuale, oddsAttuale, tipTarget) {
                // Trova range nella lookup table
                const correlations = ODDS_CORRELATIONS[tipAttuale]?.[tipTarget];
                if (!correlations) {
                    // Fallback: calcolo matematico
                    const probAttuale = 1 / oddsAttuale;
                    const probTarget = probAttuale * 0.70; // Stima conservativa
                    const oddsTarget = 1 / probTarget;

                    return {
                        min: Math.round((oddsTarget * 0.90) * 100) / 100,
                        max: Math.round((oddsTarget * 1.10) * 100) / 100,
                        avg: oddsTarget
                    };
                }

                // Cerca range corretto
                for (let range in correlations) {
                    const [minRange, maxRange] = range.split('-').map(Number);
                    if (oddsAttuale >= minRange && oddsAttuale <= maxRange) {
                        const [minOdds, maxOdds] = correlations[range];
                        return {
                            min: minOdds,
                            max: maxOdds,
                            avg: (minOdds + maxOdds) / 2
                        };
                    }
                }

                // Fallback se non trovato range esatto
                const probAttuale = 1 / oddsAttuale;
                const probTarget = probAttuale * 0.70;
                const oddsTarget = 1 / probTarget;

                return {
                    min: Math.round((oddsTarget * 0.90) * 100) / 100,
                    max: Math.round((oddsTarget * 1.10) * 100) / 100,
                    avg: oddsTarget
                };
            }

            // Calcola green con odds precise
            function calculateGreen(backStake, backOdds, layOdds) {
                const liability = backStake * (layOdds - 1);
                const backProfit = backStake * (backOdds - 1);

                // Green se lay vince (back perde)
                const greenLay = liability;
                // Green se back vince (lay perde) 
                const greenBack = backProfit - liability;

                // Usa il minore per essere conservativi
                return Math.min(greenLay, greenBack);
            }

            // Calcola green range con odds stimate
            function calculateGreenRange(backStake, backOdds, layOddsMin, layOddsMax) {
                const greenMin = calculateGreen(backStake, backOdds, layOddsMin);
                const greenMax = calculateGreen(backStake, backOdds, layOddsMax);

                return {
                    min: greenMin,
                    max: greenMax,
                    avg: (greenMin + greenMax) / 2
                };
            }

            // ==================== MATCH TIMES SYSTEM ====================

            // Carica cache orari da Firebase
            // Ottieni orario da API Football
            async function getTimeFromAPIFootball(date, teamHome, teamAway) {
                if (apiCallsToday >= 90) {
                    console.warn("API call limit reached today");
                    return null;
                }

                try {
                    const response = await fetch(`${API_FOOTBALL_URL}/fixtures?date=${date}&team=${teamHome}`, {
                        headers: {
                            'x-rapidapi-key': API_FOOTBALL_KEY,
                            'x-rapidapi-host': 'v3.api-football.com'
                        }
                    });

                    if (!response.ok) {
                        console.error("API Football error:", response.status);
                        return null;
                    }

                    const data = await response.json();
                    apiCallsToday++;

                    if (data.response && data.response.length > 0) {
                        // Cerca match che contiene entrambe le squadre
                        const match = data.response.find(m => {
                            const home = normalizeKey(m.teams.home.name);
                            const away = normalizeKey(m.teams.away.name);
                            const searchHome = normalizeKey(teamHome);
                            const searchAway = normalizeKey(teamAway);

                            return (home.includes(searchHome) || searchHome.includes(home)) &&
                                (away.includes(searchAway) || searchAway.includes(away));
                        });

                        if (match && match.fixture && match.fixture.date) {
                            // Converti UTC a ora italiana (UTC+1 o UTC+2)
                            const utcDate = new Date(match.fixture.date);
                            const italianTime = new Date(utcDate.getTime() + (2 * 60 * 60 * 1000)); // UTC+2 per ora solare

                            const hours = String(italianTime.getHours()).padStart(2, '0');
                            const minutes = String(italianTime.getMinutes()).padStart(2, '0');

                            return `${hours}:${minutes}`;
                        }
                    }

                    return null;
                } catch (e) {
                    console.error("API Football fetch error:", e);
                    return null;
                }
            }

            // Ottieni orario match (usa cache -> API)
            async function getMatchTime(date, match) {
                // 1. Prova cache Firebase
                const cached = getTimeFromCache(date, match);
                if (cached) return cached;

                // 2. Prova bulk cache (localStorage)
                const bulkTime = getTimeFromBulkCache(date, match);
                if (bulkTime) {
                    // Salva in cache Firebase per prossime volte
                    await saveTimeToCache(date, match, bulkTime);
                    return bulkTime;
                }

                // 3. Fallback: chiamata API singola (non dovrebbe servire)
                const teams = match.split(' - ');
                if (teams.length !== 2) return null;

                const teamHome = teams[0].trim();
                const teamAway = teams[1].trim();

                const time = await getTimeFromAPIFootball(date, teamHome, teamAway);

                if (time) {
                    await saveTimeToCache(date, match, time);
                }

                return time;
            }

            // ==================== POISSON ODDS CALCULATOR ====================

            // Calcola probabilit√† Poisson
            function poissonProbability(lambda, k) {
                let prob = Math.exp(-lambda);
                for (let i = 1; i <= k; i++) {
                    prob *= lambda / i;
                }
                return prob;
            }

            // Stima lambda da quota esistente
            function estimateLambda(tip, quota, prob) {
                // Usa probabilit√† reale per calcolo accurato
                const impliedProb = prob / 100;

                // Calcolo matematico basato su distribuzione Poisson
                if (tip === '+0.5') {
                    // P(X >= 1) = impliedProb
                    // Lambda = -ln(1 - impliedProb)
                    return -Math.log(1 - impliedProb);
                } else if (tip === '+1.5') {
                    // P(X >= 2) = impliedProb
                    // Approssimazione: lambda ‚âà 1.5 + (impliedProb - 0.5) * 3
                    const baseLambda = 2.0;
                    const adjustment = (impliedProb - 0.75) * 2;
                    return Math.max(1.5, Math.min(4.0, baseLambda + adjustment));
                } else if (tip === '+2.5') {
                    const baseLambda = 3.0;
                    const adjustment = (impliedProb - 0.60) * 2;
                    return Math.max(2.5, Math.min(5.0, baseLambda + adjustment));
                } else if (tip === '+3.5') {
                    const baseLambda = 4.0;
                    const adjustment = (impliedProb - 0.45) * 2;
                    return Math.max(3.5, Math.min(6.0, baseLambda + adjustment));
                }

                // Default fallback
                return 2.5;
            }

            // Calcola quota target con Poisson
            function calculatePoissonOdds(tipCurrent, quotaCurrent, probCurrent, tipTarget) {
                const lambda = estimateLambda(tipCurrent, quotaCurrent, probCurrent);

                let targetProb = 0;

                if (tipTarget === '+0.5') {
                    // P(X >= 1) = 1 - P(X = 0)
                    targetProb = 1 - poissonProbability(lambda, 0);
                } else if (tipTarget === '+1.5') {
                    // P(X >= 2) = 1 - P(X=0) - P(X=1)
                    targetProb = 1 - poissonProbability(lambda, 0) - poissonProbability(lambda, 1);
                } else if (tipTarget === '+2.5') {
                    // P(X >= 3)
                    targetProb = 1 - poissonProbability(lambda, 0) - poissonProbability(lambda, 1) - poissonProbability(lambda, 2);
                } else if (tipTarget === '+3.5') {
                    // P(X >= 4)
                    let sum = 0;
                    for (let k = 0; k <= 3; k++) {
                        sum += poissonProbability(lambda, k);
                    }
                    targetProb = 1 - sum;
                } else if (tipTarget === '-2.5') {
                    // P(X < 3) = P(X=0) + P(X=1) + P(X=2)
                    targetProb = poissonProbability(lambda, 0) + poissonProbability(lambda, 1) + poissonProbability(lambda, 2);
                }

                if (targetProb <= 0 || targetProb >= 1) return null;

                const targetOdds = 1 / targetProb;

                return {
                    odds: targetOdds,
                    prob: Math.round(targetProb * 100),
                    source: 'poisson'
                };
            }

            // ==================== AI TRADING ADVISOR ====================

            // V3.4.5.1 - BOLLINO BETFAIR INTELLIGENTE
            // ==================== TRADING INDICATIONS ====================
            function getTradingIndication(score, quota) {
                if (score >= 85) return { text: "üíé DIAMOND", color: "text-blue-400", bg: "bg-blue-900/50" };
                if (score >= 75) return { text: "‚úÖ VALUE", color: "text-green-400", bg: "bg-green-900/50" };
                if (score >= 60) return { text: "‚öñÔ∏è BALANCED", color: "text-yellow-400", bg: "bg-yellow-900/50" };
                return { text: "‚ö†Ô∏è RISKY", color: "text-red-400", bg: "bg-red-900/50" };
            }

            // ==================== FILTER MATCHES HELPER ====================
            function filterMatchesByStrategy(matches, filter) {
                if (!filter) return matches;
                return matches.filter(m => {
                    // 1. Leagues
                    if (filter.leagues && filter.leagues.length > 0) {
                        const matchLega = normalizeLega(m.lega);
                        if (!filter.leagues.includes(matchLega)) return false;
                    }
                    // 2. Tips
                    if (filter.tips && filter.tips.length > 0) {
                        if (!filter.tips.includes(m.tip)) return false;
                    }
                    // 3. Odds
                    if (filter.odds && Array.isArray(filter.odds)) {
                        const q = parseFloat(m.quota);
                        if (q < filter.odds[0] || q > filter.odds[1]) return false;
                    }
                    // 4. Prob (HT or FT depending on strategy - usually FT for standard filters)
                    // Note: Custom strategies might have specific prob logic, simplified here
                    return true;
                });
            }

            function generateBetfairBadge(match, is05HT = false, team1Stats = null, team2Stats = null) {
                const tip = (match.tip || '').trim().toUpperCase();
                const score = match.score || 0;

                // Estrai HT prob se disponibile
                let htProb = 0;
                if (match.info_ht && match.info_ht.trim() !== '') {
                    const htMatch = match.info_ht.match(/(\d+)%/);
                    if (htMatch) htProb = parseInt(htMatch[1]);
                }

                let betfairBadge = null;

                // SPECIALE: Filtro BEST 0.5 HT ‚Üí Badge dinamico basato su prolificit√†
                if (is05HT && htProb >= 70 && score >= 50 && team1Stats && team2Stats) {
                    // Calcola prolificit√† media squadre per Over 2.5
                    const team1Over25 = team1Stats.total >= 5 ? (team1Stats.count / team1Stats.total) * 100 : 0;
                    const team2Over25 = team2Stats.total >= 5 ? (team2Stats.count / team2Stats.total) * 100 : 0;
                    const avgProlificita = (team1Over25 + team2Over25) / 2;

                    // Badge dinamico basato su prolificit√†
                    if (avgProlificita >= 75) {
                        betfairBadge = {
                            text: 'Trading Back Over 2.5',
                            color: 'bg-yellow-100 text-yellow-700 border-yellow-300'
                        };
                    } else if (avgProlificita >= 60) {
                        betfairBadge = {
                            text: 'Trading Back Over 1.5',
                            color: 'bg-yellow-100 text-yellow-700 border-yellow-300'
                        };
                    } else if (avgProlificita < 50 && avgProlificita >= 30) {
                        betfairBadge = {
                            text: 'Trading Lay Under 2.5',
                            color: 'bg-yellow-100 text-yellow-700 border-yellow-300'
                        };
                    }
                    // Se < 30% o 50-60% ‚Üí nessun badge (poco affidabile)
                }
                // OVER con HT alto + score buono ‚Üí Back Over 2.5
                else if (tip.startsWith('+') && htProb >= 70 && score >= 35) {
                    betfairBadge = {
                        text: 'Trading Back Over 2.5',
                        color: 'bg-purple-100 text-purple-700 border-purple-300'
                    };
                }
                // OVER con squadre molto prolifiche ‚Üí Back Over 2.5
                else if (tip.startsWith('+') && score >= 45) {
                    betfairBadge = {
                        text: 'Trading Back Over 2.5',
                        color: 'bg-purple-100 text-purple-700 border-purple-300'
                    };
                }
                // UNDER con score buono ‚Üí Lay Over 2.5
                else if (tip.startsWith('-') && score >= 40) {
                    betfairBadge = {
                        text: 'Trading Lay Over 2.5',
                        color: 'bg-purple-100 text-purple-700 border-purple-300'
                    };
                }
                // 1X2 / DC equilibrata ‚Üí Lay The Draw
                else if ((tip.includes('X') || tip.includes('12')) && score >= 30) {
                    betfairBadge = {
                        text: 'Trading Lay The Draw',
                        color: 'bg-purple-100 text-purple-700 border-purple-300'
                    };
                }

                return betfairBadge;
            }

            // ==================== TOOLTIP SYSTEM ====================

            function generateScoreTooltip(match, scoreDetails) {
                return `
                    <div class="text-left">
                        <div class="font-bold mb-2 text-center">SCORE BREAKDOWN</div>
                        <div class="text-sm space-y-1">
                            <div>Lega: <span class="font-semibold">+${scoreDetails.legaScore || 0}</span></div>
                            <div>Tip: <span class="font-semibold">+${scoreDetails.tipScore || 0}</span></div>
                            <div>Prob: <span class="font-semibold">+${scoreDetails.probScore || 0}</span> (${match.probabilita}%)</div>
                            ${scoreDetails.htBonus ? `<div>HT Boost: <span class="font-semibold text-green-600">+${scoreDetails.htBonus}</span></div>` : ''}
                            <div class="border-t pt-1 mt-1">Totale: <span class="font-bold text-lg">${scoreDetails.totalScore || 0}</span></div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t text-gray-600">
                            <div>80+ = ECCELLENTE üî•</div>
                            <div>60-79 = BUONO ‚ö°</div>
                            <div>40-59 = MEDIO üí°</div>
                            <div>&lt;40 = BASSO ‚ö†Ô∏è</div>
                        </div>
                    </div>
                `;
            }

            function generateStatsTooltip(homeWins, awayWins) {
                const homeColor = homeWins >= 7 ? 'üü¢' : homeWins >= 4 ? 'üü°' : 'üî¥';
                const awayColor = awayWins >= 7 ? 'üü¢' : awayWins >= 4 ? 'üü°' : 'üî¥';

                return `
                    <div class="text-left">
                        <div class="font-bold mb-2 text-center">FORM SQUADRE</div>
                        <div class="text-sm space-y-1">
                            <div>${homeColor} Casa: <span class="font-semibold">${homeWins} W</span> ultimi 10</div>
                            <div>${awayColor} Trasferta: <span class="font-semibold">${awayWins} W</span> ultimi 10</div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t text-gray-600">
                            <div>üü¢ 7+ = OTTIMA</div>
                            <div>üü° 4-6 = MEDIA</div>
                            <div>üî¥ 0-3 = SCARSA</div>
                        </div>
                    </div>
                `;
            }

            // ==================== HT MERGE FUNCTIONS ====================
            function normalizeKey(str) {
                // Normalizza stringa per matching squadre (rimuove accenti, lowercase, solo alfanumerici)
                return str.normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "")
                    .toLowerCase()
                    .replace(/[^a-z0-9]/g, "");
            }

            function mergeMainWithHT() {
                // Se non ho dati main, non posso fare merge
                if (rawMainData.length === 0) return rawMainData;

                // Se non ho dati HT, ritorno main senza modifiche
                if (rawHtData.length === 0) return rawMainData;

                // Creo mappa HT: chiave = squadre normalizzate
                const htMap = {};
                rawHtData.forEach(htRow => {
                    const partita = String(htRow.Partita || '').trim();
                    if (!partita) return;

                    // Normalizzo nome partita (Home + Away senza spazi/accenti)
                    const normalized = normalizeKey(partita);

                    // Salvo prob e quota HT
                    const probHT = parseInt(String(htRow['Probabilit√†'] || htRow.Probabilit√† || '0').replace('%', '').trim()) || 0;
                    const quotaHT = parseFloat(String(htRow.Quota || '0').replace(',', '.').trim()) || 0;

                    if (probHT > 0 && quotaHT > 0) {
                        htMap[normalized] = { prob: probHT, quota: quotaHT.toFixed(2) };
                    }
                });

                // Arricchisco Main con info HT
                return rawMainData.map(mainRow => {
                    const partita = String(mainRow.Partita || '').trim();
                    const normalized = normalizeKey(partita);

                    // Cerco match in HT map
                    if (htMap[normalized]) {
                        const htInfo = htMap[normalized];
                        mainRow.info_ht = `${htInfo.prob}% (@${htInfo.quota})`;
                    } else {
                        mainRow.info_ht = '';
                    }

                    return mainRow;
                });
            }

            // ==================== UPLOAD TIPS ====================
            document.getElementById('tips-csv-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;

                // Mostra feedback visivo
                const statusEl = document.getElementById('tips-file-status');
                const nameEl = document.getElementById('tips-file-name');
                statusEl.classList.remove('hidden');
                nameEl.textContent = file.name;

                const reader = new FileReader();
                reader.onload = async function (event) {
                    const parsed = parseCSV(event.target.result);
                    tipsFileCount = parsed.length; // UPDATE GLOBAL COUNT
                    const matchDate = document.getElementById('tips-date').value;
                    if (!matchDate) {
                        alert('Seleziona data!');
                        return;
                    }

                    // Salvo in rawMainData
                    rawMainData = parsed;

                    // Faccio merge con HT se disponibile
                    const mergedData = mergeMainWithHT();

                    // Conta quante partite hanno HT dopo merge
                    const htCount = mergedData.filter(m => m.info_ht && m.info_ht.trim() !== '').length;
                    if (htCount > 0) {
                        htFileCount = htCount; // Use matched count if available
                        const htStatusEl = document.getElementById('ht-file-status');
                        const htCountEl = document.getElementById('ht-match-count');
                        htStatusEl.classList.remove('hidden');
                        htCountEl.textContent = htCount;
                    }

                    // Processo i dati merged
                    await processAndPreviewCSV(mergedData, matchDate, 'tips');
                };
                reader.readAsText(file);
            });

            // ==================== UPLOAD HT ====================
            document.getElementById('tips-ht-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) {
                    // Se rimuovo file HT, resetto
                    rawHtData = [];
                    document.getElementById('ht-file-status').classList.add('hidden');
                    return;
                }

                // Mostra feedback visivo
                const statusEl = document.getElementById('ht-file-status');
                const nameEl = document.getElementById('ht-file-name');
                const countEl = document.getElementById('ht-match-count');
                statusEl.classList.remove('hidden');
                nameEl.textContent = file.name;

                const reader = new FileReader();
                reader.onload = async function (event) {
                    const parsed = parseCSV(event.target.result);

                    // Salvo in rawHtData
                    rawHtData = parsed;
                    htFileCount = parsed.length; // UPDATE GLOBAL COUNT
                    countEl.textContent = parsed.length;

                    // Se ho gi√† caricato Main, rifaccio merge
                    if (rawMainData.length > 0) {
                        const matchDate = document.getElementById('tips-date').value;
                        if (matchDate) {
                            const mergedData = mergeMainWithHT();

                            // Conta quante partite hanno HT dopo merge
                            const htCount = mergedData.filter(m => m.info_ht && m.info_ht.trim() !== '').length;
                            htFileCount = htCount; // Use matched count
                            countEl.textContent = htCount;

                            await processAndPreviewCSV(mergedData, matchDate, 'tips');
                        }
                    }
                };
                reader.readAsText(file);
            });

            // ==================== UPLOAD RISULTATI ====================
            document.getElementById('results-csv-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async function (event) {
                    const parsed = parseCSV(event.target.result);
                    const matchDate = document.getElementById('results-date').value;
                    if (!matchDate) {
                        alert('Seleziona data!');
                        return;
                    }
                    await processAndPreviewCSV(parsed, matchDate, 'results');
                };
                reader.readAsText(file);
            });

            // ==================== UPLOAD BACKUP / TOTALE ====================
            document.getElementById('backup-csv-file').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;

                const statusEl = document.getElementById('backup-file-status');
                const nameEl = document.getElementById('backup-file-name');
                const previewEl = document.getElementById('backup-upload-preview');

                statusEl.classList.remove('hidden');
                nameEl.textContent = file.name;
                previewEl.classList.remove('hidden');
                previewEl.innerHTML = '<div class="text-center text-gray-500"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Analisi file in corso...</div>';

                const reader = new FileReader();
                reader.onload = async function (event) {
                    const parsed = parseCSV(event.target.result);
                    await processBackupData(parsed);
                };
                reader.readAsText(file);
            });

            async function processBackupData(parsedData) {
                const previewEl = document.getElementById('backup-upload-preview');
                let updates = 0;
                let creates = 0;
                let errors = 0;
                const batchOps = [];

                // Normalizza chiavi per confronto
                const normalizeKey = (str) => String(str || '').trim().toLowerCase().replace(/\s+/g, ' ');

                for (const row of parsedData) {
                    // Skip empty rows
                    if (!row.Lega || !row.Partita) continue;

                    const matchData = {
                        data: row.data || row.Data, // Supporta lowercase header
                        lega: normalizeLega(row.lega || row.Lega),
                        partita: String(row.partita || row.Partita).trim(),
                        risultato: String(row.risultato || row.Risultato || '').trim(),
                        probabilita: parseInt(String(row.probabilita || row.Probabilit√† || row.Probabilita).replace('%', '').trim()) || 0,
                        mercato: String(row.mercato || row.Mercato).trim(),
                        tip: String(row.tip || row.Tip).trim(),
                        quota: parseFloat(String(row.quota || row.Quota).replace(',', '.').trim()) || 0,
                        esito: String(row.esito || row.Esito || '').trim(),
                        info_ht: String(row.info_ht || '').trim()
                    };

                    // Skip invalid
                    if (!matchData.data || !matchData.lega || !matchData.partita) {
                        errors++;
                        continue;
                    }

                    // Calcola esito se mancante ma c'√® risultato
                    if (!matchData.esito && matchData.risultato) {
                        matchData.esito = calculateOutcome(matchData);
                    }

                    // Cerca match esistente con strategia "Smart Matching"
                    let existingMatch = null;

                    // 1. Cerca per ID (se presente nel CSV - Future Proof)
                    if (row.id || row.ID || row.Id) {
                        const searchId = String(row.id || row.ID || row.Id).trim();
                        existingMatch = allMatches.find(m => m.id === searchId);
                    }

                    // 2. Cerca per Chiave Esatta (Data + Lega + Partita + Tip)
                    if (!existingMatch) {
                        existingMatch = allMatches.find(m =>
                            m.data === matchData.data &&
                            normalizeKey(m.lega) === normalizeKey(matchData.lega) &&
                            normalizeKey(m.partita) === normalizeKey(matchData.partita) &&
                            normalizeKey(m.tip) === normalizeKey(matchData.tip)
                        );
                    }

                    // 3. Cerca ignorando la LEGA (Data + Partita + Tip)
                    // Risolve il caso: correzione "EU-KOR" -> "AS-KOR"
                    if (!existingMatch) {
                        existingMatch = allMatches.find(m =>
                            m.data === matchData.data &&
                            normalizeKey(m.partita) === normalizeKey(matchData.partita) &&
                            normalizeKey(m.tip) === normalizeKey(matchData.tip)
                        );
                    }

                    if (existingMatch) {
                        // UPDATE
                        updates++;
                        // Mantieni ID originale
                        batchOps.push({ type: 'update', id: existingMatch.id, data: matchData });
                    } else {
                        // CREATE
                        creates++;
                        batchOps.push({ type: 'create', data: matchData });
                    }
                }

                // Preview UI
                previewEl.innerHTML = `
                    <div class="space-y-4">
                        <div class="grid grid-cols-3 gap-4 text-center">
                            <div class="bg-blue-100 p-3 rounded-lg">
                                <div class="text-2xl font-bold text-blue-700">${updates}</div>
                                <div class="text-xs text-blue-600">Da Aggiornare</div>
                            </div>
                            <div class="bg-green-100 p-3 rounded-lg">
                                <div class="text-2xl font-bold text-green-700">${creates}</div>
                                <div class="text-xs text-green-600">Da Creare</div>
                            </div>
                            <div class="bg-red-100 p-3 rounded-lg">
                                <div class="text-2xl font-bold text-red-700">${errors}</div>
                                <div class="text-xs text-red-600">Errori/Ignorati</div>
                            </div>
                        </div>
                        <button id="confirm-backup-upload-btn" class="w-full bg-orange-600 text-white py-3 rounded-lg font-bold hover:bg-orange-700 transition-colors">
                            <i class="fa-solid fa-cloud-upload-alt mr-2"></i>Conferma Caricamento Massivo
                        </button>
                    </div>
                `;

                // Attach event listener to the new button
                document.getElementById('confirm-backup-upload-btn').onclick = () => executeBatchOps(batchOps);
            }

            async function executeBatchOps(ops) {
                const btn = document.getElementById('confirm-backup-upload-btn');
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Elaborazione in corso...';

                try {
                    const batchSize = 400; // Safe limit
                    const chunks = [];
                    for (let i = 0; i < ops.length; i += batchSize) {
                        chunks.push(ops.slice(i, i + batchSize));
                    }

                    let processed = 0;
                    for (const chunk of chunks) {
                        const batch = writeBatch(db);

                        chunk.forEach(op => {
                            if (op.type === 'update') {
                                const ref = doc(db, "matches", op.id);
                                batch.update(ref, op.data);
                            } else {
                                const ref = doc(collection(db, "matches"));
                                batch.set(ref, op.data);
                            }
                        });

                        await batch.commit();
                        processed += chunk.length;
                        btn.innerHTML = `<i class="fa-solid fa-spinner fa-spin mr-2"></i>Elaborati ${processed} di ${ops.length}...`;
                    }


                    // Update Metadata Timestamp
                    try {
                        await setDoc(doc(db, "system", "metadata"), { lastUpdated: Date.now() }, { merge: true });
                    } catch (metaErr) {
                        console.warn("Could not update metadata timestamp (permissions?):", metaErr);
                    }

                    btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Caricamento Completato!';
                    btn.classList.remove('bg-orange-600', 'hover:bg-orange-700');
                    btn.classList.add('bg-gray-500', 'cursor-not-allowed');

                    alert(`Operazione completata! ${processed} record elaborati.`);
                    location.reload();

                } catch (error) {
                    console.error("Batch error:", error);
                    alert("Errore durante il caricamento: " + error.message);
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-exclamation-triangle mr-2"></i>Riprova';
                }
            }

            // ==================== CALCULATE STRATEGY RANKINGS ====================
            async function calculateStrategyRankings(matchesForDate, targetDate) {
                console.log(`[calculateStrategyRankings] Calculating rankings for ${matchesForDate.length} matches on ${targetDate}`);

                const results = {};

                // Collect ALL strategies (Standard Presets + savedFilters + Public)
                const allStrategiesMap = {};

                // 1. Load Standard Presets from client_presets (use saved configurations)
                // This ensures that manual modifications are respected!
                try {
                    const presetsDoc = await getDoc(doc(db, "system", "client_presets"));
                    if (presetsDoc.exists()) {
                        const presets = presetsDoc.data();

                        // Helper to extract filter data (handles both old array format and new object format)
                        const getFilterData = (presetData) => {
                            if (!presetData) return { leagues: [], tips: [], odds: [1.0, 10.0], prob: [0, 100] };
                            if (Array.isArray(presetData)) {
                                // Old format: just array of leagues
                                return { leagues: presetData, tips: [], odds: [1.0, 10.0], prob: [0, 100] };
                            } else if (typeof presetData === 'object') {
                                // New format: complete filter object
                                return {
                                    leagues: presetData.leagues || [],
                                    tips: presetData.tips || [],
                                    odds: presetData.odds || [1.0, 10.0],
                                    prob: presetData.prob || [0, 100]
                                };
                            }
                            return { leagues: [], tips: [], odds: [1.0, 10.0], prob: [0, 100] };
                        };

                        // ALL
                        const allFilter = getFilterData(presets.all);
                        allStrategiesMap['all'] = {
                            name: 'üìä ALL',
                            leagues: allFilter.leagues,
                            tips: allFilter.tips,
                            odds: allFilter.odds,
                            prob: allFilter.prob,
                            type: 'all'
                        };

                        // WINRATE 80%
                        const winrate80Filter = getFilterData(presets.winrate_80);
                        allStrategiesMap['winrate_80'] = {
                            name: 'üî• WINRATE 80%',
                            leagues: winrate80Filter.leagues,
                            tips: winrate80Filter.tips,
                            odds: winrate80Filter.odds,
                            prob: winrate80Filter.prob,
                            type: 'winrate_80'
                        };

                        // ITALIA - USE SAVED CONFIG!
                        const italiaFilter = getFilterData(presets.italia);
                        allStrategiesMap['italia'] = {
                            name: 'üáÆüáπ ITALIA',
                            leagues: italiaFilter.leagues,
                            tips: italiaFilter.tips,
                            odds: italiaFilter.odds,
                            prob: italiaFilter.prob,
                            type: 'italia'
                        };

                        // TOP EU
                        const topEuFilter = getFilterData(presets.top_eu);
                        allStrategiesMap['top_eu'] = {
                            name: 'üåç TOP EU',
                            leagues: topEuFilter.leagues,
                            tips: topEuFilter.tips,
                            odds: topEuFilter.odds,
                            prob: topEuFilter.prob,
                            type: 'top_eu'
                        };

                        // CUPS
                        const cupsFilter = getFilterData(presets.cups);
                        allStrategiesMap['cups'] = {
                            name: 'üèÜ COPPE',
                            leagues: cupsFilter.leagues,
                            tips: cupsFilter.tips,
                            odds: cupsFilter.odds,
                            prob: cupsFilter.prob,
                            type: 'cups'
                        };

                        console.log('[calculateStrategyRankings] Loaded complete presets from client_presets:', {
                            italia: { leagues: italiaFilter.leagues.length, tips: italiaFilter.tips.length },
                            top_eu: { leagues: topEuFilter.leagues.length, tips: topEuFilter.tips.length }
                        });
                    } else {
                        console.warn('[calculateStrategyRankings] client_presets not found, using empty filters');
                        // Fallback to empty
                        const emptyFilter = { leagues: [], tips: [], odds: [1.0, 10.0], prob: [0, 100] };
                        allStrategiesMap['all'] = { name: 'üìä ALL', ...emptyFilter, type: 'all' };
                        allStrategiesMap['winrate_80'] = { name: 'üî• WINRATE 80%', ...emptyFilter, type: 'winrate_80' };
                        allStrategiesMap['italia'] = { name: 'üáÆüáπ ITALIA', ...emptyFilter, type: 'italia' };
                        allStrategiesMap['top_eu'] = { name: 'üåç TOP EU', ...emptyFilter, type: 'top_eu' };
                        allStrategiesMap['cups'] = { name: 'üèÜ COPPE', ...emptyFilter, type: 'cups' };
                    }
                } catch (e) {
                    console.error('[calculateStrategyRankings] Error loading presets:', e);
                }

                // BEST 0.5 HT (special, no leagues filter)
                allStrategiesMap['best_05_ht'] = {
                    name: '‚ö° BEST 0.5 HT',
                    type: 'best_05_ht'
                };

                // 2. Add savedFilters ONLY IF PUBLISHED (published: true checkbox)
                if (savedFilters && savedFilters.length > 0) {
                    savedFilters.forEach(strat => {
                        // ONLY include strategies that are marked as published
                        if (strat.type === 'local' && strat.published === true) {
                            allStrategiesMap[strat.id] = {
                                name: strat.name,
                                leagues: strat.state.leagues || [],
                                tips: strat.state.tips || [],
                                odds: strat.state.odds || [1.0, 10.0],
                                prob: strat.state.prob || [0, 100],
                                type: 'local',
                                published: true
                            };
                        }
                    });
                    console.log(`[calculateStrategyRankings] Added ${Object.keys(allStrategiesMap).filter(k => allStrategiesMap[k].type === 'local').length} published custom strategies`);
                }

                // 3. Load and add Public Strategies from Firebase
                try {
                    const strategiesDoc = await getDoc(doc(db, "system", "client_strategies"));
                    if (strategiesDoc.exists()) {
                        const strategies = strategiesDoc.data();
                        Object.keys(strategies).forEach(key => {
                            allStrategiesMap[key] = {
                                name: strategies[key].name || key,
                                leagues: strategies[key].leagues || [],
                                tips: strategies[key].tips || [],
                                odds: strategies[key].oddsRange || [1.0, 10.0],
                                prob: strategies[key].probRange || [0, 100],
                                type: 'public'
                            };
                        });
                    }
                } catch (e) {
                    console.error("Error loading public strategies:", e);
                }

                // Calculate league performance once (for score calculation)
                const leaguePerformance = analyzeLeaguePerformance(allMatches);

                // Process each strategy
                for (const [stratId, strat] of Object.entries(allStrategiesMap)) {
                    let filteredMatches = [];

                    // Check if preset has saved leagues (from client_presets)
                    const hasSavedLeagues = strat.leagues && strat.leagues.length > 0;

                    if (hasSavedLeagues) {
                        // USE SAVED FILTER CONFIGURATION (manual configurations)
                        // Apply ALL filters: leagues, tips, odds, prob
                        filteredMatches = matchesForDate.filter(m => {
                            // 1. Leagues filter
                            const matchLega = normalizeLega(m.lega);
                            if (!strat.leagues.includes(matchLega)) return false;

                            // 2. Tips filter (if specified)
                            if (strat.tips && strat.tips.length > 0) {
                                if (!strat.tips.includes(m.tip)) return false;
                            }

                            // 3. Odds filter
                            const q = parseFloat(m.quota);
                            if (strat.odds) {
                                if (q < strat.odds[0] || q > strat.odds[1]) return false;
                            }

                            // 4. Probability filter
                            const prob = parseFloat(m.probabilita);
                            if (strat.prob && !isNaN(prob)) {
                                if (prob < strat.prob[0] || prob > strat.prob[1]) return false;
                            }

                            return true;
                        });
                        console.log(`[calculateStrategyRankings] ${strat.name}: Using saved config - Leagues: ${strat.leagues.length}, Tips: ${strat.tips?.length || 0}, Matched: ${filteredMatches.length}`);
                    } else if (strat.type === 'all') {
                        // ALL: no filtering
                        filteredMatches = matchesForDate;
                    } else if (strat.type === 'italia') {
                        // ITALIA: filter leagues containing "italy" or "ita"
                        filteredMatches = matchesForDate.filter(m => {
                            const legaLower = (m.lega || '').toLowerCase();
                            return legaLower.includes('italy') || legaLower.includes('ita ') || legaLower.includes('serie');
                        });
                    } else if (strat.type === 'top_eu') {
                        // TOP EU: filter top European leagues
                        const topEuLeagues = ['premier league', 'la liga', 'serie a', 'bundesliga', 'ligue 1'];
                        filteredMatches = matchesForDate.filter(m => {
                            const legaLower = (m.lega || '').toLowerCase();
                            return topEuLeagues.some(l => legaLower.includes(l) &&
                                !legaLower.includes('women') &&
                                !legaLower.includes('u19') &&
                                !legaLower.includes('u21'));
                        });
                    } else if (strat.type === 'cups') {
                        // CUPS: filter cup competitions
                        const cupKeywords = ['champions league', 'europa league', 'conference league'];
                        filteredMatches = matchesForDate.filter(m => {
                            const legaLower = (m.lega || '').toLowerCase();
                            return cupKeywords.some(k => legaLower.includes(k));
                        });
                    } else if (strat.type === 'winrate_80') {
                        // WINRATE 80%: filter leagues with 80%+ winrate from historical data
                        const leagueStats = {};
                        allMatches.forEach(m => {
                            if (!m.risultato) return;
                            const lega = normalizeLega(m.lega);
                            if (!leagueStats[lega]) leagueStats[lega] = { total: 0, wins: 0 };
                            leagueStats[lega].total++;
                            if (m.esito === 'Vinto') leagueStats[lega].wins++;
                        });

                        const goodLeagues = Object.keys(leagueStats).filter(lega => {
                            const stats = leagueStats[lega];
                            const winrate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                            return winrate >= 80 && stats.total >= 5;
                        });

                        filteredMatches = matchesForDate.filter(m => {
                            const matchLega = normalizeLega(m.lega);
                            return goodLeagues.includes(matchLega);
                        });
                    } else if (strat.type === 'best_05_ht') {
                        // BEST 0.5 HT: special HT filtering
                        filteredMatches = matchesForDate.filter(m => {
                            if (m.info_ht && m.info_ht.trim() !== '') {
                                const htMatch = m.info_ht.match(/(\d+)%/);
                                if (htMatch) {
                                    const htProb = parseInt(htMatch[1]);
                                    return htProb >= 70 && m.tip.startsWith('+');
                                }
                            }
                            return false;
                        });
                    } else {
                        // Use generic filter helper for custom strategies
                        filteredMatches = filterMatchesByStrategy(matchesForDate, strat);
                    }

                    // Skip if no matches
                    if (filteredMatches.length === 0) {
                        results[stratId] = {
                            id: stratId,
                            filtro_nome: strat.name,
                            name: strat.name,
                            magic_type: strat.type === 'best_05_ht' ? 'singole' : (strat.type === 'winrate_80' ? 'trading' : 'custom'),
                            lastCalculated: Date.now(),
                            totalMatches: 0,
                            matches: [],
                            partite_by_tip: {}
                        };
                        continue;
                    }

                    // Calculate complete data for each match
                    const rankedMatches = filteredMatches.map(m => {
                        // Prepare sets for calculateScore
                        const legheSet = new Set([m.lega.toLowerCase()]);
                        const tipsSet = new Set([m.tip]);

                        // Calculate score using historical data
                        const scoreData = calculateScore(m, legheSet, tipsSet, leaguePerformance, allMatches);

                        // Generate trading indication
                        const indication = getTradingIndication(scoreData.totalScore, m.quota);

                        // Analyze team stats
                        const teams = m.partita.split(' - ');
                        let homeStats = null;
                        let awayStats = null;
                        let betfairBadge = null;

                        if (teams.length === 2) {
                            homeStats = analyzeTeamStats(teams[0].trim(), true, m.tip, allMatches);
                            awayStats = analyzeTeamStats(teams[1].trim(), false, m.tip, allMatches);

                            // Generate Betfair badge
                            const is05HT = stratId === 'best_05_ht';
                            betfairBadge = generateBetfairBadge(m, is05HT, homeStats, awayStats);
                        }

                        return {
                            // Original match data
                            data: m.data,
                            ora: m.ora || '',
                            lega: m.lega,
                            partita: m.partita,
                            tip: m.tip,
                            quota: m.quota,
                            probabilita: m.probabilita,
                            mercato: m.mercato,
                            info_ht: m.info_ht || '',

                            // Calculated data
                            score: scoreData.totalScore,
                            scoreDetails: scoreData,
                            indication: indication,
                            betfairBadge: betfairBadge,
                            teamStats: {
                                home: homeStats,
                                away: awayStats
                            }
                        };
                    });

                    // Sort by score (desc)
                    rankedMatches.sort((a, b) => b.score - a.score);

                    // Group by tip for partite_by_tip
                    const partite_by_tip = {};
                    rankedMatches.forEach(m => {
                        if (!partite_by_tip[m.tip]) partite_by_tip[m.tip] = [];
                        partite_by_tip[m.tip].push(m);
                    });

                    results[stratId] = {
                        id: stratId,
                        filtro_nome: strat.name,
                        name: strat.name,
                        magic_type: strat.type === 'best_05_ht' ? 'singole' : (strat.type === 'winrate_80' ? 'trading' : 'custom'),
                        lastCalculated: Date.now(),
                        totalMatches: rankedMatches.length,
                        matches: rankedMatches,
                        partite_by_tip: partite_by_tip
                    };

                    console.log(`[calculateStrategyRankings] ${strat.name}: ${rankedMatches.length} matches calculated`);
                }

                // Save to Firebase under rankings/{date}
                try {
                    const strategiesArray = Object.values(results);

                    // 1. Save to rankings/{date} (Main storage)
                    await setDoc(doc(db, "rankings", targetDate), {
                        strategies: strategiesArray,
                        generated: Date.now()
                    });
                    console.log(`[calculateStrategyRankings] Saved to rankings/${targetDate}`);

                    // 2. Save to ranking_history/{date} (For History View)
                    await setDoc(doc(db, "ranking_history", targetDate), {
                        data_partite: targetDate,
                        strategies: strategiesArray,
                        generated: Date.now()
                    });
                    console.log(`[calculateStrategyRankings] Saved to ranking_history/${targetDate}`);

                } catch (e) {
                    console.error("Error saving rankings to Firebase:", e);
                }

                // If target date is today, also update system/strategy_results (for Client quick access)
                const today = new Date().toISOString().split('T')[0];
                if (targetDate === today) {
                    try {
                        await setDoc(doc(db, "system", "strategy_results"), results);
                        console.log(`[calculateStrategyRankings] Updated system/strategy_results for today`);
                    } catch (e) {
                        console.error("Error updating system/strategy_results:", e);
                    }
                }

                return results;
            }

            async function handleUploadConfirmed(type) {
                if (dataToUpload.length === 0) return;

                const btn = document.getElementById(`confirm-${type}-upload-btn`);
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento in corso...';

                const matchesCollection = collection(db, "matches");
                let deletedCount = 0;

                try {
                    // CARICA ORARI AUTOMATICAMENTE per tips (non per results)
                    if (type === 'tips') {
                        console.log('[INFO] Caricamento orari disabilitato. Aggiungi colonna "Ora" al CSV per includerli.');
                    }

                    // Carica/aggiorna partite
                    const batch = writeBatch(db);
                    for (const match of dataToUpload) {
                        // RETRIEVE TIME FROM CACHE before saving
                        const cachedTime = await getTimeFromCache(match.data, match.partita);
                        if (cachedTime) {
                            match.ora = cachedTime;
                            console.log(`[SAVE] Adding time ${cachedTime} to ${match.partita}`);
                        }

                        if (match.id) {
                            // Update esistente - usa set con merge per evitare errori
                            batch.set(doc(matchesCollection, match.id), match, { merge: true });
                        } else {
                            // Nuovo
                            const docRef = doc(matchesCollection);
                            batch.set(docRef, match);
                        }
                    }

                    await batch.commit();

                    // Update Metadata Timestamp (Silent Fail)
                    try {
                        await setDoc(doc(db, "system", "metadata"), { lastUpdated: Date.now() }, { merge: true });

                        // RELOAD DATA FIRST to include the new uploads in calculations
                        await loadAllMatches();

                        // GENERATE CLIENT PRESETS (ONLY FOR RESULTS UPLOAD)
                        let presetStats = null;
                        if (type === 'results') {
                            // Now allMatches includes the new data
                            presetStats = await calculateAndSaveClientPresets(allMatches);
                        }

                        // SE RISULTATI: aggiorna ranking salvati con esiti
                        let performanceReport = null;
                        if (type === 'results' && dataToUpload.length > 0) {
                            const uploadDate = dataToUpload[0].data;
                            performanceReport = await updateRankingResults(uploadDate, dataToUpload);
                        }

                        // 2. Se stiamo caricando TIPS (partite di oggi), calcola e salva i risultati per le Strategie Client
                        if (type === 'tips') {
                            try {
                                console.log("Calcolo risultati per Strategie Client...");

                                const strategiesDoc = await getDoc(doc(db, "system", "client_strategies"));
                                const strategies = strategiesDoc.exists() ? strategiesDoc.data() : {};

                                console.log(`Trovate ${Object.keys(strategies).length} strategie client.`);

                                const strategyResults = {};
                                const leaguePerformance = analyzeLeaguePerformance(allMatches); // Calcola performance leghe una volta sola

                                for (const [stratId, strat] of Object.entries(strategies)) {
                                    // Filtra le partite caricate (dataToUpload) in base alla strategia
                                    const filteredMatches = dataToUpload.filter(m => {
                                        // Filtro Leghe
                                        if (strat.leagues && strat.leagues.length > 0) {
                                            if (!strat.leagues.includes(m.lega)) return false;
                                        }
                                        // Filtro Tips
                                        if (strat.tips && strat.tips.length > 0) {
                                            if (!strat.tips.includes(m.tip)) return false;
                                        }
                                        // Filtro Probabilit√†
                                        if (strat.probRange) {
                                            if (m.probabilita < strat.probRange[0] || m.probabilita > strat.probRange[1]) return false;
                                        }
                                        // Filtro Quote
                                        if (strat.oddsRange) {
                                            if (m.quota < strat.oddsRange[0] || m.quota > strat.oddsRange[1]) return false;
                                        }
                                        return true;
                                    });

                                    // Se ci sono partite, calcola ranking completo
                                    if (filteredMatches.length > 0) {
                                        const rankedMatches = filteredMatches.map(m => {
                                            // Calcola score completo usando DB storico (allMatches)
                                            const scoreData = calculateScore(m, new Set([m.lega.toLowerCase()]), new Set([m.tip]), leaguePerformance, allMatches);

                                            // Genera indicazioni e badge
                                            const indication = getTradingIndication(scoreData.totalScore, m.quota);

                                            // Analisi squadre per badge Betfair
                                            const teams = m.partita.split(' - ');
                                            let betfairBadge = null;
                                            if (teams.length === 2) {
                                                const homeStats = analyzeTeamStats(teams[0].trim(), true, m.tip, allMatches);
                                                const awayStats = analyzeTeamStats(teams[1].trim(), false, m.tip, allMatches);
                                                betfairBadge = generateBetfairBadge(m, false, homeStats, awayStats);
                                            }

                                            return {
                                                ...m,
                                                score: scoreData.totalScore,
                                                scoreDetails: scoreData, // Dettagli completi per tooltip
                                                indication: indication,
                                                betfairBadge: betfairBadge
                                            };
                                        }).sort((a, b) => b.score - a.score); // Ordina per score decrescente

                                        strategyResults[stratId] = {
                                            name: strat.name,
                                            matches: rankedMatches,
                                            lastUpdated: Date.now()
                                        };
                                    } else {
                                        strategyResults[stratId] = {
                                            name: strat.name,
                                            matches: [],
                                            lastUpdated: Date.now()
                                        };
                                    }
                                }

                                // Salva risultati calcolati su Firestore
                                await setDoc(doc(db, "system", "strategy_results"), strategyResults);
                                console.log("Risultati Strategie salvati!", strategyResults);

                                // POPOLA REPORT STRATEGIE (UI)
                                const reportContainer = document.getElementById('strategy-report-container');
                                const reportList = document.getElementById('strategy-report-list');
                                if (reportContainer && reportList) {
                                    reportList.innerHTML = '';
                                    for (const [stratId, result] of Object.entries(strategyResults)) {
                                        const count = result.matches ? result.matches.length : 0;
                                        reportList.innerHTML += `<li>‚úÖ <strong>${result.name}</strong>: aggiornata a <strong>${count}</strong> pronostici</li>`;
                                    }
                                    reportContainer.classList.remove('hidden');
                                } else {
                                    if (reportList) reportList.innerHTML = '<li>‚ö†Ô∏è Nessuna strategia client configurata. Vai nella tab "Strategie" per crearne una.</li>';
                                    reportContainer?.classList.remove('hidden');
                                }
                                console.log("Calcolo strategie completato.");

                            } catch (e) {
                                console.error("Errore calcolo strategie:", e);
                                const reportList = document.getElementById('strategy-report-list');
                                if (reportList) reportList.innerHTML += `<li class="text-red-600">‚ö†Ô∏è Errore calcolo strategie: ${e.message}</li>`;
                                document.getElementById('strategy-report-container')?.classList.remove('hidden');
                            }
                        }

                        // CRITICAL: Aggiorna allMatches locale e genera Preset Standard + Daily Matches
                        // Se non facciamo questo, il client non vede le nuove partite e la dashboard admin non si aggiorna
                        console.log("Aggiornamento stato locale e preset standard...");

                        // 1. Aggiorna allMatches (ricarica tutto per sicurezza e semplicit√†, o merge parziale)
                        // Reload parziale √® rischioso per ID mancanti. Facciamo reload completo silent.
                        await loadAllMatches();

                        // 2. Genera Preset Standard (Top EU, ecc) and Daily Matches
                        presetStats = await calculateAndSaveClientPresets(allMatches);

                        // 3. CALCULATE AND SAVE COMPLETE RANKINGS (NEW!)
                        console.log("[handleUploadConfirmed] Calculating complete rankings for today...");
                        const matchDate = dataToUpload.length > 0 ? dataToUpload[0].data : new Date().toISOString().split('T')[0];
                        const todayMatches = allMatches.filter(m => m.data === matchDate && !m.risultato);

                        if (todayMatches.length > 0) {
                            const rankingResults = await calculateStrategyRankings(todayMatches, matchDate);
                            console.log(`[handleUploadConfirmed] Rankings calculated for ${Object.keys(rankingResults).length} strategies`);
                        }

                        // AGGIUNGI PRESET STANDARD AL REPORT (CALCOLATI SUI DATI CARICATI)
                        const reportList = document.getElementById('strategy-report-list');
                        if (reportList && presetStats && presetStats.fullPresets) {
                            // Rimuovi messaggio "Nessuna strategia" se presente e se abbiamo preset
                            if (reportList.innerHTML.includes('Nessuna strategia')) {
                                reportList.innerHTML = '';
                            }

                            reportList.innerHTML += `<li class="mt-2 font-bold text-gray-700 border-t border-blue-200 pt-1">Preset Standard & Custom (Oggi):</li>`;

                            // Iterate ALL presets (Standard + Custom)
                            Object.keys(presetStats.fullPresets).forEach(key => {
                                const preset = presetStats.fullPresets[key];
                                let count = 0;

                                // Special logic for Best 0.5 HT (same as in calculateAndSaveClientPresets)
                                if (key === 'best_05_ht') {
                                    count = dataToUpload.filter(m => {
                                        if (m.info_ht && m.info_ht.trim() !== '') {
                                            const htMatch = m.info_ht.match(/(\d+)%/);
                                            if (htMatch) {
                                                const htProb = parseInt(htMatch[1]);
                                                return htProb >= 70 && m.tip.startsWith('+');
                                            }
                                        }
                                        return false;
                                    }).length;
                                } else {
                                    // Use generic helper
                                    const f = {
                                        leagues: preset.leagues,
                                        tips: preset.tips,
                                        odds: preset.odds
                                    };
                                    count = filterMatchesByStrategy(dataToUpload, f).length;
                                }

                                // Icons
                                let icon = 'üìä';
                                if (key === 'top_eu') icon = 'üåç';
                                if (key === 'italia') icon = 'üáÆüáπ';
                                if (key === 'winrate_80') icon = 'üî•';
                                if (key === 'cups') icon = 'üèÜ';
                                if (key === 'best_05_ht') icon = '‚ö°';
                                if (preset.name && !['top_eu', 'italia', 'winrate_80', 'cups', 'best_05_ht'].includes(key)) icon = 'üë§';

                                const name = preset.name || key.replace(/_/g, ' ').toUpperCase();
                                reportList.innerHTML += `<li>${icon} <strong>${name}</strong>: ${count} partite</li>`;
                            });
                            document.getElementById('strategy-report-container')?.classList.remove('hidden');
                        }

                        // 4. Aggiorna UI Admin
                        applyFiltersAndRender();

                    } catch (metaErr) {
                        console.warn("Errore aggiornamento post-upload:", metaErr);
                    }

                    // UI FEEDBACK FINALE (Senza Reload)
                    btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Caricamento Completato!';
                    btn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    btn.classList.add('bg-gray-500', 'cursor-not-allowed');
                    // Non disabilitiamo btn.disabled = true; perch√© magari vuole vedere il report, ma cambiamo stile.

                    // Reset inputs per evitare doppio invio accidentale
                    document.getElementById('tips-csv-file').value = '';
                    document.getElementById('tips-ht-file').value = '';

                    // Se siamo in results, magari reload √® meglio? No, coerenza.
                    if (type === 'results') {
                        alert(`Risultati aggiornati! ${dataToUpload.length} record processati.`);
                        location.reload();
                    }

                } catch (error) {
                    console.error("Batch error:", error);
                    alert("Errore durante il caricamento: " + error.message);
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-exclamation-triangle mr-2"></i>Riprova';
                }
            }

            function parseCSV(text) {
                const lines = text.split('\n');
                const headers = lines[0].split(',').map(h => h.trim().replace(/['"]/g, ''));
                console.log('[parseCSV] Headers found:', headers);

                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    const values = lines[i].split(',').map(v => v.trim().replace(/['"]/g, ''));
                    const row = {};
                    headers.forEach((h, idx) => row[h] = values[idx]);
                    data.push(row);
                }
                if (data.length > 0) console.log('[parseCSV] First row sample:', data[0]);
                return data;
            }

            async function processAndPreviewCSV(parsedData, matchDate, type) {
                const requiredFields = ['Lega', 'Partita', 'Probabilit√†', 'Mercato', 'Tip', 'Quota'];
                let potentialMatches = [];
                let incomplete = 0;
                let duplicates = 0;
                let updates = 0;

                for (const row of parsedData) {
                    // VALIDAZIONE MIGLIORATA: scarta se campo mancante o "-"
                    if (!requiredFields.every(f => {
                        const value = String(row[f] || '').trim();
                        return value !== '' && value !== '-';
                    })) {
                        incomplete++;
                        continue;
                    }

                    // Parse dati
                    if (type === 'tips') tipsFileCount = parsedData.length;
                    if (type === 'ht') htFileCount = parsedData.length;

                    const probabilita = parseInt(String(row['Probabilit√†']).replace('%', '').trim()) || 0;
                    const quota = parseFloat(String(row.Quota).replace(',', '.').trim()) || 0;

                    // VALIDAZIONE NUMERICA: scarta se prob o quota = 0
                    if (probabilita === 0 || quota === 0) {
                        incomplete++;
                        continue;
                    }

                    // Parse ora dal CSV
                    const ora = String(row.Ora || row.Time || '').trim();

                    const matchData = {
                        data: matchDate,
                        lega: normalizeLega(String(row.Lega).trim()),
                        partita: String(row.Partita).trim(),
                        risultato: type === 'results' ? (String(row.Risultato || '').trim()) : '',
                        probabilita: probabilita,
                        mercato: String(row.Mercato).trim(),
                        tip: String(row.Tip).trim(),
                        quota: quota,
                        info_ht: String(row.info_ht || '').trim()
                    };

                    // Se c'√® ora nel CSV ‚Üí salva in cache Firebase temporanea
                    if (ora && ora !== '' && type === 'tips') {
                        // Salva in cache (non nel DB principale!)
                        await saveTimeToCache(matchData.data, matchData.partita, ora);
                    }

                    // Check duplicates in current batch
                    const existingIndex = potentialMatches.findIndex(m =>
                        m.data === matchData.data &&
                        m.lega === matchData.lega &&
                        m.partita === matchData.partita &&
                        m.tip === matchData.tip
                    );

                    if (existingIndex >= 0) {
                        // Update existing match in batch - SMART MERGE
                        const existing = potentialMatches[existingIndex];
                        const smartUpdate = { ...existing };

                        // Update fields ONLY if present in new data
                        if (matchData.ora) smartUpdate.ora = matchData.ora;
                        if (matchData.quota) smartUpdate.quota = matchData.quota;
                        if (matchData.probabilita) smartUpdate.probabilita = matchData.probabilita;
                        if (matchData.info_ht) smartUpdate.info_ht = matchData.info_ht;
                        if (matchData.risultato) smartUpdate.risultato = matchData.risultato;
                        if (matchData.esito) smartUpdate.esito = matchData.esito;

                        potentialMatches[existingIndex] = smartUpdate;
                        updates++;
                    } else {
                        // Check against already loaded matches (global)
                        const globalDuplicate = window.allMatches.find(m =>
                            m.data === matchData.data &&
                            m.lega === matchData.lega &&
                            m.partita === matchData.partita &&
                            m.tip === matchData.tip
                        );

                        if (globalDuplicate) {
                            // Update global duplicate - SMART MERGE
                            const smartUpdate = { ...globalDuplicate };

                            if (matchData.ora) smartUpdate.ora = matchData.ora;
                            if (matchData.quota) smartUpdate.quota = matchData.quota;
                            if (matchData.probabilita) smartUpdate.probabilita = matchData.probabilita;
                            if (matchData.info_ht) smartUpdate.info_ht = matchData.info_ht;
                            if (matchData.risultato) smartUpdate.risultato = matchData.risultato;
                            if (matchData.esito) smartUpdate.esito = matchData.esito;

                            potentialMatches.push(smartUpdate);
                            updates++;
                        } else {
                            // New match
                            potentialMatches.push(matchData);
                        }
                    }
                }
                dataToUpload = potentialMatches;
                // FIX: HT file should update the TIPS preview box
                const previewId = (type === 'tips' || type === 'ht') ? 'tips-upload-preview' : 'results-upload-preview';
                const uploadPreview = document.getElementById(previewId);

                uploadPreview.classList.remove('hidden');
                uploadPreview.innerHTML = `
                    <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <h4 class="font-bold text-gray-800 mb-2">Riepilogo Caricamento:</h4>
                        <ul class="text-sm space-y-1 text-gray-600">
                            <li>üìÑ File Tips (Top): <span id="stats-tips-count" class="font-bold text-blue-600">${tipsFileCount || '-'}</span> righe</li>
                            <li>üìÑ File HT (0.5): <span id="stats-ht-count" class="font-bold text-purple-600">${htFileCount || '-'}</span> righe</li>
                            <li>üîó Matchati/Uniti: <span id="stats-merged-count" class="font-bold text-green-600">${dataToUpload.length}</span> partite</li>
                            <li>‚ö†Ô∏è Non Matchati: <span id="stats-unmatched-count" class="font-bold text-red-500">0</span></li>
                            <li class="pt-2 border-t border-gray-200 mt-2">
                                <strong>Totale Operazioni:</strong> <span id="upload-count" class="font-bold text-gray-800">${dataToUpload.length}</span>
                            </li>
                        </ul>
                    </div>
                    <ul class="list-disc list-inside text-sm mt-2">
                        <li>Partite totali file: ${parsedData.length}</li>
                        <li>Scartate (incomplete): ${incomplete}</li>
                        ${type === 'results' ? `<li class="text-green-600">Da aggiornare (esistenti): ${updates}</li>` : ''}
                        ${duplicates > 0 ? `<li class="text-orange-600">Duplicate (ignorate): ${duplicates}</li>` : ''}
                        ${(type === 'tips' && htFileCount > 0 && (tipsFileCount - htFileCount) > 0) ? `<li class="text-orange-600 font-bold">‚ö†Ô∏è Senza dati HT: ${tipsFileCount - htFileCount}</li>` : ''}
                        <li class="font-bold text-blue-600">Da caricare (nuove): ${dataToUpload.length - updates}</li>
                        <li class="font-bold text-purple-600">Totale operazioni: ${dataToUpload.length}</li>
                        <li class="text-red-600 font-bold">Errori/Scartate: ${incomplete}</li>
                    </ul>
                    
                    <!-- STRATEGY REPORT CONTAINER (Initially Hidden) -->
                    <div id="strategy-report-container" class="mt-4 hidden bg-blue-50 p-4 rounded-lg border border-blue-200">
                        <h4 class="font-bold text-blue-800 mb-2">üìä Report Strategie Client (${matchDate}):</h4>
                        <ul id="strategy-report-list" class="text-sm space-y-1 text-blue-700">
                            <!-- Populated by JS after upload -->
                        </ul>
                    </div>

                    <button id="confirm-${type}-upload-btn" class="mt-4 w-full bg-green-600 text-white font-semibold py-2 rounded-lg hover:bg-green-700">
                        Conferma e Carica
                    </button>
                `;

                document.getElementById(`confirm-${type}-upload-btn`).addEventListener('click', () => {
                    console.log(`Button confirm-${type}-upload-btn clicked!`);
                    handleUploadConfirmed(type);
                });
            }

            // ==================== MASS EDIT LOGIC ====================
            document.getElementById('mass-edit-preview-btn').addEventListener('click', () => {
                const field = document.getElementById('mass-edit-field').value;
                const findVal = document.getElementById('mass-edit-find').value.trim();
                const replaceVal = document.getElementById('mass-edit-replace').value.trim();
                const previewEl = document.getElementById('mass-edit-preview');

                if (!findVal) {
                    alert("Inserisci il valore da trovare!");
                    return;
                }

                // Search logic
                const matchesFound = allMatches.filter(m => String(m[field] || '').includes(findVal));

                if (matchesFound.length === 0) {
                    previewEl.classList.remove('hidden');
                    previewEl.innerHTML = `<div class="text-red-600 font-bold">Nessuna corrispondenza trovata per "${findVal}" nel campo ${field}.</div>`;
                    return;
                }

                previewEl.classList.remove('hidden');
                previewEl.innerHTML = `
                    <div class="space-y-3">
                        <div class="font-bold text-gray-800">Trovati <span class="text-blue-600 text-lg">${matchesFound.length}</span> record.</div>
                        <div class="bg-yellow-50 p-2 rounded border border-yellow-200 text-xs">
                            Esempio: "${matchesFound[0][field]}" <i class="fa-solid fa-arrow-right mx-2 text-gray-400"></i> "${replaceVal}"
                        </div>
                        <button id="confirm-mass-edit-btn" class="w-full bg-red-600 text-white py-2 rounded-lg font-bold hover:bg-red-700">
                            <i class="fa-solid fa-exclamation-triangle mr-2"></i>Conferma Sostituzione (${matchesFound.length})
                        </button>
                    </div>
                `;

                document.getElementById('confirm-mass-edit-btn').onclick = async () => {
                    if (!confirm(`Sei SICURO di voler aggiornare ${matchesFound.length} record? Questa azione √® irreversibile.`)) return;

                    const btn = document.getElementById('confirm-mass-edit-btn');
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Aggiornamento...';

                    try {
                        const batchSize = 400;
                        const chunks = [];
                        for (let i = 0; i < matchesFound.length; i += batchSize) {
                            chunks.push(matchesFound.slice(i, i + batchSize));
                        }

                        let processed = 0;
                        for (const chunk of chunks) {
                            const batch = writeBatch(db);
                            chunk.forEach(m => {
                                const ref = doc(db, "matches", m.id);
                                // Update local logic for preview consistency if needed, but reload is safer
                                batch.update(ref, { [field]: replaceVal });
                            });
                            await batch.commit();
                            processed += chunk.length;
                        }

                        // Update Metadata Timestamp
                        try {
                            await setDoc(doc(db, "system", "metadata"), { lastUpdated: Date.now() }, { merge: true });
                            // GENERATE CLIENT PRESETS
                            await calculateAndSaveClientPresets(allMatches);
                        } catch (metaErr) {
                            console.warn("Could not update metadata timestamp (permissions?):", metaErr);
                        }

                        alert(`Operazione completata! ${processed} record aggiornati.`);
                        location.reload();
                    } catch (e) {
                        console.error(e);
                        alert("Errore: " + e.message);
                    }
                };
            });

            // ==================== QUICK SEARCH LOGIC ====================
            document.getElementById('quick-db-search').addEventListener('input', (e) => {
                const term = e.target.value.toLowerCase().trim();
                const tbody = document.getElementById('quick-db-results');

                if (term.length < 2) {
                    tbody.innerHTML = '<tr><td colspan="6" class="p-4 text-center text-gray-500">Digita almeno 2 caratteri...</td></tr>';
                    return;
                }

                const results = allMatches.filter(m =>
                    (m.lega && m.lega.toLowerCase().includes(term)) ||
                    (m.partita && m.partita.toLowerCase().includes(term)) ||
                    (m.tip && m.tip.toLowerCase().includes(term))
                ).slice(0, 50); // Limit to 50 for perf

                if (results.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="6" class="p-4 text-center text-gray-500">Nessun risultato.</td></tr>';
                    return;
                }

                tbody.innerHTML = results.map(m => `
                    <tr class="hover:bg-gray-50 border-b">
                        <td class="p-2">${m.data}</td>
                        <td class="p-2 font-medium text-blue-600">${m.lega}</td>
                        <td class="p-2">${m.partita}</td>
                        <td class="p-2 font-bold">${m.tip}</td>
                        <td class="p-2 text-center font-mono">${m.risultato || '-'}</td>
                        <td class="p-2 text-center">
                            <button onclick="enableEditMode('${m.id}')" class="text-blue-600 hover:text-blue-800 px-2"><i class="fa-solid fa-pencil"></i></button>
                        </td>
                    </tr>
                `).join('');
            });

            // ==================== FULL EXPORT LOGIC ====================
            document.getElementById('export-full-db-btn').addEventListener('click', () => {
                if (allMatches.length === 0) {
                    alert("Nessun dato da esportare.");
                    return;
                }
                const headers = ['id', 'data', 'lega', 'partita', 'risultato', 'probabilita', 'mercato', 'tip', 'quota', 'esito', 'info_ht'];
                const csv = Papa.unparse(allMatches.map(d => ({
                    ...d,
                    quota: String(d.quota).replace('.', ',')
                })), { columns: headers });

                const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `backup_completo_${new Date().toISOString().slice(0, 10)}.csv`;
                link.click();
            });

            // Export Storico Partite (CSV)
            document.getElementById('export-storico-btn').addEventListener('click', () => {
                const startDate = document.getElementById('export-start-date').value;
                const endDate = document.getElementById('export-end-date').value;
                const onlyResults = document.getElementById('export-only-results').checked;

                let filteredMatches = allMatches.filter(m => {
                    // Filter by date range
                    if (startDate && m.data < startDate) return false;
                    if (endDate && m.data > endDate) return false;
                    // Filter by results (if checkbox is checked)
                    if (onlyResults && !m.risultato) return false;
                    return true;
                });

                if (filteredMatches.length === 0) {
                    alert('Nessuna partita trovata con i filtri selezionati.');
                    return;
                }

                // Prepare CSV data with Italian date format
                const csvData = filteredMatches.map(m => ({
                    Data: formatDateIT(m.data),
                    Lega: m.lega,
                    Partita: m.partita,
                    Tip: m.tip,
                    Quota: String(m.quota).replace('.', ','),
                    Probabilit√†: m.probabilita ? m.probabilita + '%' : '',
                    Mercato: m.mercato,
                    Risultato: m.risultato || '',
                    Esito_Tip: m.esito || '',
                    Info_HT: m.info_ht || '',
                    Ora: m.ora || ''
                }));

                // Generate CSV
                const csv = Papa.unparse(csvData);
                const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const startLabel = startDate ? formatDateIT(startDate) : 'inizio';
                const endLabel = endDate ? formatDateIT(endDate) : 'oggi';
                a.download = `storico_${startLabel}_${endLabel}.csv`.replace(/\//g, '-');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            // Bulk Recalculate Esito
            document.getElementById('bulk-recalculate-esito-btn').addEventListener('click', async () => {
                const btn = document.getElementById('bulk-recalculate-esito-btn');
                const statusDiv = document.getElementById('recalc-status');

                if (!confirm('‚ö†Ô∏è Ricalcolare gli esiti per TUTTE le partite con risultato?\n\nQuesta operazione potrebbe richiedere alcuni secondi.')) {
                    return;
                }

                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Ricalcolo in corso...';
                statusDiv.classList.remove('hidden');
                statusDiv.innerHTML = '<i class="fa-solid fa-clock mr-2"></i>Analisi partite...';

                try {
                    // Find matches with result but no esito
                    const matchesToFix = allMatches.filter(m =>
                        m.risultato && m.risultato.trim() !== '' &&
                        (!m.esito || m.esito.trim() === '')
                    );

                    if (matchesToFix.length === 0) {
                        statusDiv.innerHTML = '<div class="text-green-600"><i class="fa-solid fa-check mr-2"></i>Nessuna partita da correggere! Tutti gli esiti sono gi√† presenti.</div>';
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fa-solid fa-rotate mr-2"></i>Ricalcola Tutti gli Esiti';
                        return;
                    }

                    statusDiv.innerHTML = `<i class="fa-solid fa-spinner fa-spin mr-2"></i>Ricalcolo ${matchesToFix.length} partite...`;

                    // Recalculate esito for each match
                    const batch = writeBatch(db);
                    let fixed = 0;
                    let failed = 0;

                    for (const match of matchesToFix) {
                        const newEsito = calculateOutcome(match);
                        if (newEsito && newEsito !== '') {
                            batch.update(doc(db, "matches", match.id), { esito: newEsito });
                            // Update local copy
                            const idx = allMatches.findIndex(m => m.id === match.id);
                            if (idx >= 0) allMatches[idx].esito = newEsito;
                            fixed++;
                        } else {
                            failed++;
                            console.warn('[Bulk Recalc] Could not calculate esito for:', match);
                        }
                    }

                    await batch.commit();
                    await loadAllMatches(); // Reload to refresh
                    applyFiltersAndRender(); // Refresh display

                    statusDiv.innerHTML = `
                        <div class="bg-green-50 p-3 rounded border border-green-200">
                            <div class="text-green-800 font-bold"><i class="fa-solid fa-check-circle mr-2"></i>Ricalcolo completato!</div>
                            <div class="text-sm text-green-700 mt-1">‚úÖ ${fixed} partite corrette</div>
                            ${failed > 0 ? `<div class="text-sm text-yellow-700">‚ö†Ô∏è ${failed} partite non calcolabili (mercato non riconosciuto)</div>` : ''}
                        </div>
                    `;

                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-rotate mr-2"></i>Ricalcola Tutti gli Esiti';
                } catch (e) {
                    console.error('[Bulk Recalc] Error:', e);
                    statusDiv.innerHTML = `<div class="text-red-600"><i class="fa-solid fa-exclamation-triangle mr-2"></i>Errore: ${e.message}</div>`;
                    btn.disabled = false;
                    btn.innerHTML = '<i class="fa-solid fa-rotate mr-2"></i>Ricalcola Tutti gli Esiti';
                }
            });

            // REMOVED DUPLICATE handleUploadConfirmed FUNCTION
            // The correct version is defined above (lines ~2850)

            function calculateOutcome(match) {
                const { tip, risultato } = match;
                if (!risultato || !tip) return '';

                const scores = risultato.split('-').map(s => parseInt(s.trim()));
                if (scores.length !== 2 || isNaN(scores[0]) || isNaN(scores[1])) return '';

                const [homeScore, awayScore] = scores;
                const totalGoals = homeScore + awayScore;
                const normalizedTip = tip.toUpperCase().replace(/\s/g, '');

                try {
                    // 1X2
                    if (normalizedTip === '1') return homeScore > awayScore ? 'Vinto' : 'Perso';
                    if (normalizedTip === 'X') return homeScore === awayScore ? 'Vinto' : 'Perso';
                    if (normalizedTip === '2') return awayScore > homeScore ? 'Vinto' : 'Perso';

                    // Doppia Chance
                    if (normalizedTip === '1X') return homeScore >= awayScore ? 'Vinto' : 'Perso';
                    if (normalizedTip === 'X2') return awayScore >= homeScore ? 'Vinto' : 'Perso';
                    if (normalizedTip === '12') return homeScore !== awayScore ? 'Vinto' : 'Perso';

                    // Over/Under: +1.5, -2.5, OVER1.5, UNDER2.5, etc.
                    if (/^[+-]?\d+(\.\d+)?$/.test(normalizedTip) || /^(OVER|UNDER)\d+(\.\d+)?$/i.test(normalizedTip)) {
                        let threshold;
                        let isOver;

                        if (normalizedTip.startsWith('OVER')) {
                            threshold = parseFloat(normalizedTip.replace(/OVER/i, ''));
                            isOver = true;
                        } else if (normalizedTip.startsWith('UNDER')) {
                            threshold = parseFloat(normalizedTip.replace(/UNDER/i, ''));
                            isOver = false;
                        } else if (normalizedTip.startsWith('+')) {
                            threshold = parseFloat(normalizedTip.substring(1));
                            isOver = true;
                        } else if (normalizedTip.startsWith('-')) {
                            threshold = parseFloat(normalizedTip.substring(1));
                            isOver = false;
                        } else {
                            // Just a number - assume Over
                            threshold = parseFloat(normalizedTip);
                            isOver = true;
                        }

                        if (isNaN(threshold)) return '';

                        if (isOver) return totalGoals > threshold ? 'Vinto' : 'Perso';
                        return totalGoals < threshold ? 'Vinto' : 'Perso';
                    }

                    // Goal/No Goal
                    if (normalizedTip === 'GOL' || normalizedTip === 'GG' || normalizedTip === 'SI' || normalizedTip === 'S√å') {
                        return (homeScore > 0 && awayScore > 0) ? 'Vinto' : 'Perso';
                    }
                    if (normalizedTip === 'NOGOL' || normalizedTip === 'NG' || normalizedTip === 'NO') {
                        return (homeScore === 0 || awayScore === 0) ? 'Vinto' : 'Perso';
                    }

                    // Unrecognized tip
                    console.warn(`[calculateOutcome] Unrecognized tip: "${tip}"`);
                    return '';

                } catch (e) {
                    console.error('[calculateOutcome] Error:', e, 'Match:', match);
                    return '';
                }
            }

            // ==================== CANCELLAZIONE GIORNATE ====================
            function updateTipsDaysList() {

                console.log("Aggiornamento lista giornate Tips...");
                const tipsDates = [...new Set(allMatches.filter(m => !m.risultato).map(m => m.data))].sort().reverse();
                console.log("Date trovate:", tipsDates);

                const select = document.getElementById('delete-tips-date');
                select.innerHTML = '<option value="">Seleziona una data...</option>' +
                    tipsDates.map(d => {
                        const count = allMatches.filter(m => m.data === d && !m.risultato).length;
                        return `<option value="${d}">${d} (${count} partite)</option>`;
                    }).join('');

                document.getElementById('tips-days-info').textContent = `Giornate disponibili: ${tipsDates.length}`;
            }

            function updateResultsDaysList() {
                const resultsDates = [...new Set(allMatches.filter(m => m.risultato).map(m => m.data))].sort().reverse();
                const select = document.getElementById('delete-results-date');
                select.innerHTML = '<option value="">Seleziona una data...</option>' +
                    resultsDates.map(d => {
                        const count = allMatches.filter(m => m.data === d && m.risultato).length;
                        return `<option value="${d}">${d} (${count} risultati)</option>`;
                    }).join('');

                document.getElementById('results-days-info').textContent = `Giornate con risultati: ${resultsDates.length}`;
            }


            // ==================== SAVED RANKINGS VIEWER (OLD - DISABLED) ====================
            // let savedRankingData = null;

            /* DISABLED - OLD EVENT LISTENER FOR REMOVED BUTTON
            document.getElementById('load-ranking-btn').addEventListener('click', async () => {
                const selectedDate = document.getElementById('ranking-date-selector').value;
                if (!selectedDate) {
                    alert('Seleziona una data!');
                    return;
                }

                try {
                    const rankingDoc = await getDoc(doc(db, "rankings", selectedDate));
                    if (!rankingDoc.exists()) {
                        alert(`Nessun ranking salvato per la data ${selectedDate}`);
                        document.getElementById('ranking-strategies-list').classList.add('hidden');
                        document.getElementById('ranking-matches-detail').classList.add('hidden');
                        return;
                    }

                    savedRankingData = rankingDoc.data();
                    const strategies = savedRankingData.strategies;

                    // Display strategies list
                    const strategiesGrid = document.getElementById('ranking-strategies-grid');
                    strategiesGrid.innerHTML = '';

                    Object.keys(strategies).forEach(stratId => {
                        const strat = strategies[stratId];
                        const card = document.createElement('button');
                        card.className = 'bg-white p-4 rounded-lg shadow border-2 border-purple-200 hover:border-purple-400 hover:shadow-lg transition-all text-left';
                        card.innerHTML = `
                            <div class="font-bold text-sm text-gray-800 mb-1">${strat.name}</div>
                            <div class="text-xs text-gray-600">${strat.totalMatches} partite</div>
                        `;
                        card.addEventListener('click', () => displayRankingMatches(stratId, strat));
                        strategiesGrid.appendChild(card);
                    });

                    document.getElementById('ranking-strategies-list').classList.remove('hidden');
                    document.getElementById('ranking-matches-detail').classList.add('hidden');
                } catch (e) {
                    console.error('Error loading ranking:', e);
                    alert('Errore caricamento ranking: ' + e.message);
                }
            });
            */



            document.getElementById('ranking-back-btn').addEventListener('click', () => {
                document.getElementById('ranking-strategies-list').classList.remove('hidden');
                document.getElementById('ranking-matches-detail').classList.add('hidden');
            });

            // Set default date to today (OLD - DISABLED)
            // document.getElementById('ranking-date-selector').valueAsDate = new Date();

            document.getElementById('delete-tips-day-btn').addEventListener('click', async () => {
                const selectedDate = document.getElementById('delete-tips-date').value;
                if (!selectedDate) {
                    showModal("Errore", "Seleziona una data!", () => { });
                    return;
                }

                const toDelete = allMatches.filter(m => m.data === selectedDate && !m.risultato);

                showModal(
                    "Conferma Cancellazione",
                    `Eliminare ${toDelete.length} partite del ${selectedDate} senza risultati?`,
                    async () => {
                        const batch = writeBatch(db);
                        toDelete.forEach(m => {
                            batch.delete(doc(db, "matches", m.id));
                        });

                        try {
                            await batch.commit();
                            showModal("Successo", `${toDelete.length} partite eliminate!`, () => { });
                            await loadAllMatches();
                            populateFilters();
                            applyFiltersAndRender();
                            updateTipsDaysList();
                        } catch (e) {
                            showModal("Errore", `Errore: ${e.message}`, () => { });
                        }
                    }
                );
            });

            document.getElementById('delete-results-day-btn').addEventListener('click', async () => {
                const selectedDate = document.getElementById('delete-results-date').value;
                if (!selectedDate) {
                    showModal("Errore", "Seleziona una data!", () => { });
                    return;
                }

                const toDelete = allMatches.filter(m => m.data === selectedDate && m.risultato);

                showModal(
                    "Conferma Cancellazione",
                    `Eliminare ${toDelete.length} risultati del ${selectedDate}? Le partite torneranno senza risultato.`,
                    async () => {
                        const batch = writeBatch(db);
                        toDelete.forEach(m => {
                            batch.update(doc(db, "matches", m.id), { risultato: '', esito: '' });
                        });

                        try {
                            await batch.commit();
                            showModal("Successo", `${toDelete.length} risultati eliminati!`, () => { });
                            await loadAllMatches();
                            populateFilters();
                            applyFiltersAndRender();
                            updateResultsDaysList();
                        } catch (e) {
                            showModal("Errore", `Errore: ${e.message}`, () => { });
                        }
                    }
                );
            });

            // ==================== RANKING ====================

            // v3.5.3: State globale per visualizzazione ranking (DEVE essere qui!)
            let currentRankingView = 'by-tip'; // 'by-tip' o 'by-time'
            let currentRankingData = null; // Salva dati ranking per toggle

            document.getElementById('generate-ranking-btn').addEventListener('click', async () => {
                const rankingDate = document.getElementById('ranking-date').value;
                const maxMatches = parseInt(document.getElementById('ranking-max-matches').value);
                const selectedFilterId = document.getElementById('ranking-filter-select').value;

                if (!rankingDate) {
                    alert('Seleziona data!');
                    return;
                }

                const resultsContainer = document.getElementById('ranking-results');
                resultsContainer.innerHTML = '<div class="bg-white p-6 rounded-xl shadow text-center"><div class="animate-pulse text-lg">üîÑ Generazione ranking... <br><span class="text-sm text-gray-500">(Recupero orari in corso...)</span></div></div>';

                try {
                    // Partite del giorno senza risultato
                    let todayMatches = allMatches.filter(m => m.data === rankingDate && !m.risultato);

                    // APPLICA FILTRO SE SELEZIONATO
                    let filterName = "Tutte le partite";

                    // FILTRO SPECIALE: BEST 0.5 HT
                    if (selectedFilterId === 'BEST_05HT') {
                        filterName = "‚ö° BEST 0.5 HT (Auto)";

                        todayMatches = todayMatches.filter(m => {
                            // Requisito 1: HT prob disponibile e >= 70%
                            if (!m.info_ht || m.info_ht.trim() === '') return false;
                            const htMatch = m.info_ht.match(/(\d+)%/);
                            if (!htMatch) return false;
                            const htProb = parseInt(htMatch[1]);
                            if (htProb < 70) return false;

                            // Requisito 2: Tip Over (squadre prolifiche)
                            if (!m.tip.startsWith('+')) return false;

                            return true;
                        });
                    }
                    // FILTRI NORMALI
                    else if (selectedFilterId) {
                        const selectedFilter = savedFilters.find(f => f.id === selectedFilterId);
                        if (selectedFilter) {
                            filterName = selectedFilter.name;
                            // Normalize state (Public uses probRange/oddsRange, Local uses prob/odds)
                            const s = selectedFilter.state;
                            const leagues = s.leagues || [];
                            const tips = s.tips || [];
                            const prob = s.prob || s.probRange;
                            const odds = s.odds || s.oddsRange;

                            // Applica filtri
                            todayMatches = todayMatches.filter(m => {
                                // Filtro leghe
                                if (leagues && leagues.length > 0) {
                                    if (!leagues.includes(m.lega)) return false;
                                }

                                // Filtro tips
                                if (tips && tips.length > 0) {
                                    if (!tips.includes(m.tip)) return false;
                                }

                                // Filtro probabilit√†
                                if (prob) {
                                    const [minProb, maxProb] = prob.map(v => parseInt(v));
                                    if (m.probabilita < minProb || m.probabilita > maxProb) return false;
                                }

                                // Filtro odds
                                if (odds) {
                                    const [minOdds, maxOdds] = odds.map(v => parseFloat(v));
                                    if (m.quota < minOdds || m.quota > maxOdds) return false;
                                }

                                return true;
                            });
                        }
                    }

                    if (todayMatches.length === 0) {
                        resultsContainer.innerHTML = '<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita per quella data con i filtri selezionati!</div>';
                        return;
                    }

                    const leaguePerformance = analyzeLeaguePerformance(allMatches);

                    // Calcola score per tutte le partite
                    const rankedMatches = todayMatches.map(m => {
                        // Se filtro BEST 0.5 HT, usa score speciale
                        const score = selectedFilterId === 'BEST_05HT'
                            ? calculateScore05HT(m, allMatches)
                            : calculateScore(m, new Set([m.lega.toLowerCase()]), new Set([m.tip]), leaguePerformance, allMatches);
                        return {
                            ...m,
                            score: score.totalScore,
                            scoreDetails: score // Salva dettagli per tooltip
                        };
                    }).filter(m => m.score > 0); // Solo partite con score > 0

                    if (rankedMatches.length === 0) {
                        resultsContainer.innerHTML = `<div class="bg-yellow-50 p-6 rounded-xl text-center">‚ö†Ô∏è Nessuna partita disponibile con i filtri selezionati</div>`;
                        return;
                    }

                    // Raggruppa per tip
                    const byTip = {};
                    rankedMatches.forEach(m => {
                        if (!byTip[m.tip]) byTip[m.tip] = [];
                        byTip[m.tip].push(m);
                    });

                    // Ordina ogni gruppo per score
                    Object.keys(byTip).forEach(tip => {
                        byTip[tip].sort((a, b) => b.score - a.score);
                        byTip[tip] = byTip[tip].slice(0, maxMatches);
                    });

                    // CARICA ORARI da Firebase cache temporanea
                    const allRankedMatches = Object.values(byTip).flat();
                    let loadedTimes = 0;

                    for (let match of allRankedMatches) {
                        const ora = await getTimeFromCache(match.data, match.partita);
                        if (ora) {
                            match.time = ora;
                            loadedTimes++;
                        }
                    }

                    console.log(`[CACHE] Orari recuperati: ${loadedTimes}/${allRankedMatches.length}`);

                    if (loadedTimes === 0) {
                        console.log('[INFO] Nessun orario in cache. Carica CSV con colonna "Ora".');
                    }
                    if (loadedTimes > 0) {
                        console.log(`Loaded ${loadedTimes} match times for ranking`);
                    }

                    // SALVA DATI PER TRACKING
                    lastGeneratedRanking = {
                        timestamp: new Date().toISOString(),
                        data_partite: rankingDate,
                        filtro_nome: filterName,
                        filtro_id: selectedFilterId || null,
                        partite_by_tip: {},
                        stats: {
                            totale_partite: rankedMatches.length,
                            tips_count: Object.keys(byTip).length
                        }
                    };

                    // Organizza partite per tip
                    Object.keys(byTip).forEach(tip => {
                        lastGeneratedRanking.partite_by_tip[tip] = byTip[tip].map(m => ({
                            partita: m.partita,
                            lega: m.lega,
                            tip: m.tip,
                            mercato: m.mercato,
                            quota: m.quota,
                            probabilita: m.probabilita,
                            score: m.score,
                            esito: null // Verr√† aggiornato quando carichi risultati
                        }));
                    });

                    // v3.5.3: Salva dati per toggle visualizzazione
                    currentRankingData = {
                        byTip,
                        rankingDate,
                        filterName,
                        rankedMatches,
                        todayMatches,
                        selectedFilterId,
                        maxMatches
                    };

                    // v3.5.3: Render default (per tip)
                    currentRankingView = 'by-tip';
                    renderRankingByTip(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId, maxMatches);

                } catch (e) {
                    console.error('Error:', e);
                    resultsContainer.innerHTML = `<div class="bg-red-50 p-6 rounded-xl text-center">‚ùå Errore: ${e.message}</div>`;
                }
            });

            // ==================== v3.5.3: VISUALIZZAZIONE RANKING & ORDINAMENTO ====================

            // v3.5.3: Funzione setup tooltip listeners (riattiva dopo re-render)
            function setupTooltipListeners() {
                // Tooltip gi√† gestiti da event delegation globale nel codice esistente
                // Questa funzione √® placeholder per compatibilit√†
            }

            // Funzione render ranking per tip (default)
            function renderRankingByTip(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId, maxMatches) {
                const resultsContainer = document.getElementById('ranking-results');
                const toggleContainer = document.getElementById('ranking-view-toggle');

                // Mostra toggle
                toggleContainer.classList.remove('hidden');

                // Render tip blocks (codice esistente)
                const tipBlocks = Object.keys(byTip).sort().map(tip => {
                    const matches = byTip[tip];
                    const sectionTitle = selectedFilterId === 'BEST_05HT' ? '‚ö° BEST 0.5 HT' : `üìä ${tip}`;
                    const sectionSubtitle = selectedFilterId === 'BEST_05HT'
                        ? `${matches.length} partite selezionate automaticamente`
                        : `${matches.length} partite (max ${maxMatches} per tip)`;

                    return `
                        <div class="bg-white p-6 rounded-xl shadow mb-6">
                            <h3 class="text-2xl font-bold mb-3">${sectionTitle}</h3>
                            <div class="text-sm text-gray-600 mb-4">${sectionSubtitle}</div>
                            <div class="space-y-3">
                                ${matches.map((m, idx) => renderMatchCard(m, idx, selectedFilterId)).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                resultsContainer.innerHTML = `
                    <div class="mb-6 bg-gradient-to-r from-purple-500 to-blue-500 text-white p-6 rounded-xl shadow">
                        <h2 class="text-3xl font-bold mb-2">üèÜ Ranking ${rankingDate}</h2>
                        <div class="text-lg mb-1">üìä Filtro: <span class="font-bold">${filterName}</span></div>
                        <div class="text-sm opacity-90 mb-3">
                            ‚úÖ ${rankedMatches.length} partite totali su ${todayMatches.length} filtrate ‚Ä¢ ${Object.keys(byTip).length} tip diverse
                        </div>
                        <button id="save-ranking-btn" class="bg-white text-purple-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                            <i class="fa-solid fa-save mr-2"></i>Salva Ranking per Tracking ML
                        </button>
                        <button id="export-csv-btn" class="bg-white text-blue-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md">
                            <i class="fa-solid fa-download mr-2"></i>Esporta CSV Strategie
                        </button>
                    </div>
                    ${tipBlocks}
                `;

                // Re-attach event listeners
                document.getElementById('save-ranking-btn').addEventListener('click', saveRankingForTracking);
                document.getElementById('export-csv-btn').addEventListener('click', exportRankingCSV);

                // Riattiva tooltips
                setupTooltipListeners();
            }

            // Funzione render ranking per orario
            function renderRankingByTime(byTip, rankingDate, filterName, rankedMatches, todayMatches, selectedFilterId) {
                const resultsContainer = document.getElementById('ranking-results');
                const toggleContainer = document.getElementById('ranking-view-toggle');

                // Mostra toggle
                toggleContainer.classList.remove('hidden');

                // Flatten e ordina per orario
                const allMatches = Object.values(byTip).flat();
                const matchesByTime = {};

                allMatches.forEach(m => {
                    const timeKey = m.time && m.time.trim() !== '' ? m.time : '‚è∞ Orario non disponibile';
                    if (!matchesByTime[timeKey]) matchesByTime[timeKey] = [];
                    matchesByTime[timeKey].push(m);
                });

                // Ordina keys per orario
                const sortedTimes = Object.keys(matchesByTime).sort((a, b) => {
                    if (a === '‚è∞ Orario non disponibile') return 1;
                    if (b === '‚è∞ Orario non disponibile') return -1;
                    return a.localeCompare(b);
                });

                const timeBlocks = sortedTimes.map(time => {
                    const matches = matchesByTime[time];
                    // Ordina per score dentro ogni orario
                    matches.sort((a, b) => b.score - a.score);

                    return `
                        <div class="bg-white p-6 rounded-xl shadow mb-6">
                            <h3 class="text-2xl font-bold mb-3">‚è∞ ${time}</h3>
                            <div class="text-sm text-gray-600 mb-4">${matches.length} partite</div>
                            <div class="space-y-3">
                                ${matches.map((m, idx) => renderMatchCard(m, idx, selectedFilterId, true)).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                resultsContainer.innerHTML = `
                    <div class="mb-6 bg-gradient-to-r from-purple-500 to-blue-500 text-white p-6 rounded-xl shadow">
                        <h2 class="text-3xl font-bold mb-2">üèÜ Ranking ${rankingDate}</h2>
                        <div class="text-lg mb-1">üìä Filtro: <span class="font-bold">${filterName}</span></div>
                        <div class="text-sm opacity-90 mb-3">
                            ‚úÖ ${rankedMatches.length} partite totali su ${todayMatches.length} filtrate
                        </div>
                        <button id="save-ranking-btn" class="bg-white text-purple-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md mr-3">
                            <i class="fa-solid fa-save mr-2"></i>Salva Ranking per Tracking ML
                        </button>
                        <button id="export-csv-btn" class="bg-white text-blue-600 px-6 py-2 rounded-lg font-bold hover:bg-gray-100 transition-all shadow-md">
                            <i class="fa-solid fa-download mr-2"></i>Esporta CSV Strategie
                        </button>
                    </div>
                    ${timeBlocks}
                `;

                // Re-attach event listeners
                document.getElementById('save-ranking-btn').addEventListener('click', saveRankingForTracking);
                document.getElementById('export-csv-btn').addEventListener('click', exportRankingCSV);

                // Riattiva tooltips
                setupTooltipListeners();
            }

            // Funzione render singola card match (riutilizzabile)
            function renderMatchCard(m, idx, selectedFilterId, showTip = false) {
                const [team1, team2] = m.partita.split(' - ');
                const team1Stats = analyzeTeamStats(team1, true, m.tip, allMatches);
                const team2Stats = analyzeTeamStats(team2, false, m.tip, allMatches);

                // HT indicator
                let htIndicator = '';
                if (m.info_ht && m.info_ht.trim() !== '') {
                    const probMatch = m.info_ht.match(/(\d+)%/);
                    if (probMatch) {
                        const htProb = parseInt(probMatch[1]);
                        if (htProb >= 70) {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-green-100 text-green-700 px-2 py-1 rounded font-bold">‚ö° HT: ${m.info_ht}</span></div>`;
                        } else if (htProb >= 55) {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-yellow-100 text-yellow-700 px-2 py-1 rounded">üí° HT: ${m.info_ht}</span></div>`;
                        } else {
                            htIndicator = `<div class="text-xs mt-1"><span class="bg-gray-100 text-gray-600 px-2 py-1 rounded">üìä HT: ${m.info_ht}</span></div>`;
                        }
                    }
                }

                // Betfair badge
                const betfairBadge = generateBetfairBadge(m, selectedFilterId === 'BEST_05HT', team1Stats, team2Stats);
                let betfairDisplay = '';
                if (betfairBadge) {
                    const icon = selectedFilterId === 'BEST_05HT' ? '‚ö°' : 'üü£';
                    betfairDisplay = `<div class="mt-2"><span class="px-3 py-1 rounded-full text-xs font-bold border ${betfairBadge.color}">${icon} ${betfairBadge.text}</span></div>`;
                }

                // Formato display TIP FT
                const tipDisplay = showTip ? `${m.tip} FT` : `${m.tip} FT`;

                return `
                    <div class="border rounded-lg p-4 ${(m.score || 0) < 30 ? 'bg-red-50 border-red-200' : 'bg-white hover:bg-gray-50'}">
                        <div class="flex justify-between items-start mb-3">
                            <div class="flex-1">
                                <div class="flex justify-between items-start">
                                    <div class="font-bold text-lg">
                                        ${idx + 1}. 
                                        <span class="team-${team1Stats.color}">${team1}</span>
                                        - 
                                        <span class="team-${team2Stats.color}">${team2}</span>
                                    </div>
                                </div>
                                <div class="text-sm text-gray-600 flex items-center gap-2">
                                    ${m.time && m.time.trim() !== '' ? `<span class="text-gray-900 font-bold">‚è∞ ${m.time}</span> | ` : ''}
                                    ${m.lega}
                                </div>
                                <div class="text-sm mt-1">
                                    <span class="bg-blue-100 px-2 py-1 rounded text-xs font-semibold">${tipDisplay}</span>
                                    <span class="ml-2 font-bold">@${m.quota.toFixed(2)}</span>
                                    <span class="ml-2 text-gray-500">${m.probabilita}%</span>
                                </div>
                                ${htIndicator}
                            </div>
                            <div class="text-right">
                                <div class="score-badge">${m.score || 0}</div>
                                <div class="text-xs text-gray-500 mt-1 relative inline-block">
                                    <span class="tooltip-trigger cursor-help"
                                          data-tooltip-type="stats"
                                          data-mercato="${m.mercato || ''}"
                                          data-tip="${m.tip || ''}"
                                          data-home-count="${team1Stats.count || 0}"
                                          data-home-total="${team1Stats.total || 0}"
                                          data-away-count="${team2Stats.count || 0}"
                                          data-away-total="${team2Stats.total || 0}"
                                          data-home-perc="${team1Stats.percentage || 0}"
                                          data-away-perc="${team2Stats.percentage || 0}"
                                          data-home-penalty="${team1Stats.penalty || 0}"
                                          data-away-penalty="${team2Stats.penalty || 0}"
                                          data-home-score="${team1Stats.scoreValue || 0}"
                                          data-away-score="${team2Stats.scoreValue || 0}"
                                          data-home-details="${team1Stats.details || ''}"
                                          data-away-details="${team2Stats.details || ''}">
                                        ${team1Stats.stats} | ${team2Stats.stats}
                                    </span>
                                    <span class="ml-1 text-blue-500 cursor-help tooltip-trigger"
                                          data-tooltip-type="stats"
                                          data-mercato="${m.mercato || ''}"
                                          data-tip="${m.tip || ''}"
                                          data-home-count="${team1Stats.count || 0}"
                                          data-home-total="${team1Stats.total || 0}"
                                          data-away-count="${team2Stats.count || 0}"
                                          data-away-total="${team2Stats.total || 0}"
                                          data-home-perc="${team1Stats.percentage || 0}"
                                          data-away-perc="${team2Stats.percentage || 0}"
                                          data-home-penalty="${team1Stats.penalty || 0}"
                                          data-away-penalty="${team2Stats.penalty || 0}"
                                          data-home-score="${team1Stats.scoreValue || 0}"
                                          data-away-score="${team2Stats.scoreValue || 0}"
                                          data-home-details="${team1Stats.details || ''}"
                                          data-away-details="${team2Stats.details || ''}"
                                          title="Hover per dettagli">
                                        ‚ÑπÔ∏è
                                    </span>
                                </div>
                            </div>
                        </div>
                        ${betfairDisplay}
                        ${(m.score || 0) < 30 ? '<div class="mt-2"><span class="bg-red-500 text-white text-xs px-2 py-1 rounded font-bold">‚ö†Ô∏è Score Basso - Poco Affidabile</span></div>' : ''}
                    </div>
                `;
            }

            // Event listeners toggle visualizzazione ranking
            document.addEventListener('click', (e) => {
                if (e.target.id === 'view-by-tip-btn' || e.target.closest('#view-by-tip-btn')) {
                    if (currentRankingView === 'by-tip') return;
                    currentRankingView = 'by-tip';

                    // Update buttons
                    document.getElementById('view-by-tip-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white';
                    document.getElementById('view-by-time-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300';

                    // Re-render
                    if (currentRankingData) {
                        renderRankingByTip(
                            currentRankingData.byTip,
                            currentRankingData.rankingDate,
                            currentRankingData.filterName,
                            currentRankingData.rankedMatches,
                            currentRankingData.todayMatches,
                            currentRankingData.selectedFilterId,
                            currentRankingData.maxMatches
                        );
                    }
                } else if (e.target.id === 'view-by-time-btn' || e.target.closest('#view-by-time-btn')) {
                    if (currentRankingView === 'by-time') return;
                    currentRankingView = 'by-time';

                    // Update buttons
                    document.getElementById('view-by-tip-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-gray-200 text-gray-700 hover:bg-gray-300';
                    document.getElementById('view-by-time-btn').className = 'flex-1 py-2 px-4 rounded-lg font-semibold transition-all bg-blue-600 text-white';

                    // Re-render
                    if (currentRankingData) {
                        renderRankingByTime(
                            currentRankingData.byTip,
                            currentRankingData.rankingDate,
                            currentRankingData.filterName,
                            currentRankingData.rankedMatches,
                            currentRankingData.todayMatches,
                            currentRankingData.selectedFilterId
                        );
                    }
                }
            });

            // Funzione export CSV ranking
            function exportRankingCSV() {
                if (!currentRankingData) return;

                const csvData = [];
                csvData.push(['Data', 'Lega', 'Partita', 'Tip', 'Quota', 'Prob%', 'HT', 'Ora', 'Score', 'Betfair'].join(','));

                Object.keys(currentRankingData.byTip).forEach(tip => {
                    currentRankingData.byTip[tip].forEach(m => {
                        const [team1, team2] = m.partita.split(' - ');
                        const team1Stats = analyzeTeamStats(team1, true, m.tip, allMatches);
                        const team2Stats = analyzeTeamStats(team2, false, m.tip, allMatches);
                        const betfairBadge = generateBetfairBadge(m, currentRankingData.selectedFilterId === 'BEST_05HT', team1Stats, team2Stats);
                        const betfairText = betfairBadge ? betfairBadge.text : 'N/A';
                        const htInfo = m.info_ht || '-';
                        const time = m.time || '-';

                        csvData.push([
                            m.id, // Add ID here
                            m.data,
                            `"${m.lega}"`,
                            `"${m.partita}"`,
                            m.tip,
                            m.quota.toFixed(2),
                            m.probabilita,
                            htInfo,
                            time,
                            m.score,
                            betfairText
                        ].join(','));
                    });
                });

                const csvContent = csvData.join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `ranking_${currentRankingData.rankingDate}_${currentRankingData.filterName.replace(/\s+/g, '_')}.csv`;
                link.click();
            }

            // Ordinamento Dashboard
            document.getElementById('dashboard-sort-select')?.addEventListener('change', (e) => {
                const sortBy = e.target.value;
                applyFiltersAndRender(sortBy);
            });

            // ==================== STORICO PREVISIONI ====================

            // Carica previsioni per data specifica
            async function loadStorico(date) {
                const storicoList = document.getElementById('storico-strategie-list');
                const storicoContainer = document.getElementById('storico-strategie-container');
                const storicoDateTitle = document.getElementById('storico-date-title');
                const storicoCount = document.getElementById('storico-count');
                const storicoDettaglio = document.getElementById('storico-dettaglio');
                const storicoStatsGlobali = document.getElementById('storico-stats-globali');

                storicoList.classList.remove('hidden');
                storicoDettaglio.classList.add('hidden');
                storicoStatsGlobali.classList.add('hidden');
                storicoContainer.innerHTML = '<div class="text-center py-4"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento...</div>';

                try {
                    // USE DIRECT getDoc INSTEAD OF QUERY (date is the document ID)
                    const docRef = doc(db, "ranking_history", date);
                    const docSnap = await getDoc(docRef);

                    if (!docSnap.exists()) {
                        storicoDateTitle.textContent = `Previsioni del ${date}`;
                        storicoCount.textContent = 'Nessuna previsione salvata';
                        storicoContainer.innerHTML = `
                            <div class="text-center py-8 text-gray-500">
                                <i class="fa-solid fa-inbox text-4xl mb-3"></i>
                                <p>Nessuna previsione salvata per questa data.</p>
                                <p class="text-sm mt-2">Vai su Ranking o Magic per generare e salvare previsioni.</p>
                            </div>
                        `;
                        return;
                    }

                    const docData = { id: docSnap.id, ...docSnap.data() };
                    const rankings = [docData]; // Single document array for compatibility

                    // Count total strategies across all documents
                    let totalStrategies = 0;
                    rankings.forEach(docData => {
                        if (Array.isArray(docData.strategies)) {
                            totalStrategies += docData.strategies.length;
                        } else if (docData.strategies && typeof docData.strategies === 'object') {
                            totalStrategies += Object.keys(docData.strategies).length;
                        }
                    });

                    storicoDateTitle.innerHTML = `Previsioni del ${date} <button id="delete-date-btn" class="ml-3 bg-red-500 hover:bg-red-600 text-white text-sm px-3 py-1 rounded" title="Cancella tutte le strategie di questa giornata"><i class="fa-solid fa-trash mr-1"></i>Cancella Giornata</button>`;
                    storicoCount.textContent = `${totalStrategies} strategie salvate`;

                    // Event listener cancella giornata
                    document.getElementById('delete-date-btn').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (!confirm(`‚ö†Ô∏è ATTENZIONE!\n\nVuoi cancellare TUTTE le ${totalStrategies} strategie del ${date}?\n\nQuesta azione √® IRREVERSIBILE e pu√≤ influenzare il machine learning futuro.`)) return;

                        try {
                            const batch = [];
                            for (const ranking of rankings) {
                                const docRef = doc(db, "ranking_history", ranking.id);
                                batch.push(deleteDoc(docRef));
                            }
                            await Promise.all(batch);

                            showModal("‚úÖ Cancellato!", `Tutte le ${rankings.length} strategie del ${date} sono state eliminate.`, () => {
                                // Ricarica storico
                                storicoList.classList.add('hidden');
                            });
                        } catch (e) {
                            showModal("Errore", `Errore cancellazione: ${e.message}`, () => { });
                        }
                    });

                    // Calcola stats per ogni strategia
                    const strategieCards = rankings.flatMap(docData => {
                        let strategiesList = [];
                        if (Array.isArray(docData.strategies)) {
                            strategiesList = docData.strategies;
                        } else if (docData.strategies && typeof docData.strategies === 'object') {
                            strategiesList = Object.values(docData.strategies);
                        }

                        console.log(`[loadStorico] Document ${docData.id}: ${strategiesList.length} strategies found`);
                        if (strategiesList.length === 0) return [];

                        return strategiesList.map(ranking => {
                            // RESILIENT: If partite_by_tip is missing, default to empty array instead of hiding
                            let allPartite = [];
                            if (ranking.partite_by_tip) {
                                allPartite = Object.values(ranking.partite_by_tip).flat();
                            } else {
                                console.warn(`[loadStorico] Strategia "${ranking.filtro_nome || ranking.name}" senza partite_by_tip, fallback to matches`);
                                // Try to use ranking.matches if available (fallback)
                                if (ranking.matches && Array.isArray(ranking.matches)) {
                                    allPartite = ranking.matches;
                                }
                            }

                            console.log(`[loadStorico] Strategy "${ranking.filtro_nome || ranking.name}": ${allPartite.length} matches`);

                            const vinte = allPartite.filter(p => p.esito === 'Vinto').length;
                            const perse = allPartite.filter(p => p.esito === 'Perso').length;
                            const pending = allPartite.filter(p => !p.esito || p.esito === 'PENDING').length;
                            const totConEsito = vinte + perse;
                            const winRate = totConEsito > 0 ? Math.round((vinte / totConEsito) * 100) : null;

                            // Determina icona e colore
                            let icon = 'üìä';
                            let bgClass = 'bg-gray-50 hover:bg-gray-100';
                            let borderClass = 'border-gray-200';

                            if (ranking.magic_type === 'singole') {
                                icon = 'üéØ';
                                bgClass = 'bg-green-50 hover:bg-green-100';
                                borderClass = 'border-green-300';
                            } else if (ranking.magic_type === 'trading') {
                                icon = 'üìà';
                                bgClass = 'bg-blue-50 hover:bg-blue-100';
                                borderClass = 'border-blue-300';
                            }

                            // Stats badge
                            let statsBadge = '';
                            if (totConEsito > 0) {
                                const winColor = winRate >= 70 ? 'bg-green-500' : winRate >= 50 ? 'bg-yellow-500' : 'bg-red-500';
                                statsBadge = `
                                <div class="flex items-center gap-2 mt-2">
                                    <span class="text-green-600 font-bold">${vinte}W</span>
                                    <span class="text-red-600 font-bold">${perse}L</span>
                                    ${pending > 0 ? `<span class="text-gray-500">${pending}P</span>` : ''}
                                    <span class="${winColor} text-white text-xs px-2 py-1 rounded-full font-bold">${winRate}%</span>
                                </div>
                            `;
                            } else if (pending > 0) {
                                statsBadge = `<div class="text-sm text-gray-500 mt-2"><i class="fa-solid fa-clock mr-1"></i>${pending} partite in attesa risultati</div>`;
                            }

                            return `
                            <div class="p-4 rounded-lg border-2 ${borderClass} ${bgClass} transition-all storico-strategia-card" 
                                 data-ranking-id="${ranking.id}">
                                <div class="flex justify-between items-start">
                                    <div class="flex-1 cursor-pointer storico-card-clickable">
                                        <div class="flex items-center gap-2">
                                            <span class="text-2xl">${icon}</span>
                                            <div>
                                                <div class="font-bold text-lg">${ranking.filtro_nome}</div>
                                                <div class="text-sm text-gray-600">${allPartite.length} partite</div>
                                            </div>
                                        </div>
                                        ${statsBadge}
                                    </div>
                                    <div class="flex flex-col items-end gap-2">
                                        <button class="delete-strategy-btn text-red-500 hover:text-red-700 hover:bg-red-50 p-2 rounded" 
                                                data-strategy-id="${ranking.id}"
                                                data-strategy-name="${ranking.filtro_nome}"
                                                title="Cancella questa strategia">
                                            <i class="fa-solid fa-trash"></i>
                                        </button>
                                        <div class="text-xs text-gray-500">${new Date(ranking.lastCalculated || docData.generated).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}</div>
                                        <div class="cursor-pointer text-gray-400 hover:text-gray-600"><i class="fa-solid fa-chevron-right"></i></div>
                                    </div>
                                </div>
                            </div>
                        `;
                        }).join('');
                    }).join('');

                    storicoContainer.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">${strategieCards}</div>`;

                    // Event listeners per click area principale card
                    document.querySelectorAll('.storico-card-clickable').forEach(clickArea => {
                        clickArea.addEventListener('click', () => {
                            const card = clickArea.closest('.storico-strategia-card');
                            const rankingId = card.dataset.rankingId;
                            // Find strategy in nested structure
                            let ranking = null;
                            for (const doc of rankings) {
                                if (doc.strategies) {
                                    ranking = doc.strategies.find(r => r.id === rankingId);
                                    if (ranking) break;
                                }
                            }
                            if (ranking) showStoricoDettaglio(ranking);
                        });
                    });

                    // Event listeners per pulsanti cancella strategia
                    document.querySelectorAll('.delete-strategy-btn').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            const strategyId = btn.dataset.strategyId;
                            const strategyName = btn.dataset.strategyName;

                            if (!confirm(`‚ö†Ô∏è Cancellare la strategia "${strategyName}"?\n\nQuesta azione √® irreversibile e pu√≤ influenzare il ML futuro.`)) return;

                            try {
                                const docRef = doc(db, "ranking_history", strategyId);
                                await deleteDoc(docRef);

                                showModal("‚úÖ Cancellato!", `Strategia "${strategyName}" eliminata.`, () => {
                                    // Ricarica la data
                                    loadStorico(date);
                                });
                            } catch (e) {
                                showModal("Errore", `Errore cancellazione: ${e.message}`, () => { });
                            }
                        });
                    });

                    // Mostra stats globali se ci sono risultati
                    showStoricoStatsGlobali(rankings);

                } catch (e) {
                    console.error('Storico Error:', e);
                    storicoContainer.innerHTML = `<div class="text-center py-4 text-red-600">Errore: ${e.message}</div>`;
                }
            }

            // Mostra dettaglio strategia
            function showStoricoDettaglio(ranking) {
                const dettaglioEl = document.getElementById('storico-dettaglio');
                dettaglioEl.classList.remove('hidden');

                // Scroll to dettaglio
                dettaglioEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

                // Determina icona
                let icon = 'üìä';
                let gradientClass = 'from-gray-500 to-gray-600';
                if (ranking.magic_type === 'singole') {
                    icon = 'üéØ';
                    gradientClass = 'from-green-500 to-emerald-600';
                } else if (ranking.magic_type === 'trading') {
                    icon = 'üìà';
                    gradientClass = 'from-blue-500 to-indigo-600';
                }

                // Costruisci lista partite per tip
                const tipSections = Object.keys(ranking.partite_by_tip).map(tip => {
                    const partite = ranking.partite_by_tip[tip];

                    const partiteRows = partite.map(p => {
                        let esitoClass = 'bg-gray-100 text-gray-600';
                        let esitoIcon = '‚è≥';
                        let esitoBorder = 'border-gray-200';

                        if (p.esito === 'Vinto') {
                            esitoClass = 'bg-green-100 text-green-700';
                            esitoIcon = '‚úÖ';
                            esitoBorder = 'border-green-300';
                        } else if (p.esito === 'Perso') {
                            esitoClass = 'bg-red-100 text-red-700';
                            esitoIcon = '‚ùå';
                            esitoBorder = 'border-red-300';
                        }

                        return `
                            <div class="p-3 rounded-lg border ${esitoBorder} ${esitoClass} mb-2">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-bold">${p.partita}</div>
                                        <div class="text-xs opacity-75">${p.lega}</div>
                                        ${p.risultato ? `<div class="text-sm font-bold mt-1">‚öΩ Risultato: ${p.risultato}</div>` : ''}
                                    </div>
                                    <div class="text-right">
                                        <div class="text-lg">${esitoIcon}</div>
                                        <div class="text-xs">Tip: ${p.tip} @${p.quota?.toFixed(2) || '-'}</div>
                                        <div class="text-xs">Prob: ${p.probabilita || '-'}%</div>
                                        <div class="text-xs font-bold">Score: ${p.score || '-'}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    // Stats per tip
                    const vinte = partite.filter(p => p.esito === 'Vinto').length;
                    const perse = partite.filter(p => p.esito === 'Perso').length;
                    const pending = partite.filter(p => !p.esito || p.esito === 'PENDING').length;

                    return `
                        <div class="mb-6">
                            <div class="flex justify-between items-center mb-3">
                                <h4 class="text-lg font-bold">${tip}</h4>
                                <div class="text-sm">
                                    <span class="text-green-600 font-bold">${vinte}W</span> / 
                                    <span class="text-red-600 font-bold">${perse}L</span>
                                    ${pending > 0 ? ` / <span class="text-gray-500">${pending}P</span>` : ''}
                                </div>
                            </div>
                            ${partiteRows}
                        </div>
                    `;
                }).join('');

                // Stats totali
                const allPartite = Object.values(ranking.partite_by_tip).flat();
                const totVinte = allPartite.filter(p => p.esito === 'Vinto').length;
                const totPerse = allPartite.filter(p => p.esito === 'Perso').length;
                const totPending = allPartite.filter(p => !p.esito || p.esito === 'PENDING').length;
                const totConEsito = totVinte + totPerse;
                const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                dettaglioEl.innerHTML = `
                    <div class="bg-gradient-to-r ${gradientClass} text-white p-4 rounded-t-xl">
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="text-2xl mr-2">${icon}</span>
                                <span class="text-xl font-bold">${ranking.filtro_nome}</span>
                            </div>
                            <button id="close-dettaglio-btn" class="bg-white/20 hover:bg-white/30 px-3 py-1 rounded-lg text-sm">
                                <i class="fa-solid fa-times mr-1"></i>Chiudi
                            </button>
                        </div>
                        <div class="mt-2 text-sm opacity-90">
                            üìÖ ${ranking.data_partite} ‚Ä¢ ${allPartite.length} partite ‚Ä¢ 
                            Salvato alle ${new Date(ranking.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}
                        </div>
                        ${winRate !== null ? `
                            <div class="mt-3 flex items-center gap-4">
                                <span class="bg-white/20 px-3 py-1 rounded-lg">
                                    <span class="font-bold">${totVinte}</span> Vinte
                                </span>
                                <span class="bg-white/20 px-3 py-1 rounded-lg">
                                    <span class="font-bold">${totPerse}</span> Perse
                                </span>
                                <span class="bg-white text-gray-800 px-3 py-1 rounded-lg font-bold">
                                    ${winRate}% Win Rate
                                </span>
                            </div>
                        ` : totPending > 0 ? `
                            <div class="mt-3 text-sm">
                                <i class="fa-solid fa-clock mr-1"></i>${totPending} partite in attesa risultati
                            </div>
                        ` : ''}
                    </div>
                    <div class="bg-white rounded-b-xl shadow-md border border-gray-200 p-4">
                        ${tipSections}
                    </div>
                `;

                // Close button
                document.getElementById('close-dettaglio-btn').addEventListener('click', () => {
                    dettaglioEl.classList.add('hidden');
                });
            }

            // Stats globali per tutte le strategie della data
            function showStoricoStatsGlobali(rankings) {
                const statsEl = document.getElementById('storico-stats-globali');
                const statsContent = document.getElementById('storico-stats-content');

                // Calcola totali
                let totPartite = 0;
                let totVinte = 0;
                let totPerse = 0;
                let totPending = 0;

                rankings.forEach(docData => {
                    if (docData.strategies && Array.isArray(docData.strategies)) {
                        docData.strategies.forEach(r => {
                            if (r.partite_by_tip) {
                                const partite = Object.values(r.partite_by_tip).flat();
                                totPartite += partite.length;
                                totVinte += partite.filter(p => p.esito === 'Vinto').length;
                                totPerse += partite.filter(p => p.esito === 'Perso').length;
                                totPending += partite.filter(p => !p.esito || p.esito === 'PENDING').length;
                            }
                        });
                    }
                });

                const totConEsito = totVinte + totPerse;
                const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                if (totConEsito === 0) {
                    statsEl.classList.add('hidden');
                    return;
                }

                statsEl.classList.remove('hidden');

                const winRateColor = winRate >= 70 ? 'text-green-600' : winRate >= 50 ? 'text-yellow-600' : 'text-red-600';

                statsContent.innerHTML = `
                    <div class="bg-blue-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold text-blue-600">${totPartite}</div>
                        <div class="text-sm text-gray-600">Partite Totali</div>
                    </div>
                    <div class="bg-green-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold text-green-600">${totVinte}</div>
                        <div class="text-sm text-gray-600">Vinte</div>
                    </div>
                    <div class="bg-red-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold text-red-600">${totPerse}</div>
                        <div class="text-sm text-gray-600">Perse</div>
                    </div>
                    <div class="bg-purple-50 p-4 rounded-xl text-center">
                        <div class="text-3xl font-bold ${winRateColor}">${winRate}%</div>
                        <div class="text-sm text-gray-600">Win Rate</div>
                    </div>
                `;
            }

            // Carica ultime N giornate
            async function loadUltimeGiornate(n = 10) {
                const storicoList = document.getElementById('storico-strategie-list');
                const storicoContainer = document.getElementById('storico-strategie-container');
                const storicoDateTitle = document.getElementById('storico-date-title');
                const storicoCount = document.getElementById('storico-count');
                const storicoDettaglio = document.getElementById('storico-dettaglio');
                const storicoStatsGlobali = document.getElementById('storico-stats-globali');

                storicoList.classList.remove('hidden');
                storicoDettaglio.classList.add('hidden');
                storicoStatsGlobali.classList.add('hidden');
                storicoContainer.innerHTML = '<div class="text-center py-4"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Caricamento ultime giornate...</div>';

                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    const snapshot = await getDocs(rankingHistoryCol);

                    if (snapshot.empty) {
                        storicoDateTitle.textContent = 'Storico Completo';
                        storicoCount.textContent = 'Nessuna previsione salvata';
                        storicoContainer.innerHTML = `
                            <div class="text-center py-8 text-gray-500">
                                <i class="fa-solid fa-inbox text-4xl mb-3"></i>
                                <p>Nessuna previsione salvata nel sistema.</p>
                            </div>
                        `;
                        return;
                    }

                    // Raggruppa per data
                    const byDate = {};
                    snapshot.docs.forEach(doc => {
                        const data = doc.data();
                        const date = data.data_partite;
                        if (!byDate[date]) byDate[date] = [];
                        byDate[date].push({ id: doc.id, ...data });
                    });

                    // Ordina date e prendi ultime N
                    const sortedDates = Object.keys(byDate).sort().reverse().slice(0, n);

                    storicoDateTitle.textContent = `Ultime ${sortedDates.length} Giornate`;
                    storicoCount.textContent = `${snapshot.docs.length} strategie totali`;

                    // Costruisci cards per data
                    const dateCards = sortedDates.map(date => {
                        const rankings = byDate[date];

                        // Stats aggregate per data
                        let totVinte = 0, totPerse = 0, totPending = 0;
                        rankings.forEach(docData => {
                            if (docData.strategies && Array.isArray(docData.strategies)) {
                                docData.strategies.forEach(strategy => {
                                    if (strategy.partite_by_tip) {
                                        const partite = Object.values(strategy.partite_by_tip).flat();
                                        totVinte += partite.filter(p => p.esito === 'Vinto').length;
                                        totPerse += partite.filter(p => p.esito === 'Perso').length;
                                        totPending += partite.filter(p => !p.esito || p.esito === 'PENDING').length;
                                    }
                                });
                            }
                        });

                        const totConEsito = totVinte + totPerse;
                        const winRate = totConEsito > 0 ? Math.round((totVinte / totConEsito) * 100) : null;

                        let statsBadge = '';
                        if (winRate !== null) {
                            const winColor = winRate >= 70 ? 'bg-green-500' : winRate >= 50 ? 'bg-yellow-500' : 'bg-red-500';
                            statsBadge = `<span class="${winColor} text-white text-xs px-2 py-1 rounded-full ml-2">${winRate}% (${totVinte}/${totConEsito})</span>`;
                        }

                        if (totPending > 0) {
                            statsBadge += `<span class="bg-gray-400 text-white text-xs px-2 py-1 rounded-full ml-2">${totPending} Pending</span>`;
                        }

                        return `
                            <div class="p-4 rounded-lg border-2 border-gray-200 bg-gray-50 hover:bg-gray-100 cursor-pointer transition-all storico-date-card" 
                                 data-date="${date}">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-bold text-lg">üìÖ ${date} ${statsBadge}</div>
                                        <div class="text-sm text-gray-600">${rankings.length} strategie</div>
                                    </div>
                                    <div class="text-gray-400">
                                        <i class="fa-solid fa-chevron-right"></i>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                    storicoContainer.innerHTML = `<div class="space-y-3">${dateCards}</div>`;

                    // Event listeners
                    document.querySelectorAll('.storico-date-card').forEach(card => {
                        card.addEventListener('click', () => {
                            const date = card.dataset.date;
                            document.getElementById('storico-date').value = date;
                            loadStorico(date);
                        });
                    });

                } catch (e) {
                    console.error('Storico Error:', e);
                    storicoContainer.innerHTML = `<div class="text-center py-4 text-red-600">Errore: ${e.message}</div>`;
                }
            }

            // Event listeners Storico
            document.getElementById('load-storico-btn').addEventListener('click', () => {
                const date = document.getElementById('storico-date').value;
                if (!date) {
                    alert('Seleziona una data!');
                    return;
                }
                loadStorico(date);
            });

            document.getElementById('load-all-storico-btn').addEventListener('click', () => {
                loadUltimeGiornate(10);
            });

            // ==================== RANKING TRACKING & ML ====================
            async function saveRankingForTracking() {
                if (!lastGeneratedRanking) {
                    showModal("Errore", "Nessun ranking da salvare!", () => { });
                    return;
                }

                try {
                    const rankingHistoryCol = collection(db, "ranking_history");

                    // CONTROLLO SE ESISTE GI√Ä un ranking con stessa data + stesso filtro
                    const q = query(rankingHistoryCol,
                        where("data_partite", "==", lastGeneratedRanking.data_partite),
                        where("filtro_nome", "==", lastGeneratedRanking.filtro_nome)
                    );
                    const snapshot = await getDocs(q);

                    if (!snapshot.empty) {
                        // SOVRASCRIVI il documento esistente
                        const docId = snapshot.docs[0].id;
                        const docRef = doc(db, "ranking_history", docId);
                        await setDoc(docRef, lastGeneratedRanking);

                        // v3.5.0: Refresh immediato storico dopo salvataggio
                        const currentDate = document.getElementById('storico-data-picker')?.value;
                        if (currentDate) {
                            await loadStorico(currentDate);
                        }

                        showModal("‚úÖ Aggiornato!", `Ranking aggiornato (sovrascritto)!\nData: ${lastGeneratedRanking.data_partite}\nFiltro: ${lastGeneratedRanking.filtro_nome}\nPartite: ${lastGeneratedRanking.stats.totale_partite}`, () => { });
                    } else {
                        // CREA NUOVO documento
                        await addDoc(rankingHistoryCol, lastGeneratedRanking);

                        // v3.5.0: Refresh immediato storico dopo salvataggio
                        const currentDate = document.getElementById('storico-data-picker')?.value;
                        if (currentDate) {
                            await loadStorico(currentDate);
                        }

                        showModal("‚úÖ Salvato!", `Ranking salvato per tracking ML!\nData: ${lastGeneratedRanking.data_partite}\nFiltro: ${lastGeneratedRanking.filtro_nome}\nPartite: ${lastGeneratedRanking.stats.totale_partite}`, () => { });
                    }

                    // Disabilita bottone dopo salvataggio
                    const btn = document.getElementById('save-ranking-btn');
                    if (btn) {
                        btn.disabled = true;
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                        btn.innerHTML = '<i class="fa-solid fa-check mr-2"></i>Ranking Salvato';
                    }
                } catch (e) {
                    showModal("Errore", `Errore salvataggio: ${e.message}`, () => { });
                }
            }

            async function updateRankingResults(uploadedDate, uploadedMatches) {
                try {
                    const rankingHistoryCol = collection(db, "ranking_history");
                    const q = query(rankingHistoryCol, where("data_partite", "==", uploadedDate));
                    const snapshot = await getDocs(q);

                    if (snapshot.empty) {
                        return null; // Nessun ranking salvato per quella data
                    }

                    let totalUpdated = 0;
                    const performanceByFilter = {};

                    for (const docSnap of snapshot.docs) {
                        const ranking = docSnap.data();
                        let updated = false;

                        // Per ogni tip nel ranking
                        Object.keys(ranking.partite_by_tip).forEach(tip => {
                            ranking.partite_by_tip[tip].forEach(partitaRanking => {
                                // Trova match corrispondente nei risultati caricati
                                const match = uploadedMatches.find(m =>
                                    m.partita === partitaRanking.partita &&
                                    m.tip === partitaRanking.tip &&
                                    m.risultato
                                );

                                if (match && match.esito) {
                                    partitaRanking.esito = match.esito;
                                    partitaRanking.risultato = match.risultato;
                                    updated = true;
                                    totalUpdated++;
                                }
                            });
                        });

                        if (updated) {
                            // Calcola performance
                            let totalMatches = 0;
                            let wonMatches = 0;

                            Object.keys(ranking.partite_by_tip).forEach(tip => {
                                ranking.partite_by_tip[tip].forEach(p => {
                                    if (p.esito) {
                                        totalMatches++;
                                        if (p.esito === 'Vinto') wonMatches++;
                                    }
                                });
                            });

                            const winrate = totalMatches > 0 ? Math.round((wonMatches / totalMatches) * 100) : 0;
                            ranking.performance = {
                                totale: totalMatches,
                                vinte: wonMatches,
                                perse: totalMatches - wonMatches,
                                winrate: winrate
                            };

                            // Aggiorna su Firestore
                            await setDoc(doc(db, "ranking_history", docSnap.id), ranking);

                            performanceByFilter[ranking.filtro_nome] = ranking.performance;
                        }
                    }

                    return {
                        updated: totalUpdated,
                        performance: performanceByFilter
                    };
                } catch (e) {
                    console.error("Error updating ranking results:", e);
                    return null;
                }
            }

            // ==================== RANKING FUNCTIONS ====================
            // V3.4.5 - SCORE SPECIALE PER 0.5 HT
            function calculateScore05HT(partita, dbCompleto) {
                let score = 0;

                // Estrai HT prob
                let htProb = 0;
                if (partita.info_ht && partita.info_ht.trim() !== '') {
                    const htMatch = partita.info_ht.match(/(\d+)%/);
                    if (htMatch) htProb = parseInt(htMatch[1]);
                }

                // PESO 1: HT Probability (50% del score)
                if (htProb >= 85) score += 50;
                else if (htProb >= 80) score += 45;
                else if (htProb >= 75) score += 40;
                else if (htProb >= 70) score += 35;
                else if (htProb >= 65) score += 25;

                // PESO 2: Prolificit√† squadre Over 1.5 (30% del score)
                const teams = partita.partita.split(' - ');
                if (teams.length === 2 && dbCompleto && dbCompleto.length > 0) {
                    const teamHome = teams[0].trim();
                    const teamAway = teams[1].trim();

                    const homeStats = analyzeTeamStats(teamHome, true, '+1.5', dbCompleto);
                    const awayStats = analyzeTeamStats(teamAway, false, '+1.5', dbCompleto);

                    if (homeStats.total >= 5 && awayStats.total >= 5) {
                        const homePerc = (homeStats.count / homeStats.total) * 100;
                        const awayPerc = (awayStats.count / awayStats.total) * 100;
                        const avgPerc = (homePerc + awayPerc) / 2;

                        if (avgPerc >= 75) score += 30;
                        else if (avgPerc >= 65) score += 25;
                        else if (avgPerc >= 55) score += 20;
                        else if (avgPerc >= 45) score += 15;
                        else score += 10;
                    }
                }

                // PESO 3: Orario favorevole (20% del score - bonus)
                if (partita.time) {
                    const [hours] = partita.time.split(':').map(Number);
                    if (hours >= 17 && hours <= 22) score += 20; // Orario prime time
                    else if (hours >= 14 && hours <= 23) score += 10; // Orario buono
                }

                return {
                    teamBonus: score,
                    totalScore: Math.min(100, score),
                    quotaValid: true,
                    htProb: htProb
                };
            }

            function calculateScore(partita, legheSet, tipsSet, leaguePerformance = {}, dbCompleto = null) {
                // v3.5.0 - SCORE DA SCOREVALUE: usa direttamente score calcolato da analyzeTeamStats

                let score = 0;
                const tipNorm = (partita.tip || '').trim().toUpperCase();
                const mercato = (partita.mercato || '').toLowerCase().trim();

                // Se non ho DB, score 0
                if (!dbCompleto || dbCompleto.length === 0 || !partita.partita) {
                    return {
                        teamBonus: 0,
                        totalScore: 0,
                        quotaValid: true
                    };
                }

                const teams = partita.partita.split(' - ');
                if (teams.length !== 2) {
                    return {
                        teamBonus: 0,
                        totalScore: 0,
                        quotaValid: true
                    };
                }

                const teamHome = teams[0].trim();
                const teamAway = teams[1].trim();

                // Analizza statistiche squadre
                const homeStats = analyzeTeamStats(teamHome, true, tipNorm, dbCompleto);
                const awayStats = analyzeTeamStats(teamAway, false, tipNorm, dbCompleto);

                // ========== OVER/UNDER (+1.5, +2.5, -2.5, etc) ==========
                if (tipNorm.startsWith('+') || tipNorm.startsWith('-')) {
                    // Usa scoreValue DIRETTO da analyzeTeamStats
                    // Media dei due score
                    const avgScore = (homeStats.scoreValue + awayStats.scoreValue) / 2;
                    score = Math.round(avgScore);

                    // BOOST HT se disponibile (solo per OVER)
                    if (tipNorm.startsWith('+') && partita.info_ht && partita.info_ht.trim() !== '') {
                        const probMatch = partita.info_ht.match(/(\d+)%/);
                        if (probMatch) {
                            const htProb = parseInt(probMatch[1]);
                            if (htProb >= 75) score += 15;
                            else if (htProb >= 65) score += 10;
                            else if (htProb >= 55) score += 5;
                        }
                    }

                    // PENALIT√Ä HT alto (solo per UNDER)
                    if (tipNorm.startsWith('-') && partita.info_ht && partita.info_ht.trim() !== '') {
                        const probMatch = partita.info_ht.match(/(\d+)%/);
                        if (probMatch) {
                            const htProb = parseInt(probMatch[1]);
                            if (htProb >= 75) score -= 15;
                            else if (htProb >= 65) score -= 10;
                        }
                    }

                    return {
                        teamBonus: score,
                        totalScore: Math.max(0, Math.min(100, score)),
                        quotaValid: true
                    };
                }

                // ========== 1X2 / Doppia Chance ==========
                // Usa scoreValue DIRETTO da analyzeTeamStats
                const avgScore = (homeStats.scoreValue + awayStats.scoreValue) / 2;
                score = Math.round(avgScore);

                return {
                    teamBonus: score,
                    totalScore: Math.max(0, Math.min(100, score)),
                    quotaValid: true
                };
            }

            // ==================== CALCULATE SCORE 0.5 HT ====================

            function analyzeLeaguePerformance(dbCompleto) {
                if (!dbCompleto || dbCompleto.length === 0) return {};

                const leagueStats = {};

                dbCompleto.forEach(match => {
                    const lega = (match.lega || '').toLowerCase().trim();
                    if (!lega) return;

                    if (!leagueStats[lega]) {
                        leagueStats[lega] = {
                            totalMatches: 0,
                            over25Count: 0,
                            under25Count: 0,
                            tips: {}
                        };
                    }

                    leagueStats[lega].totalMatches++;

                    const risultato = match.risultato || '';
                    const golMatch = risultato.match(/(\d+)\s*-\s*(\d+)/);

                    let golTotali = 0;
                    if (golMatch) {
                        const golCasa = parseInt(golMatch[1]);
                        const golTrasferta = parseInt(golMatch[2]);
                        golTotali = golCasa + golTrasferta;

                        if (golTotali > 2.5) leagueStats[lega].over25Count++;
                        else leagueStats[lega].under25Count++;
                    }

                    const tip = (match.tip || '').trim();
                    if (tip) {
                        if (!leagueStats[lega].tips[tip]) {
                            leagueStats[lega].tips[tip] = { total: 0, success: 0 };
                        }

                        leagueStats[lega].tips[tip].total++;

                        let success = false;
                        if (golMatch && golTotali > 0) {
                            if (tip.startsWith('+')) {
                                const soglia = parseFloat(tip.substring(1));
                                success = golTotali > soglia;
                            } else if (tip.startsWith('-')) {
                                const soglia = parseFloat(tip.substring(1));
                                success = golTotali < soglia;
                            }
                        }

                        if (success) leagueStats[lega].tips[tip].success++;
                    }
                });

                Object.keys(leagueStats).forEach(lega => {
                    const stats = leagueStats[lega];
                    stats.over25Percentage = (stats.over25Count / stats.totalMatches * 100).toFixed(0);
                    stats.under25Percentage = (stats.under25Count / stats.totalMatches * 100).toFixed(0);

                    Object.keys(stats.tips).forEach(tip => {
                        const tipStats = stats.tips[tip];
                        tipStats.successRate = (tipStats.success / tipStats.total * 100).toFixed(0);
                    });
                });

                return leagueStats;
            }

            function analyzeTeamStats(teamName, isHome, tip, dbCompleto) {
                if (!dbCompleto || dbCompleto.length === 0) {
                    return { color: 'black', stats: '', count: 0, total: 0, percentage: 0, penalty: 0, scoreValue: 0, details: '' };
                }

                const teamNorm = teamName.toLowerCase().trim();

                // v3.5.0 NUOVA LOGICA: Calcolo preciso score + penalit√†
                const isOverUnder = tip.startsWith('+') || tip.startsWith('-');

                let relevantMatches = [];

                // Filtra match ultimi 6 mesi con risultato
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

                if (isOverUnder) {
                    // OVER/UNDER: Tutti i match della squadra (ultimi 15)
                    const allTeamMatches = dbCompleto.filter(row => {
                        if (!row.risultato || row.risultato.trim() === '') return false;

                        const matchDate = new Date(row.data || '2000-01-01');
                        if (matchDate < sixMonthsAgo) return false;

                        const team1 = (row.partita || '').split(' - ')[0]?.toLowerCase().trim() || '';
                        const team2 = (row.partita || '').split(' - ').slice(1).join(' - ')?.toLowerCase().trim() || '';
                        return (team1 === teamNorm || team2 === teamNorm);
                    });

                    allTeamMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                    relevantMatches = allTeamMatches.slice(0, 15);

                } else {
                    // 1X2/DC: Match casa o trasferta (ultimi 5)
                    let locationMatches = dbCompleto.filter(row => {
                        if (!row.risultato || row.risultato.trim() === '') return false;

                        const matchDate = new Date(row.data || '2000-01-01');
                        if (matchDate < sixMonthsAgo) return false;

                        const team1 = (row.partita || '').split(' - ')[0]?.toLowerCase().trim() || '';
                        const team2 = (row.partita || '').split(' - ').slice(1).join(' - ')?.toLowerCase().trim() || '';

                        if (isHome) return team1 === teamNorm;
                        else return team2 === teamNorm;
                    });

                    locationMatches.sort((a, b) => new Date(b.data || '2000-01-01') - new Date(a.data || '2000-01-01'));
                    relevantMatches = locationMatches.slice(0, 5); // Solo ultimi 5 per 1X2/DC
                }

                // Minimo match richiesti
                const minMatches = isOverUnder ? 5 : 3;
                if (relevantMatches.length < minMatches) {
                    return {
                        color: 'gray',
                        stats: `(${relevantMatches.length})`,
                        count: 0,
                        total: relevantMatches.length,
                        percentage: 0,
                        penalty: 0,
                        scoreValue: 0,
                        details: `Dati insufficienti (min ${minMatches})`
                    };
                }

                let successCount = 0;
                let penalty = 0;
                let detailsArray = [];

                relevantMatches.forEach(match => {
                    const risultato = match.risultato || '';
                    const golMatch = risultato.match(/(\d+)\s*-\s*(\d+)/);

                    if (!golMatch) return;

                    const golCasa = parseInt(golMatch[1]);
                    const golTrasferta = parseInt(golMatch[2]);
                    const golTotali = golCasa + golTrasferta;

                    const team1 = (match.partita || '').split(' - ')[0]?.toLowerCase().trim() || '';
                    const isTeamHome = team1 === teamNorm;

                    let success = false;

                    if (tip.startsWith('+')) {
                        // OVER: conta gol totali > soglia
                        const soglia = parseFloat(tip.substring(1));
                        success = golTotali > soglia;

                        // Penalit√† -5 per ogni 0-0
                        if (golCasa === 0 && golTrasferta === 0) {
                            penalty += 5;
                            detailsArray.push(`0-0 (-5 pen)`);
                        }

                    } else if (tip.startsWith('-')) {
                        // UNDER: conta gol totali < soglia
                        const soglia = parseFloat(tip.substring(1));
                        success = golTotali < soglia;

                        // Penalit√† -5 per ogni 4+ gol (se Under 3.5)
                        if (soglia <= 3.5 && golTotali >= 4) {
                            penalty += 5;
                            detailsArray.push(`${golCasa}-${golTrasferta} 4+ gol (-5 pen)`);
                        }

                    } else if (tip === '1') {
                        // Casa vince (Tip 1)
                        if (isHome && isTeamHome) {
                            // Casa FAVORITA: conta vittorie
                            success = golCasa > golTrasferta;
                        } else if (!isHome && !isTeamHome) {
                            // Trasferta SFAVORITA: conta sconfitte
                            success = golTrasferta < golCasa;
                        }

                    } else if (tip === 'X') {
                        // Pareggio (Tip X)
                        // Entrambe contano pareggi
                        success = golCasa === golTrasferta;

                    } else if (tip === '2') {
                        // Trasferta vince (Tip 2)
                        if (!isHome && !isTeamHome) {
                            // Trasferta FAVORITA: conta vittorie
                            success = golTrasferta > golCasa;
                        } else if (isHome && isTeamHome) {
                            // Casa SFAVORITA: conta sconfitte
                            success = golCasa < golTrasferta;
                        }

                    } else if (tip === '1X') {
                        // Casa o Pareggio (Tip 1X)
                        if (isHome && isTeamHome) {
                            // Casa FAVORITA: conta non-sconfitte (V+P)
                            success = golCasa >= golTrasferta;
                        } else if (!isHome && !isTeamHome) {
                            // Trasferta SFAVORITA: conta sconfitte + pareggi (NON vittorie)
                            // Logica: vogliamo che NON vinca
                            success = golTrasferta <= golCasa;
                        }

                    } else if (tip === '12') {
                        // Casa o Trasferta (no pareggio) (Tip 12)
                        // Entrambe contano SOLO vittorie
                        const isVittoria = (isHome && isTeamHome && golCasa > golTrasferta) ||
                            (!isHome && !isTeamHome && golTrasferta > golCasa);
                        success = isVittoria;

                        // Penalit√† -5 per ogni pareggio
                        if (golCasa === golTrasferta) {
                            penalty += 5;
                            detailsArray.push(`${golCasa}-${golTrasferta} pareggio (-5 pen)`);
                        }

                    } else if (tip === 'X2') {
                        // Pareggio o Trasferta (Tip X2)
                        if (!isHome && !isTeamHome) {
                            // Trasferta FAVORITA: conta non-sconfitte (V+P)
                            success = golTrasferta >= golCasa;
                        } else if (isHome && isTeamHome) {
                            // Casa SFAVORITA: conta sconfitte + pareggi (NON vittorie)
                            // Logica: vogliamo che NON vinca
                            success = golCasa <= golTrasferta;
                        }
                    }

                    if (success) successCount++;
                });

                // Calcola percentuale ESATTA
                const percentage = relevantMatches.length > 0 ? (successCount / relevantMatches.length) * 100 : 0;

                // Score value = percentuale - penalit√†
                const scoreValue = Math.max(0, Math.round(percentage - penalty));

                // Colore basato su score finale
                let color = 'black';
                if (relevantMatches.length >= minMatches) {
                    if (scoreValue >= 70) color = 'green';
                    else if (scoreValue >= 50) color = 'yellow';
                    else color = 'red';
                }

                // Details string
                const details = detailsArray.length > 0 ? detailsArray.join(', ') : '';

                return {
                    color: color,
                    stats: `(${successCount}/${relevantMatches.length})`,
                    count: successCount,
                    total: relevantMatches.length,
                    percentage: Math.round(percentage),
                    penalty: penalty,
                    scoreValue: scoreValue,
                    details: details
                };
            }

            // ==================== MODAL ====================
            // showModal moved to top level


            // ==================== INIT APP ====================
            // Init App Logic wrapped in IIFE to ensure async context
            (async () => {
                try {
                    // Set Default Date for Results Upload to Yesterday
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    document.getElementById('results-date').value = yesterday.toISOString().split('T')[0];

                    // Set Default Date for Tips Upload to Today
                    document.getElementById('tips-date').value = new Date().toISOString().split('T')[0];

                    await loadSavedFilters();
                    showPage('page-dashboard');
                    updateTipsDaysList();
                    updateResultsDaysList();
                } catch (e) {
                    console.error("Error during init:", e);
                }
            })();
            // Removed late closing brace of startApp

            // End of Init Logic - Continuing with Helper Functions


            // Legacy Strategy Builder Logic removed to prevent conflicts with new implementation.

            // Legacy Load/Delete listeners removed.

            // ==================== TOOLTIP SYSTEM ====================

            // Crea elemento tooltip
            const tooltipEl = document.createElement('div');
            tooltipEl.id = 'custom-tooltip';
            tooltipEl.className = 'fixed bg-gray-900 text-white text-xs rounded-lg p-3 shadow-xl pointer-events-none z-[9999] max-w-xs';
            tooltipEl.style.display = 'none';
            document.body.appendChild(tooltipEl);

            // Mostra tooltip - VERSIONE USER-FRIENDLY v3.3
            function showTooltipCustom(element, type) {
                const rect = element.getBoundingClientRect();
                let content = '';

                if (type === 'score') {
                    const score = element.dataset.score || '0';
                    const legaScore = parseInt(element.dataset.legaScore) || 0;
                    const tipScore = parseInt(element.dataset.tipScore) || 0;
                    const probScore = parseInt(element.dataset.probScore) || 0;
                    const teamBonus = parseInt(element.dataset.teamBonus) || 0;
                    const htBonus = parseInt(element.dataset.htBonus) || 0;

                    // Genera spiegazione user-friendly
                    const reasons = [];

                    if (legaScore >= 15) reasons.push('üèÜ <strong>Lega top</strong> per questo mercato');
                    else if (legaScore >= 10) reasons.push('üèÜ Lega con buono storico');
                    else if (legaScore >= 5) reasons.push('üèÜ Lega nella media');

                    if (tipScore >= 15) reasons.push('‚úÖ <strong>Tip molto affidabile</strong> (storico >70%)');
                    else if (tipScore >= 10) reasons.push('‚úÖ Tip affidabile');

                    if (probScore >= 20) reasons.push('üìä <strong>Prob. eccellente</strong> (>80%)');
                    else if (probScore >= 15) reasons.push('üìä Prob. alta (>75%)');
                    else if (probScore >= 10) reasons.push('üìä Prob. buona (>70%)');

                    if (teamBonus >= 20) reasons.push('‚öΩ <strong>Squadre molto prolifiche</strong>');
                    else if (teamBonus >= 10) reasons.push('‚öΩ Squadre con buona tendenza gol');
                    else if (teamBonus < 0) reasons.push('‚ö†Ô∏è Squadre poco prolifiche');

                    if (htBonus >= 10) reasons.push('üî• <strong>HT molto alto</strong> - gol probabile 1¬∞T');
                    else if (htBonus >= 5) reasons.push('üí° HT buono');
                    else if (htBonus < 0) reasons.push('‚ö†Ô∏è HT sfavorevole per questa tip');

                    content = `
                    <div class="font-bold mb-2 text-center text-base">üìä PERCH√â SCORE ${score}</div>
                    <div class="space-y-2">
                        ${reasons.length > 0 ? reasons.map(r => `<div>${r}</div>`).join('') : '<div>Score nella media</div>'}
                    </div>
                    <div class="text-xs mt-3 pt-2 border-t border-gray-700 opacity-75 text-center">
                        <div>üî• 65+ = TOP | ‚ö° 50-64 = BUONO</div>
                        <div>üí° 30-49 = MEDIO | ‚ö†Ô∏è <30 = SKIP</div>
                    </div>
                `;
                } else if (type === 'stats') {
                    const mercato = element.dataset.mercato || '';
                    const tip = element.dataset.tip || '';
                    const homeCount = parseInt(element.dataset.homeCount) || 0;
                    const homeTotal = parseInt(element.dataset.homeTotal) || 0;
                    const awayCount = parseInt(element.dataset.awayCount) || 0;
                    const awayTotal = parseInt(element.dataset.awayTotal) || 0;

                    // v3.5.0: Dati estesi da analyzeTeamStats
                    const homePerc = parseInt(element.dataset.homePerc) || (homeTotal > 0 ? Math.round((homeCount / homeTotal) * 100) : 0);
                    const awayPerc = parseInt(element.dataset.awayPerc) || (awayTotal > 0 ? Math.round((awayCount / awayTotal) * 100) : 0);
                    const homePenalty = parseInt(element.dataset.homePenalty) || 0;
                    const awayPenalty = parseInt(element.dataset.awayPenalty) || 0;
                    const homeScore = parseInt(element.dataset.homeScore) || 0;
                    const awayScore = parseInt(element.dataset.awayScore) || 0;
                    const homeDetails = element.dataset.homeDetails || '';
                    const awayDetails = element.dataset.awayDetails || '';

                    const homeColor = homePerc >= 70 ? 'üü¢' : homePerc >= 50 ? 'üü°' : 'üî¥';
                    const awayColor = awayPerc >= 70 ? 'üü¢' : awayPerc >= 50 ? 'üü°' : 'üî¥';

                    // Per mercato GOL mostra tendenza gol
                    if (mercato.toLowerCase().includes('gol') || mercato.toLowerCase().includes('goal') || tip.startsWith('+') || tip.startsWith('-')) {
                        const tipLabel = tip.startsWith('+') ? `Over ${tip.substring(1)}` : tip.startsWith('-') ? `Under ${tip.substring(1)}` : tip;

                        // Valutazione complessiva
                        const avgScore = (homeScore + awayScore) / 2;
                        let verdict = '';
                        if (avgScore >= 70) verdict = '<div class="text-green-400 font-bold mt-2">‚úÖ OTTIMA AFFIDABILIT√Ä</div>';
                        else if (avgScore >= 50) verdict = '<div class="text-yellow-400 mt-2">üí° AFFIDABILIT√Ä MEDIA</div>';
                        else verdict = '<div class="text-red-400 mt-2">‚ö†Ô∏è BASSA AFFIDABILIT√Ä</div>';

                        content = `
                        <div class="font-bold mb-2 text-center">‚öΩ ${tipLabel} - DETTAGLIO PRECISO</div>
                        <div class="space-y-2 text-xs">
                            <div class="border-b border-gray-700 pb-1">
                                ${homeColor} <strong>Casa:</strong> ${homeCount}/${homeTotal} match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${homePerc}%
                                    ${homePenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${homePenalty} punti` : ''}
                                    ${homeDetails ? `<br>‚Ä¢ ${homeDetails}` : ''}
                                    <br>‚Ä¢ <strong>Score finale: ${homeScore}</strong>
                                </div>
                            </div>
                            <div class="pb-1">
                                ${awayColor} <strong>Trasferta:</strong> ${awayCount}/${awayTotal} match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${awayPerc}%
                                    ${awayPenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${awayPenalty} punti` : ''}
                                    ${awayDetails ? `<br>‚Ä¢ ${awayDetails}` : ''}
                                    <br>‚Ä¢ <strong>Score finale: ${awayScore}</strong>
                                </div>
                            </div>
                        </div>
                        ${verdict}
                        <div class="text-xs mt-2 pt-2 border-t border-gray-700 opacity-75">
                            <div><strong>Score medio partita: ${Math.round(avgScore)}</strong></div>
                            <div class="mt-1">70+ = TOP | 50-69 = BUONO | <50 = SKIP</div>
                        </div>
                    `;
                    } else {
                        // Per 1X2/Doppia Chance
                        const avgScore = (homeScore + awayScore) / 2;

                        content = `
                        <div class="font-bold mb-2 text-center">üìà ${tip} - FORMA DETTAGLIATA</div>
                        <div class="space-y-2 text-xs">
                            <div class="border-b border-gray-700 pb-1">
                                ${homeColor} <strong>Casa:</strong> ${homeCount}/${homeTotal} ultimi match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${homePerc}%
                                    ${homePenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${homePenalty} punti` : ''}
                                    <br>‚Ä¢ <strong>Score: ${homeScore}</strong>
                                </div>
                            </div>
                            <div class="pb-1">
                                ${awayColor} <strong>Trasferta:</strong> ${awayCount}/${awayTotal} ultimi match
                                <div class="pl-4 mt-1">
                                    ‚Ä¢ Percentuale: ${awayPerc}%
                                    ${awayPenalty > 0 ? `<br>‚Ä¢ Penalit√†: -${awayPenalty} punti` : ''}
                                    <br>‚Ä¢ <strong>Score: ${awayScore}</strong>
                                </div>
                            </div>
                        </div>
                        <div class="text-xs mt-2 pt-2 border-t border-gray-700 opacity-75">
                            <div><strong>Score medio: ${Math.round(avgScore)}</strong></div>
                            <div class="mt-1">80+ = OTTIMA | 60-79 = BUONA | <60 = INCERTA</div>
                        </div>
                    `;
                    }
                }

                tooltipEl.innerHTML = content;
                tooltipEl.style.display = 'block';

                // Posiziona tooltip - FIX: Rimuovi scrollY perch√© √® position: fixed
                setTimeout(() => {
                    const tooltipRect = tooltipEl.getBoundingClientRect();
                    let top = rect.top - tooltipRect.height - 10;
                    let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);

                    // Evita overflow top/bottom/left/right
                    if (top < 0) top = rect.bottom + 10;
                    if (left < 10) left = 10;
                    if (left + tooltipRect.width > window.innerWidth) {
                        left = window.innerWidth - tooltipRect.width - 10;
                    }

                    tooltipEl.style.top = `${top}px`; // FIX: Solo top relativo a viewport
                    tooltipEl.style.left = `${left}px`;
                }, 0);
            }

            // Nascondi tooltip
            function hideTooltipCustom() {
                tooltipEl.style.display = 'none';
            }

            // Event delegation per tooltip - FIX: Usa mouseover per bubbling corretto
            document.addEventListener('mouseover', (e) => {
                const trigger = e.target.closest('.tooltip-trigger');
                if (trigger && trigger.dataset.tooltipType) {
                    showTooltipCustom(trigger, trigger.dataset.tooltipType);
                } else {
                    hideTooltipCustom();
                }
            });

            document.addEventListener('mouseout', (e) => {
                // Lascia che mouseover gestisca la scomparsa se esce dal trigger
                const related = e.relatedTarget;
                const trigger = e.target.closest('.tooltip-trigger');
                if (trigger && (!related || !trigger.contains(related))) {
                    hideTooltipCustom();
                }
            });
            // ==================== CLIENT PRESET GENERATION (V4.0) ====================
            async function calculateAndSaveClientPresets(matchesToProcess = allMatches) {
                console.log("Generating Client Presets with Historical Stats...");
                const statusEl = document.getElementById('auth-status');
                if (statusEl) statusEl.textContent = "Calcolo Statistiche Storiche...";

                try {
                    // 1. Fetch EXISTING Presets (to protect manual changes)
                    let existingPresets = {};
                    try {
                        const presetsDoc = await getDoc(doc(db, "system", "client_presets"));
                        if (presetsDoc.exists()) {
                            existingPresets = presetsDoc.data();
                        }
                    } catch (e) {
                        console.warn("Could not fetch existing presets, starting fresh.", e);
                    }

                    // 2. Helper to calculate stats for a set of leagues
                    const calculateStats = (leaguesFilter) => {
                        let total = 0, wins = 0, lost = 0, voided = 0;
                        matchesToProcess.forEach(m => {
                            const lega = normalizeLega(m.lega);
                            // If leaguesFilter is empty/null, it means ALL leagues
                            if (!leaguesFilter || leaguesFilter.length === 0 || leaguesFilter.includes(lega)) {
                                total++;
                                if (m.esito === 'Vinto') wins++;
                                else if (m.esito === 'Perso') lost++;
                                else voided++;
                            }
                        });
                        const winrate = (wins + lost) > 0 ? (wins / (wins + lost)) * 100 : 0;
                        return { total, wins, lost, voided, winrate: parseFloat(winrate.toFixed(1)) };
                    };

                    // --- GENERATION LOGIC ---
                    const leagueStats = {};
                    matchesToProcess.forEach(m => {
                        const lega = normalizeLega(m.lega);
                        if (!leagueStats[lega]) leagueStats[lega] = { total: 0, wins: 0 };
                        leagueStats[lega].total++;
                        if (m.esito === 'Vinto') leagueStats[lega].wins++;
                    });

                    const generatedLeagues = {
                        winrate_80: [],
                        italia: [],
                        top_eu: [],
                        cups: []
                    };

                    const topEuLeagues = ['premier league', 'la liga', 'serie a', 'bundesliga', 'ligue 1'];
                    const cupKeywords = ['champions league', 'europa league', 'conference league'];

                    Object.keys(leagueStats).forEach(lega => {
                        const stats = leagueStats[lega];
                        const winrate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                        const legaLower = lega.toLowerCase();

                        if (winrate >= 80 && stats.total >= 5) generatedLeagues.winrate_80.push(lega);
                        if (legaLower.includes('italy') || legaLower.includes('ita ')) generatedLeagues.italia.push(lega);
                        if (topEuLeagues.some(l => legaLower.includes(l) && !legaLower.includes('women') && !legaLower.includes('u19') && !legaLower.includes('u21'))) generatedLeagues.top_eu.push(lega);
                        if (cupKeywords.some(k => legaLower.includes(k))) generatedLeagues.cups.push(lega);
                    });
                    // ------------------------

                    // 4. Build Final Object
                    // Structure: key: { leagues: [], stats: {} }
                    // For 'all', leagues is null/empty (implies all)

                    const finalPresets = {
                        'all': {
                            leagues: [], // All leagues
                            stats: calculateStats(null)
                        },
                        'winrate_80': {
                            leagues: generatedLeagues.winrate_80, // Always regenerated based on data
                            stats: calculateStats(generatedLeagues.winrate_80)
                        },
                        'italia': {
                            leagues: (existingPresets.italia && existingPresets.italia.leagues && existingPresets.italia.leagues.length > 0) ? existingPresets.italia.leagues : generatedLeagues.italia,
                            stats: {} // Calculated below
                        },
                        'top_eu': {
                            leagues: (existingPresets.top_eu && existingPresets.top_eu.leagues && existingPresets.top_eu.leagues.length > 0) ? existingPresets.top_eu.leagues : generatedLeagues.top_eu,
                            stats: {} // Calculated below
                        },
                        'cups': {
                            leagues: (existingPresets.cups && existingPresets.cups.leagues && existingPresets.cups.leagues.length > 0) ? existingPresets.cups.leagues : generatedLeagues.cups,
                            stats: {} // Calculated below
                        },
                        'best_05_ht': {
                            leagues: [], // Not league based
                            stats: {} // Calculated below
                        }
                    };

                    // Add Custom Strategies from savedFilters
                    if (savedFilters && savedFilters.length > 0) {
                        savedFilters.forEach(strat => {
                            if (strat.type === 'local') { // Only local strategies for now? Or public too? User said "Magic AI che ho creato io"
                                finalPresets[strat.id] = {
                                    name: strat.name,
                                    leagues: strat.state.leagues || [],
                                    tips: strat.state.tips || [],
                                    odds: strat.state.odds || [],
                                    stats: {} // Calculated below
                                };
                            }
                        });
                    }

                    // Helper to calculate stats using filterMatchesByStrategy
                    const calcStatsForFilter = (filterKey, filterObj) => {
                        let filtered = [];
                        if (filterKey === 'best_05_ht') {
                            // Special Logic for Best 0.5 HT
                            filtered = matchesToProcess.filter(m => {
                                if (m.info_ht && m.info_ht.trim() !== '') {
                                    const htMatch = m.info_ht.match(/(\d+)%/);
                                    if (htMatch) {
                                        const htProb = parseInt(htMatch[1]);
                                        return htProb >= 70 && m.tip.startsWith('+');
                                    }
                                }
                                return false;
                            });
                        } else {
                            // Use generic helper
                            // Construct filter object compatible with helper
                            const f = {
                                leagues: filterObj.leagues,
                                tips: filterObj.tips,
                                odds: filterObj.odds
                            };
                            filtered = filterMatchesByStrategy(matchesToProcess, f);
                        }

                        let total = filtered.length, wins = 0, lost = 0, voided = 0;
                        filtered.forEach(m => {
                            if (m.esito === 'Vinto') wins++;
                            else if (m.esito === 'Perso') lost++;
                            else voided++;
                        });
                        const winrate = (wins + lost) > 0 ? (wins / (wins + lost)) * 100 : 0;
                        return { total, wins, lost, voided, winrate: parseFloat(winrate.toFixed(1)) };
                    };

                    // Calculate stats for ALL presets
                    Object.keys(finalPresets).forEach(key => {
                        finalPresets[key].stats = calcStatsForFilter(key, finalPresets[key]);
                    });


                    // 5. Save Presets to System
                    await setDoc(doc(db, "system", "client_presets"), {
                        ...finalPresets,
                        lastUpdated: Date.now()
                    });
                    console.log("Client Presets Saved with Stats!", finalPresets);

                    // 6. Save Daily Matches (Standard Logic)
                    const rankingDateInput = document.getElementById('ranking-date');
                    let targetDate = rankingDateInput && rankingDateInput.value ? rankingDateInput.value : null;

                    if (targetDate) {
                        let matchesForClient = matchesToProcess.filter(m => m.data === targetDate);

                        // Fallback logic
                        if (matchesForClient.length === 0 && matchesToProcess.length > 0) {
                            const dateCounts = {};
                            matchesToProcess.forEach(m => {
                                if (m.data) dateCounts[m.data] = (dateCounts[m.data] || 0) + 1;
                            });
                            const mostCommonDate = Object.keys(dateCounts).sort((a, b) => dateCounts[b] - dateCounts[a])[0];
                            if (mostCommonDate) {
                                console.log(`[Auto-Detect] No matches for ${targetDate}, switching to ${mostCommonDate}`);
                                targetDate = mostCommonDate;
                                matchesForClient = matchesToProcess.filter(m => m.data === targetDate);
                            }
                        }

                        await setDoc(doc(db, "client_data", "daily_matches"), {
                            date: targetDate,
                            matches: matchesForClient,
                            lastUpdated: Date.now()
                        });
                        console.log(`Daily Matches for ${targetDate} Saved! (${matchesForClient.length} matches)`);
                    } else {
                        console.log("No date selected. Skipping daily_matches save.");
                    }

                    return {
                        totalMatches: matchesToProcess.length,
                        presets: {
                            all: finalPresets.all.stats.total,
                            winrate_80: finalPresets.winrate_80.stats.total,
                            italia: finalPresets.italia.stats.total,
                            top_eu: finalPresets.top_eu.stats.total,
                            cups: finalPresets.cups.stats.total,
                            best_05_ht: finalPresets.best_05_ht.stats.total
                        },
                        fullPresets: finalPresets // Return full object for league lists
                    };
                } catch (e) {
                    console.error("Error generating client presets:", e);
                    return null;
                }
            }

            // REMOVED handleSendHistory
            // document.getElementById('send-history-btn')?.addEventListener('click', handleSendHistory);
        }); // Close DOMContentLoaded
        // ==================== AI KNOWLEDGE BASE UPLOAD ====================
        const uploadAiBtn = document.getElementById('upload-ai-knowledge-btn');

        // Populate Custom Strategies Dropdown
        async function populateAiStrategySelect() {
            const selectGroup = document.getElementById('ai-custom-strats-group');
            if (!selectGroup) return;

            selectGroup.innerHTML = ''; // Clear

            try {
                // Use savedFilters loaded from Firestore (via loadSavedFilters)
                // Ensure savedFilters is populated (it is loaded in init)
                if (typeof savedFilters !== 'undefined' && savedFilters.length > 0) {
                    savedFilters.forEach(strat => {
                        const option = document.createElement('option');
                        option.value = strat.id; // e.g. "magic_ai_123"
                        option.textContent = strat.name;
                        selectGroup.appendChild(option);
                    });
                }
            } catch (e) {
                console.warn("Error populating AI dropdown:", e);
            }
        }

        // Call it after init
        setTimeout(populateAiStrategySelect, 2000); // Wait for loadSavedFilters

        if (uploadAiBtn) {
            uploadAiBtn.addEventListener('click', async () => {
                const stratId = document.getElementById('ai-strat-id').value; // Value from SELECT
                const desc = document.getElementById('ai-strat-desc').value.trim();
                const fileInput = document.getElementById('ai-csv-file');
                const statusEl = document.getElementById('ai-upload-status');

                if (!stratId) {
                    alert("Inserisci un ID Strategia (es. top_eu)");
                    return;
                }

                statusEl.textContent = "Elaborazione in corso...";
                statusEl.className = "text-sm text-blue-600 block mt-2";
                statusEl.classList.remove('hidden');

                let uniqueLeagues = [];

                // Helper to save to Firestore
                const saveToFirestore = async (leagues) => {
                    try {
                        const docRef = doc(db, "strategies_metadata", "definitions");
                        const updateData = {};
                        updateData[stratId] = {
                            name: stratId,
                            description: desc,
                            leagues: leagues,
                            lastUpdated: new Date().toISOString()
                        };

                        await setDoc(docRef, updateData, { merge: true });

                        statusEl.innerHTML = `<i class="fa-solid fa-check-circle text-green-500"></i> Salvato con successo! (${leagues.length} leghe)`;
                        statusEl.className = "text-sm text-green-600 block mt-2";
                    } catch (e) {
                        console.error("Error saving AI knowledge:", e);
                        statusEl.textContent = "Errore salvataggio: " + e.message;
                        statusEl.className = "text-sm text-red-600 block mt-2";
                    }
                };

                if (fileInput.files.length > 0) {
                    Papa.parse(fileInput.files[0], {
                        header: true,
                        skipEmptyLines: true,
                        complete: function (results) {
                            const leagues = new Set();
                            results.data.forEach(row => {
                                if (row.lega) {
                                    // Clean league name (remove EU-, AS-, etc.)
                                    const cleanLega = row.lega.replace(/^(EU-|AS-|AF-|NA-|SA-)/, '').trim();
                                    leagues.add(cleanLega);
                                }
                            });
                            uniqueLeagues = Array.from(leagues).sort();
                            saveToFirestore(uniqueLeagues);
                        },
                        error: function (err) {
                            statusEl.textContent = "Errore CSV: " + err.message;
                            statusEl.className = "text-sm text-red-600 block mt-2";
                        }
                    });
                } else {
                    // Save without leagues (just description update)
                    saveToFirestore([]);
                }
            });
        }

    </script>
    </div>
</body>

</html>